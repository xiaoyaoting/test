const fs = require('fs-extra');
const path = require('path');
const isEmpty = require('lodash.isempty');
const safeStringify = require('fast-safe-stringify').default;
const { createLogger, format, transports } = require('winston');
const debug = require('debug');
const rfs = require('rotating-file-stream');
require('winston-daily-rotate-file');
const { LOG_RETAIN_IN_DAYS } = require('@abtnode/constant');
const CustomRotateFileTransport = require('./transport');
const { getAccessLogFilenameGenerator } = require('./util');

const instanceMap = new Map();

const getNoopLogger = (label = '') => {
  if (process.env.DEBUG) {
    const d = debug(label);
    return {
      error: d,
      warn: d,
      info: d,
      verbose: d,
      debug: d,
      silly: d,
    };
  }

  return {
    error: () => {},
    warn: () => {},
    info: () => {},
    verbose: () => {},
    debug: () => {},
    silly: () => {},
  };
};

// singleton per process
let addedRejectionExceptionTransport = false;

const customPrintfCallback = ({ level, message, label, timestamp, metadata, [Symbol.for('splat')]: splat }) => {
  let result = `[${process.pid}] [${timestamp}] [${level}]`;
  if (label) {
    result = `${result} [${label}]`;
  }

  if (!isEmpty(message)) {
    result = `${result} [${message}]`;
  }

  let newMetaData = metadata;
  if (isEmpty(newMetaData) && !isEmpty(splat)) {
    newMetaData = { data: splat[0] };
  }

  if (!isEmpty(newMetaData)) {
    if (newMetaData.error && newMetaData.error instanceof Error) {
      const { error } = newMetaData;
      newMetaData.error = error.message;
      newMetaData.error_stack = error.stack;
    }

    result = `${result} ${safeStringify(newMetaData)}`;
  }

  return result;
};

const initLogger =
  (label = '') =>
  ({
    logDir = process.env.ABT_NODE_LOG_DIR,
    filename = 'daemon',
    retain,
    level = process.env.ABT_NODE_LOG_LEVEL,
  } = {}) => {
    if (!logDir) {
      return getNoopLogger(label);
    }

    const logger = createLogger({
      format: format.combine(
        format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
        format.label({ label }),
        format.metadata({ fillExcept: ['message', 'level', 'timestamp', 'label'] }),
        format.printf(customPrintfCallback)
      ),
    });

    if (process.env.NODE_ENV === 'production') {
      logger.level = level || 'info';
      if (!fs.existsSync(logDir)) {
        fs.mkdirSync(logDir, { recursive: true });
      }

      const rotateConfig = {
        datePattern: 'YYYY-MM-DD',
        dirname: logDir,
        zippedArchive: true,
        createSymlink: true,
        maxSize: '20m',
      };

      const infoAuditFilename = `.${filename}-info.audit.json`;
      const errorAuditFilename = `.${filename}-error.audit.json`;

      const infoRotateFileParams = {
        ...rotateConfig,
        filename: `${filename}-%DATE%.log`,
        ignoreLevels: ['error'],
        symlinkName: `${filename}.log`,
        auditFile: path.join(logDir, infoAuditFilename),
      };

      const errorRotateFileParams = {
        ...rotateConfig,
        filename: `${filename}-error-%DATE%.log`,
        symlinkName: `${filename}-error.log`,
        auditFile: path.join(logDir, errorAuditFilename),
        level: 'error',
      };

      if (typeof retain === 'number') {
        infoRotateFileParams.maxFiles = retain;
        errorRotateFileParams.maxFiles = retain;
      }

      logger.add(new transports.DailyRotateFile(errorRotateFileParams));
      logger.add(new CustomRotateFileTransport(infoRotateFileParams));

      if (!addedRejectionExceptionTransport) {
        logger.rejections.handle(
          new transports.File({
            filename: path.join(logDir, 'stderr.log'),
          })
        );

        logger.exceptions.handle(
          new transports.File({
            filename: path.join(logDir, 'stderr.log'),
          })
        );

        addedRejectionExceptionTransport = true;
      }
    } else {
      logger.level = level || 'debug';
      const transport = new transports.Console();

      logger.add(transport);

      if (!addedRejectionExceptionTransport) {
        logger.rejections.handle(transport);
        logger.exceptions.handle(transport);
        addedRejectionExceptionTransport = true;
      }
    }

    return logger;
  };

const getLogger = (label = '', options = {}) => {
  if (!instanceMap.has(label)) {
    instanceMap.set(label, initLogger(label)({ retain: LOG_RETAIN_IN_DAYS, ...options }));
  }

  return instanceMap.get(label);
};

const deleteOldLogfiles = (file, retain) => {
  if (typeof retain !== 'number') {
    return;
  }

  if (file === '/dev/null') {
    return;
  }

  const extname = path.extname(file);
  const fileBaseName = `${path.basename(file, extname)}`;
  const dirName = path.dirname(file);
  const files = fs.readdirSync(dirName);
  let i;
  let len;
  const rotatedFiles = [];
  for (i = 0, len = files.length; i < len; i++) {
    if (files[i].startsWith(`${fileBaseName}-`)) {
      rotatedFiles.push(files[i]);
    }
  }

  rotatedFiles.sort().reverse();

  for (i = rotatedFiles.length - 1; i >= retain; i--) {
    fs.unlinkSync(path.resolve(dirName, rotatedFiles[i]));
  }
};

const getAccessLogStream = (dir, filename = 'access.log') => {
  const stream = rfs.createStream(getAccessLogFilenameGenerator(filename), {
    interval: '1d',
    path: dir,
    compress: 'gzip',
  });

  stream.on('rotated', () => {
    deleteOldLogfiles(path.join(dir, filename), LOG_RETAIN_IN_DAYS);
  });

  return stream;
};

module.exports = getLogger;
module.exports.initLogger = initLogger;
module.exports.getNoopLogger = getNoopLogger;
module.exports.customPrintfCallback = customPrintfCallback;
module.exports.getInstanceSize = () => instanceMap.size;
module.exports.getAccessLogStream = getAccessLogStream;
module.exports.deleteOldLogfiles = deleteOldLogfiles;
