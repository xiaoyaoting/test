const fs = require('fs');
const { CancelToken } = require('axios');
const streamToPromise = require('stream-to-promise');
const tryWithTimeout = require('./try-with-timeout');
const axios = require('./axios');

const CANCEL = '__cancel__';

/**
 *
 *
 * @param {Stream} stream
 * @returns {Promise<string>}
 */
async function getErrorMessageFromStream(stream) {
  const str = await streamToString(stream);

  try {
    const json = JSON.parse(str);
    return json.error;
  } catch (error) {
    return str;
  }
}

/**
 *
 *
 * @param {*} stream
 * @return {Promise<string>}
 */
async function streamToString(stream) {
  const chunks = [];

  for await (const chunk of stream) {
    chunks.push(Buffer.from(chunk));
  }

  return Buffer.concat(chunks).toString('utf-8');
}

/**
 *
 *
 * @param {*} url
 * @param {*} dest directory
 * @param {{
 *  timeout: number; // unit: ms
 *  cancelCtrl: any;
 * }} [{ timeout = 600 * 1000, cancelCtrl, data }={}]
 * @param {{}} context
 * @return {*}
 */
const downloadFile = async (url, dest, { timeout = 600 * 1000, cancelCtrl } = {}, context = {}) => {
  const CONNECTION_TIMEOUT = 20 * 1000;
  const source = CancelToken.source();

  try {
    return await tryWithTimeout(async () => {
      const timer = setTimeout(() => {
        source.cancel(`Connection timeout: ${Math.ceil(CONNECTION_TIMEOUT / 1000)}s`);
      }, CONNECTION_TIMEOUT);

      let fileStream;

      if (cancelCtrl) {
        cancelCtrl.cancel = () => {
          clearTimeout(timer);
          cancelCtrl.isCancelled = true;
          source.cancel('Manual cancel');
          if (fileStream) {
            fileStream.destroy(new Error('Manual cancel'));
            fileStream = null;
          }
        };
      }

      const response = await axios({
        url,
        headers: context?.headers,
        method: 'GET',
        responseType: 'stream',
        cancelToken: source.token,
        timeout,
      });
      clearTimeout(timer);
      fileStream = response.data.pipe(fs.createWriteStream(dest));
      await streamToPromise(fileStream);

      if (cancelCtrl && cancelCtrl.isCancelled) {
        if (fs.existsSync(dest)) {
          fs.unlinkSync(dest);
        }
        return CANCEL;
      }

      if (response.data.complete === false) {
        throw new Error('download incomplete');
      }

      return dest;
    }, timeout);
  } catch (err) {
    if (fs.existsSync(dest)) {
      fs.unlinkSync(dest);
    }

    if (err.message === 'Manual cancel') {
      if (cancelCtrl && cancelCtrl.isCancelled) {
        return CANCEL;
      }
      throw new Error('Manual stop abnormal');
    }

    source.cancel();

    if (err?.response?.data) {
      throw new Error(await getErrorMessageFromStream(err.response.data));
    }

    throw err;
  }
};

downloadFile.CancelCtrl = class {
  constructor() {
    this.isCancelled = false;
  }

  cancel() {
    throw new Error('This method should be rewrite inside downloadFile');
  }
};

downloadFile.CANCEL = CANCEL;

module.exports = downloadFile;
