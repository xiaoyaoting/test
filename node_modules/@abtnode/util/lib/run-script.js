/* eslint-disable prefer-const */
/* eslint-disable no-nested-ternary */
const fs = require('fs');
const which = require('which');
const stream = require('stream');
const spawn = require('cross-spawn');

class PrefixTransform extends stream.Transform {
  constructor(prefix, state) {
    super();

    this.prefix = prefix;
    this.state = state;
  }

  // transform all output from child process with a prefix for better readability
  _transform(chunk, _encoding, callback) {
    const { prefix, state } = this;
    const nPrefix = `\n${prefix}`;
    const firstPrefix = state.lastIsLineBreak ? prefix : state.lastPrefix !== prefix ? '\n' : '';
    const prefixed = `${firstPrefix}${chunk}`.replace(/\n/g, nPrefix);
    const index = prefixed.indexOf(prefix, Math.max(0, prefixed.length - prefix.length));

    state.lastPrefix = prefix;
    state.lastIsLineBreak = index !== -1;

    callback(null, index !== -1 ? prefixed.slice(0, index) : prefixed);
  }
}

const wrapStream = (next, prefix, state) => {
  const transform = new PrefixTransform(`[${prefix}] `, state);
  transform.pipe(next);
  return transform;
};

/**
 * Run script with a childProcess.spawn
 *
 * @param {string} script
 * @param {string} label
 * @param {object} options.env
 * @param {string} options.cwd
 * @param {number} options.timeout
 * @param {bool} options.silent
 * @return {Promise}
 */
const runScript = (script, label, options = {}) => {
  if (!script) {
    throw new Error('script is required');
  }
  if (!label) {
    throw new Error('label is required');
  }

  let child = null;

  const cleanup = () => {
    if (child) {
      child.kill();
      child = null;
    }
  };

  const promise = new Promise((resolve, reject) => {
    process.stdout.setMaxListeners(0);
    process.stderr.setMaxListeners(0);

    let [command, ...args] = script.split(' ');
    if (fs.existsSync(command) === false) {
      command = which.sync(command);
      if (!command) {
        reject(new Error(`Command not found: ${command}`));
        return;
      }
    }

    const state = {
      lastPrefix: null,
      lastIsLineBreak: true,
    };

    const stdout = wrapStream(process.stdout, label, state);
    const stderr = wrapStream(process.stderr, label, state);

    child = spawn(command, args, {
      timeout: 2 * 60 * 1000,
      detached: false,
      shell: false,
      stdio: ['ignore', 'pipe', 'pipe'],
      ...options,
    });

    if (!options.silent) {
      child.stdout.pipe(stdout, { end: false });
      child.stderr.pipe(stderr, { end: false });
    }

    let hasUnhandledRejection = false;
    const errorMessages = [];
    child.stderr.on('data', (err) => {
      errorMessages.push(err);
      if (err.includes('UnhandledPromiseRejectionWarning')) {
        hasUnhandledRejection = true;
      }
    });

    child.on('error', (err) => {
      console.error(err);
      errorMessages.push(err.message);
      return reject(new Error(errorMessages.join('\r\n')));
    });

    child.on('close', (code) => {
      if (errorMessages.length > 0) {
        if (code !== 0 || hasUnhandledRejection) {
          return reject(new Error(errorMessages.join('\r\n')));
        }
      }

      return resolve({ code, script });
    });
  });

  promise.abort = cleanup;

  return promise;
};

module.exports = runScript;
