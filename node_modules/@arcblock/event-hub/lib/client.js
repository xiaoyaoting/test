// eslint-disable-next-line max-classes-per-file
const { EventEmitter } = require('events');
const axon = require('axon');
const roundrobin = require('axon/lib/plugins/round-robin');
const queue = require('axon/lib/plugins/queue');
const { fromSecretKey } = require('@ocap/wallet');
const JWT = require('@arcblock/jwt');
const { toTypeInfo } = require('@arcblock/did');

const { RESERVED_EVENT_PREFIX, EVENT_AUTH, EVENT_AUTH_FAIL } = require('./constant');

const checkEvent = (event) => {
  if (event.startsWith(RESERVED_EVENT_PREFIX)) {
    throw new Error(`event cannot start with ${RESERVED_EVENT_PREFIX}`);
  }
};

const defaultOpts = {
  port: undefined,
  hostname: '0.0.0.0',
  autoConnect: false,
  did: undefined,
  pk: undefined,
  sk: undefined,
};

class Socket extends axon.SubEmitterSocket {
  constructor(opts) {
    super();

    this.sock.use((sock) => {
      sock.on('connect', () => {
        const { did, pk, sk } = opts;
        sock.send(EVENT_AUTH, {
          pk,
          token: JWT.sign(did, sk),
        });

        sock.on(EVENT_AUTH_FAIL, ({ msg } = {}) => {
          this.emit('error', { msg });
          sock.close();
        });
      });
    });

    this.sock.use(queue());
    this.sock.use(roundrobin({ fallback: this.sock.enqueue }));
    this.send = this.sock.send.bind(this.sock);
  }
}

class Client extends EventEmitter {
  constructor(opts = {}) {
    super();

    if (!opts.port) {
      throw new Error('port should not be empty');
    }

    if (!opts.did || !opts.sk) {
      throw new Error('did, sk should not be empty');
    }

    const wallet = fromSecretKey(opts.sk, toTypeInfo(opts.did));

    if (wallet.address !== opts.did) {
      throw new Error('did, sk does not match');
    }

    this.opts = Object.assign({}, defaultOpts, opts, { pk: wallet.publicKey });
    this._client = new Socket(this.opts);

    this._bindEvent();

    if (this.opts.autoConnect) {
      this.connect();
    }
  }

  connect() {
    const { port, hostname } = this.opts;
    this._client.connect(port, hostname);
  }

  close() {
    this._client.close();
  }

  broadcast(event, data) {
    checkEvent(event);
    this._client.send(event, data);
  }

  on(name, fn) {
    checkEvent(name);
    super.on(name, fn);
    this._client.on(name, fn);
  }

  off(name, fn) {
    checkEvent(name);
    this._client.off(name);

    if (fn) {
      super.off(name, fn);
    } else {
      super.removeAllListeners(name);
    }
  }

  _bindEvent() {
    this._client.on('error', this.emit.bind(this, 'error'));
  }
}

module.exports = Client;
