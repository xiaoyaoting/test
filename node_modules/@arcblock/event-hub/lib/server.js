/* eslint-disable no-console */
const axon = require('axon');
const Message = require('amp-message');

const JWT = require('@arcblock/jwt');

const { EVENT_AUTH, EVENT_AUTH_FAIL } = require('./constant');

const getDid = (jwt) => jwt.iss.replace(/^did:abt:/, '');

class Server extends axon.Socket {
  constructor() {
    super();
    this.on('message', (event, data, sock) => {
      const { channel } = sock;
      if (!sock.channel) {
        console.error('skip message of unauthenticated socket');
        return;
      }
      this.send(event, data, channel);
    });

    this.on('connect', (socket) => {
      console.log('event-hub client connected', socket._peername);
    });
    this.on('reconnect attempt', (socket) => {
      console.log('event-hub client reconnect', socket._peername);
    });
    this.on('disconnect', (socket) => {
      console.log('event-hub client disconnected', socket._peername);
    });
    this.on('drop', (args) => {
      console.log('event-hub server drop message', args);
    });
    this.on('error', (err) => {
      console.log('event-hub server error', err);
    });
  }

  onmessage(sock) {
    return (buf) => {
      const msg = new Message(buf);
      const [event, data] = msg.args;
      if (event === EVENT_AUTH) {
        try {
          // verify
          const { pk, token } = data;
          if (!JWT.verify(token, pk)) {
            throw new Error('token verify failed');
          }

          // set channel as did
          const did = getDid(JWT.decode(token));
          sock.channel = did;
        } catch (err) {
          console.error(err);
          const resBuf = this.pack([EVENT_AUTH_FAIL, { msg: err.message }]);
          sock.write(resBuf);
        }
        return;
      }

      this.emit('message', event, data, sock);
    };
  }

  send(event, data, channel) {
    const { socks } = this;

    const buf = this.pack([event, data]);

    for (let i = 0; i < socks.length; i++) {
      const sock = socks[i];
      if (sock.channel === channel) {
        if (sock.writable) sock.write(buf);
      }
    }

    return this;
  }
}

module.exports = Server;
