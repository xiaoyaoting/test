"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Secp256k1Signer = void 0;
const elliptic_1 = __importDefault(require("elliptic"));
const util_1 = require("@ocap/util");
const randombytes_1 = __importDefault(require("randombytes"));
const signer_1 = __importDefault(require("../protocols/signer"));
const encode_1 = require("../encode");
/* eslint-disable class-methods-use-this */
/* eslint-disable no-useless-constructor */
const EC = elliptic_1.default.ec;
const secp256k1 = new EC('secp256k1');
/**
 * Signer implementation for secp256k1, based on `elliptic`
 *
 * @class Secp256k1Signer
 */
class Secp256k1Signer extends signer_1.default {
    constructor() {
        super();
        this.pkHasFormatPrefix = true;
        this.pkCompressed = false;
    }
    isValidSK(sk) {
        if (sk.byteLength !== 32) {
            return false;
        }
        const bn = new util_1.BN(sk);
        return bn.cmp(secp256k1.curve.n) < 0 && !bn.isZero();
    }
    /**
     * @public
     * @typedefKeyPairType
     * @prop {string} publicKey - publicKey in hex format
     * @prop {string} secretKey - secretKey in hex format
     * @memberof Secp256k1Signer
     */
    /**
     * Generate random secret/public key pair
     */
    genKeyPair(encoding = 'hex') {
        let sk = null;
        do {
            sk = new Uint8Array((0, randombytes_1.default)(32));
        } while (!this.isValidSK(sk));
        const pk = this.getPublicKey((0, util_1.toHex)(sk));
        return { secretKey: (0, encode_1.encode)(sk, encoding), publicKey: (0, encode_1.encode)(pk, encoding) };
    }
    /**
     * Get publicKey from secretKey
     */
    getPublicKey(sk, encoding = 'hex') {
        if (!this.isValidSK((0, util_1.toUint8Array)(sk))) {
            throw new Error('Invalid secret key');
        }
        let pk = secp256k1.keyFromPrivate((0, util_1.toBuffer)(sk)).getPublic(this.pkCompressed, 'hex');
        if (this.pkHasFormatPrefix === false) {
            pk = pk.slice(2);
        }
        return (0, encode_1.encode)(`0x${pk}`, encoding);
    }
    /**
     * Sign a message and get the signature hex
     */
    sign(message, sk, encoding = 'hex') {
        let msg = message;
        try {
            msg = (0, util_1.toUint8Array)(message);
        }
        catch (err) {
            // Do nothing;
        }
        const signature = secp256k1
            .keyFromPrivate((0, util_1.toBuffer)(sk))
            .sign((0, util_1.stripHexPrefix)(msg), { canonical: true })
            .toDER('hex');
        return (0, encode_1.encode)(`0x${signature}`, encoding);
    }
    /**
     * Verify if a signature is valid
     */
    verify(message, signature, pk) {
        let msg = message;
        try {
            msg = (0, util_1.toUint8Array)(message);
        }
        catch (err) {
            // Do nothing;
        }
        let pkBuffer = (0, util_1.toBuffer)(pk);
        if (this.pkHasFormatPrefix === false && pkBuffer[0] !== 0x04 && pkBuffer.byteLength === 64) {
            pkBuffer = Buffer.concat([Buffer.from([0x04]), pkBuffer]);
        }
        return secp256k1.keyFromPublic(pkBuffer).verify((0, util_1.stripHexPrefix)(msg), (0, util_1.stripHexPrefix)((0, util_1.toHex)(signature)));
    }
}
exports.Secp256k1Signer = Secp256k1Signer;
exports.default = new Secp256k1Signer();
