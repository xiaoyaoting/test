/// <reference types="node" />
import { EncodingType, BytesType } from '@ocap/util';
import { DidType, DIDType, DIDTypeStr, DIDTypeArg } from '@arcblock/did';
declare type KeyPairType<T extends BytesType = string> = {
    sk?: T;
    pk?: T;
    address?: string;
};
export declare type SerializedWallet = {
    type: DIDTypeStr;
    pk: string;
    sk: string;
    address: string;
};
export interface WalletObject<T extends BytesType = string> {
    type: DIDType;
    secretKey: T;
    publicKey: T;
    address: string;
    hash(data: BytesType, round?: number, encoding?: 'hex'): string;
    hash(data: BytesType, round?: number, encoding?: 'base16'): string;
    hash(data: BytesType, round?: number, encoding?: 'base58'): string;
    hash(data: BytesType, round?: number, encoding?: 'base64'): string;
    hash(data: BytesType, round?: number, encoding?: 'buffer'): Buffer;
    hash(data: BytesType, round?: number, encoding?: 'Uint8Array'): Uint8Array;
    hash(data: BytesType, round?: number, encoding?: EncodingType): BytesType;
    sign(data: BytesType, hashBeforeSign?: boolean, encoding?: 'hex'): string;
    sign(data: BytesType, hashBeforeSign?: boolean, encoding?: 'base16'): string;
    sign(data: BytesType, hashBeforeSign?: boolean, encoding?: 'base58'): string;
    sign(data: BytesType, hashBeforeSign?: boolean, encoding?: 'base64'): string;
    sign(data: BytesType, hashBeforeSign?: boolean, encoding?: 'buffer'): Buffer;
    sign(data: BytesType, hashBeforeSign?: boolean, encoding?: 'Uint8Array'): Uint8Array;
    sign(data: BytesType, hashBeforeSign?: boolean, encoding?: EncodingType): BytesType;
    verify(data: BytesType, signature: BytesType, hashBeforeVerify?: boolean): boolean;
    ethHash(data: string): string;
    ethSign(data: string, hashBeforeSign?: boolean): string;
    ethVerify(data: string, signature: string, hashBeforeVerify?: boolean): boolean;
    toJSON(): SerializedWallet;
    /**
     * @deprecated ES6: use `wallet.address` instead
     */
    toAddress(): string;
}
export declare const WalletType: typeof DidType;
/**
 * Generate an wallet instance that can be used to sign a message or verify a signature
 */
export declare function Wallet<T extends BytesType = string>(keyPair: KeyPairType<T>, t?: DIDTypeArg): WalletObject<T>;
/**
 * Generate a wallet from secretKey
 *
 * @example
 * const assert = require('assert');
 * const { fromSecretKey } = require('@ocap/wallet');
 *
 * const sk =
 *   '0xD67C071B6F51D2B61180B9B1AA9BE0DD0704619F0E30453AB4A592B036EDE644E4852B7091317E3622068E62A5127D1FB0D4AE2FC50213295E10652D2F0ABFC7';
 * const sig =
 *   '0x08a102851c38c072e42756c1cc70938b5499c8e9358dfe5f383823f56cdb282ffda60fcd581a02c6c673069e5afc0bf09abbe3639b61b84d64fd58ef9f083003';
 *
 * const wallet = fromSecretKey(sk, type);
 * const message = 'data to sign';
 * const signature = wallet.sign(message);
 * assert.equal(signature, sig, "signature should match");
 * assert.ok(wallet.verify(message, signature), "signature should be verified");
 */
export declare function fromSecretKey<T extends BytesType = string>(sk: T, _type?: DIDTypeArg): WalletObject<T>;
/**
 * Generate a wallet from publicKey
 */
export declare function fromPublicKey<T extends BytesType = string>(pk: T, _type?: DIDTypeArg): WalletObject<T>;
/**
 * Generate a wallet from address (did)
 *
 * Since we do not know the publicKey and secretKey, this kind of wallet cannot be used for signing and verifying
 */
export declare function fromAddress<T extends BytesType = string>(address: string): WalletObject<T>;
/**
 * Generate a wallet by generating a random secretKey
 */
export declare function fromRandom<T extends BytesType = string>(_type?: DIDTypeArg): WalletObject<T>;
/**
 * Generating a wallet from a serialized json presentation of another wallet
 */
export declare function fromJSON<T extends BytesType = string>(json: SerializedWallet): WalletObject<T>;
/**
 * Check if an object is valid wallet object
 */
export declare function isValid(wallet: WalletObject, canSign?: boolean): boolean;
export {};
