"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DIDExtension = void 0;
const isEqual_1 = __importDefault(require("lodash/isEqual"));
const mcrypto_1 = require("@ocap/mcrypto");
const did_1 = require("@arcblock/did");
const ruleTypes = {
    pk: Object.keys(mcrypto_1.types.KeyType),
    hash: Object.keys(mcrypto_1.types.HashType),
    role: Object.keys(mcrypto_1.types.RoleType),
};
function DIDExtension(root) {
    return {
        type: 'DID',
        base: root.string().trim(),
        messages: {
            'did.empty': 'Expect {{#label}} to be non-empty string, got "{{#value}}"',
            'did.invalid': 'Expect {{#label}} to be valid did, got "{{#value}}"',
            'did.wallet': 'Expect wallet type of {{#label}} to be "{{#expected}}" wallet, got "{{#actual}}"',
            'did.pk': 'Expect pk type of {{#label}} to be "{{#expected}}", got "{{#actual}}"',
            'did.hash': 'Expect hash type of {{#label}} to be "{{#expected}}", got "{{#actual}}"',
            'did.role': 'Expect role type of {{#label}} to be "{{#expected}}", got "{{#actual}}"',
            'did.prefix': 'Expect prefix of {{#label}} to be "{{#expected}}"',
        },
        validate(value, helpers) {
            if (!value || typeof value !== 'string') {
                return { errors: helpers.error('did.empty', { value }) };
            }
            if ((0, did_1.isValid)(value) === false) {
                return { errors: helpers.error('did.invalid', { value }) };
            }
            return { value };
        },
        rules: {
            type: {
                args: [
                    {
                        name: 'key',
                        ref: true,
                        assert: (v) => Object.keys(ruleTypes).includes(v),
                        message: `must be one of ${Object.keys(ruleTypes).join(', ')}`,
                    },
                    {
                        name: 'expected',
                        // @ts-ignore
                        assert: (v) => Object.keys(ruleTypes).some((x) => ruleTypes[x].includes(v)),
                        message: 'must be valid type',
                    },
                ],
                // The rule return structure is different from the root
                // eslint-disable-next-line consistent-return
                validate(value, helpers, args) {
                    const typeStr = (0, did_1.toTypeInfoStr)(value);
                    if (args.key === 'pk' && typeStr.pk !== args.expected) {
                        return helpers.error('did.pk', Object.assign(Object.assign({}, args), { actual: typeStr.pk }));
                    }
                    if (args.key === 'hash' && typeStr.hash !== args.expected) {
                        return helpers.error('did.hash', Object.assign(Object.assign({}, args), { actual: typeStr.hash }));
                    }
                    if (args.key === 'role' && typeStr.role !== args.expected) {
                        return helpers.error('did.role', Object.assign(Object.assign({}, args), { actual: typeStr.role }));
                    }
                    return value;
                },
            },
            pk: {
                method(type) {
                    // @ts-ignore
                    return this.$_addRule({ name: 'type', args: { key: 'pk', expected: type } });
                },
            },
            hash: {
                method(type) {
                    // @ts-ignore
                    return this.$_addRule({ name: 'type', args: { key: 'hash', expected: type } });
                },
            },
            role: {
                method(type) {
                    // @ts-ignore
                    return this.$_addRule({ name: 'type', args: { key: 'role', expected: type } });
                },
            },
            wallet: {
                method(type) {
                    // @ts-ignore
                    return this.$_addRule({ name: 'wallet', args: { type } });
                },
                args: [
                    {
                        name: 'type',
                        ref: true,
                        assert: (v) => ['arcblock', 'ethereum', 'default', 'eth'].includes(v),
                        message: 'must be a string',
                        normalize: (v) => v.trim(),
                    },
                ],
                validate(value, helpers, args = {}) {
                    const type = (0, did_1.toTypeInfo)(value);
                    const typeStr = (0, did_1.toTypeInfoStr)(value);
                    if (['ethereum', 'eth'].includes(args.type) && (0, isEqual_1.default)(type, did_1.DID_TYPE_ETHEREUM) === false) {
                        return helpers.error('did.wallet', { expected: args.type, actual: JSON.stringify(typeStr) });
                    }
                    if (['arcblock', 'default'].includes(args.type) && (0, isEqual_1.default)(type, did_1.DID_TYPE_ARCBLOCK) === false) {
                        return helpers.error('did.wallet', { expected: args.type, actual: JSON.stringify(typeStr) });
                    }
                    return value;
                },
            },
            prefix: {
                method(str = '') {
                    // @ts-ignore
                    return this.$_addRule({ name: 'prefix', args: { str } });
                },
                args: [
                    {
                        name: 'str',
                        ref: true,
                        assert: (v) => ['', did_1.DID_PREFIX].includes(v),
                        message: 'must be a string',
                        normalize: (v) => v.trim(),
                    },
                ],
                validate(value, helpers, args = {}) {
                    if (args.str && value.startsWith(args.str) === false) {
                        return helpers.error('did.prefix', { expected: args.str });
                    }
                    if (!args.str && (0, did_1.toAddress)(value) !== value) {
                        return helpers.error('did.prefix', { expected: args.str });
                    }
                    return value;
                },
            },
        },
    };
}
exports.DIDExtension = DIDExtension;
