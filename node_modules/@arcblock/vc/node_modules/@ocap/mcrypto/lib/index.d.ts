/// <reference types="node" />
import { BytesType, EncodingType, KeyPairType } from '@ocap/util';
import { LiteralUnion } from 'type-fest';
export declare type KeyType = LiteralUnion<'ED25519' | 'SECP256K1' | 'ETHEREUM', string>;
export declare type HashType = LiteralUnion<'KECCAK' | 'SHA3' | 'KECCAK_384' | 'SHA3_384' | 'KECCAK_512' | 'SHA3_512' | 'SHA2', string>;
export declare type RoleType = LiteralUnion<'ROLE_ACCOUNT' | 'ROLE_NODE' | 'ROLE_DEVICE' | 'ROLE_APPLICATION' | 'ROLE_SMART_CONTRACT' | 'ROLE_BOT' | 'ROLE_ASSET' | 'ROLE_STAKE' | 'ROLE_VALIDATOR' | 'ROLE_GROUP' | 'ROLE_GROUP' | 'ROLE_TX' | 'ROLE_TETHER' | 'ROLE_SWAP' | 'ROLE_DELEGATION' | 'ROLE_VC' | 'ROLE_BLOCKLET' | 'ROLE_STORE' | 'ROLE_TOKEN' | 'ROLE_FACTORY' | 'ROLE_ROLLUP' | 'ROLE_ANY', string>;
export declare type AddressType = LiteralUnion<'BASE16' | 'BASE58', string>;
export interface HashFnType {
    (data: BytesType, round: number, encoding?: 'hex'): string;
    (data: BytesType, round: number, encoding?: 'base16'): string;
    (data: BytesType, round: number, encoding?: 'base58'): string;
    (data: BytesType, round: number, encoding?: 'base64'): string;
    (data: BytesType, round: number, encoding?: 'buffer'): Buffer;
    (data: BytesType, round: number, encoding?: 'Uint8Array'): Uint8Array;
    (data: BytesType, round: number, encoding?: EncodingType): BytesType;
}
export interface SignerType {
    genKeyPair(encoding?: EncodingType, seed?: BytesType): KeyPairType;
    getPublicKey(sk: BytesType, encoding?: 'hex'): string;
    getPublicKey(sk: BytesType, encoding?: 'base16'): string;
    getPublicKey(sk: BytesType, encoding?: 'base58'): string;
    getPublicKey(sk: BytesType, encoding?: 'base64'): string;
    getPublicKey(sk: BytesType, encoding?: 'buffer'): Buffer;
    getPublicKey(sk: BytesType, encoding?: 'Uint8Array'): Uint8Array;
    getPublicKey(sk: BytesType, encoding?: EncodingType): BytesType;
    sign(data: BytesType, sk: BytesType, encoding?: 'hex'): string;
    sign(data: BytesType, sk: BytesType, encoding?: 'base16'): string;
    sign(data: BytesType, sk: BytesType, encoding?: 'base58'): string;
    sign(data: BytesType, sk: BytesType, encoding?: 'base64'): string;
    sign(data: BytesType, sk: BytesType, encoding?: 'buffer'): Buffer;
    sign(data: BytesType, sk: BytesType, encoding?: 'Uint8Array'): Uint8Array;
    sign(data: BytesType, sk: BytesType, encoding?: EncodingType): BytesType;
    verify(data: BytesType, pk: BytesType, signature: BytesType): boolean;
    ethHash?(data: string): string;
    ethSign?(data: string, sk: string): string;
    ethVerify?(data: string, pk: string, signature: BytesType): boolean;
    ethRecover?(hash: string, signature: string): string;
}
/**
 * Contains all supported signers, eg: `Ed25519` and `Secp256k1`
 *
 * @readonly
 * @type {object}
 * @name Signer
 * @static
 * @example
 * const { Signer } = require('@ocap/mcrypto');
 * const message = 'some message to sign';
 *
 * // Use Signer directly
 * const keyPair = Signer.Ed25519.genKeyPair();
 * const signature = Signer.Ed25519.sign(message, keyPair.secretKey);
 * const result = Signer.Ed25519.verify(message, signature, keyPair.publicKey);
 * assert.ok(result);
 */
export declare const Signer: {
    Ed25519: import("./signer/ed25519").Ed25519Signer;
    Secp256k1: import("./signer/secp256k1").Secp256k1Signer;
    Ethereum: import("./signer/ethereum").EthereumSigner;
};
/**
 * Contains all supported hasher, eg: `SHA2`,`SHA3` and `Keccak`, each of them supports `hash224`, `hash256`, `hash384`, `hash512`
 *
 * @readonly
 * @type {object}
 * @name Hasher
 * @static
 * @example
 * const { Hasher } = require('@ocap/mcrypto');
 *
 * const message = 'message to hash';
 * const hash = Hasher.SHA2.hash256(message);
 */
export declare const Hasher: {
    SHA2: import("./hasher/sha2").Sha2Hasher;
    SHA3: import("./hasher/sha3").Sha3Hasher;
    Keccak: import("./hasher/keccak").KeccakHasher;
};
/**
 * Contains type constants that represent can be used to compose different crypto method, each crypto method consist one of:
 * FIXME: enum definition of forge-abi and abt-did-elixir are not exactly the same
 *
 * @readonly
 * @type {object}
 * @name types
 * @static
 * @example
 * const { types } = require('@ocap/mcrypto');
 *
 * // types.RoleType.ROLE_ACCOUNT
 * // types.KeyType.ED25519
 * // types.HashType.SHA3
 * // types.EncodingType.BASE58
 */
export declare const types: {
    /**
     * Key-pair derivation algorithms
     *
     * @readonly
     * @enum {number}
     * @name types.KeyType
     * @memberof types
     * @static
     */
    KeyType: {
        ED25519: number;
        SECP256K1: number;
        ETHEREUM: number;
    };
    /**
     * Hashing algorithms
     *
     * @readonly
     * @enum {number}
     * @name types.HashType
     * @memberof types
     * @static
     */
    HashType: {
        KECCAK: number;
        SHA3: number;
        KECCAK_384: number;
        SHA3_384: number;
        KECCAK_512: number;
        SHA3_512: number;
        SHA2: number;
    };
    /**
     * DID wallet role type
     *
     * @readonly
     * @enum {number}
     * @name types.RoleType
     * @memberof types
     * @static
     */
    RoleType: {
        ROLE_ACCOUNT: number;
        ROLE_NODE: number;
        ROLE_DEVICE: number;
        ROLE_APPLICATION: number;
        ROLE_SMART_CONTRACT: number;
        ROLE_BOT: number;
        ROLE_ASSET: number;
        ROLE_STAKE: number;
        ROLE_VALIDATOR: number;
        ROLE_GROUP: number;
        ROLE_TX: number;
        ROLE_TETHER: number;
        ROLE_SWAP: number;
        ROLE_DELEGATION: number;
        ROLE_VC: number;
        ROLE_BLOCKLET: number;
        ROLE_STORE: number;
        ROLE_TOKEN: number;
        ROLE_FACTORY: number;
        ROLE_ROLLUP: number;
        ROLE_STORAGE: number;
        ROLE_ANY: number;
    };
    /**
     * Address encoding algorithm, defaults to `base58btc`
     *
     * @readonly
     * @enum {number}
     * @name types.RoleType
     * @memberof types
     * @static
     */
    EncodingType: {
        BASE16: number;
        BASE58: number;
    };
};
/**
 * Get signer instance
 *
 * @function
 * @param {number} type - algorithm used to derive key pair, possible values are
 * - types.KeyType.ED25519
 * - types.KeyType.SECP256k1
 * - types.KeyType.ETHEREUM
 * @returns {object} signer instance
 * @example
 * const { getSigner, types } = require('@ocap/mcrypto');
 * const message = 'some message to sign';
 *
 * const signer = getSigner(types.KeyType.ED25519);
 * const keyPair1 = signer.genKeyPair();
 * const signature1 = signer.sign(message, keyPair1.secretKey);
 * const result1 = signer.verify(message, signature1, keyPair1.publicKey);
 * assert.ok(result1);
 */
export declare function getSigner(type: number): SignerType;
/**
 * Get hasher instance
 *
 * @function
 * @param {number} type - algorithm used to hash data, possible values
 * - types.HashType.KECCAK
 * - types.HashType.KECCAK_384
 * - types.HashType.KECCAK_512
 * - types.HashType.SHA3
 * - types.HashType.SHA3_384
 * - types.HashType.SHA3_512
 * @returns {object} hasher instance
 * @example
 * const { getHasher, types } = require('@ocap/mcrypto');
 *
 * const hashFn = getHasher(types.HashType.SHA3);
 * const hash2 = hashFn(message);
 */
export declare function getHasher(type: number): HashFnType;
/**
 * Get random bytes in specified encoding
 */
export declare function getRandomBytes(length: number, encoding?: 'hex'): string;
export declare function getRandomBytes(length: number, encoding?: 'base16'): string;
export declare function getRandomBytes(length: number, encoding?: 'base58'): string;
export declare function getRandomBytes(length: number, encoding?: 'base64'): string;
export declare function getRandomBytes(length: number, encoding?: 'buffer'): Buffer;
export declare function getRandomBytes(length: number, encoding?: 'Uint8Array'): Uint8Array;
export declare function getRandomBytes(length: number, encoding?: EncodingType): BytesType;
export declare const Signers: Readonly<{
    [x: number]: import("./signer/ed25519").Ed25519Signer | import("./signer/secp256k1").Secp256k1Signer;
}>;
export declare const Hashers: Readonly<{
    [x: number]: (data: BytesType, round?: number, encoding?: EncodingType) => BytesType;
}>;
export declare const toTxHash: (buf: Buffer | Uint8Array) => string;
