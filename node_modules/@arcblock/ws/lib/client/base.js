const createLogger = require('../logger');

module.exports = (Socket, EventEmitter, transport) => {
  return class WsClient extends Socket {
    constructor(endpoint, opts = {}) {
      super(endpoint, { transport, ...opts });

      this._logger = createLogger('client', opts.silent);
      this.emitter = new EventEmitter();

      this.onOpen(() => {
        this._logger.debug('socket open', endpoint);
      });
      this.onClose(() => {
        this._logger.debug('socket close', endpoint);
      });
      this.onError((err) => {
        this._logger.error('socket error', err.error);
      });
      this.onMessage((message) => {
        this._logger.debug('socket message', { message });
      });
    }

    on(event, handler) {
      this.ensureJoinChannel(event);
      this.emitter.on(event, handler);
    }

    off(event, handler) {
      if (handler) {
        this.emitter.off(event, handler);
      } else {
        this.emitter.removeAllListeners(event);
      }

      this.ensureLeaveChannel(event);
    }

    disconnect(callback, code, reason) {
      this.emitter.eventNames().forEach((event) => {
        this.emitter.removeAllListeners(event);
      });
      super.disconnect(callback, code, reason);
    }

    /**
     * private
     */
    ensureJoinChannel(event) {
      const count = this.emitter.listenerCount(event);
      if (count > 0) {
        return;
      }

      const topic = event;
      const channel = this.channel(topic);
      channel
        .join()
        .receive('ok', (message) => {
          this._logger.debug('join success', { event, message });
        })
        .receive('error', (error) => {
          this._logger.error('join error', { event, error });
        })
        .receive('timeout', () => {
          this._logger.debug('join timeout', { event });
        });
      channel.on(event, ({ status, response: data }) => {
        if (status === 'ok') {
          this.emitter.emit(event, data);
        } else {
          this._logger.debug('response error', { event, status, data });
        }
      });
    }

    /**
     * private
     */
    ensureLeaveChannel(event) {
      const count = this.emitter.listenerCount(event);
      if (count > 0) {
        return;
      }

      const topic = event;
      const channel = this.channels.find((c) => c.topic === topic);
      if (!channel) {
        return;
      }

      this.remove(channel);
      channel
        .leave()
        .receive('ok', (message) => {
          this._logger.debug('leave success', { event, message });
        })
        .receive('error', (err) => {
          this._logger.error('leave error', { event, err });
        })
        .receive('timeout', () => {
          this._logger.debug('leave timeout', { event });
        });
      channel.off(event);
    }
  };
};
