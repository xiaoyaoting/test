"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.didExtension = exports.fileExtension = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const did_1 = require("@arcblock/did");
const fileExtension = (joi) => ({
    type: 'file',
    base: joi.string(),
    validate(value, { error }) {
        if (value && typeof value === 'string') {
            return { value };
        }
        return { errors: error('file.empty', { file: value }) };
    },
    messages: {
        'file.empty': 'file "{{#file}}" must be non-empty string',
        'file.enoent': 'file "{{#file}}" does not exist',
        'file.error.generic': 'file could not be read. message: "{{#message}}"',
    },
    rules: {
        exists: {
            multi: false,
            method({ baseDir = null, canSkip = () => false } = {}) {
                return this.$_addRule({ name: 'exists', args: { baseDir, canSkip } });
            },
            args: [
                {
                    name: 'baseDir',
                    assert: (baseDir) => fs_1.default.existsSync(baseDir),
                    message: 'baseDir must exist',
                },
                {
                    name: 'canSkip',
                    assert: (canSkip) => typeof canSkip === 'function',
                    message: 'canSkip must be a function',
                },
            ],
            validate(value, { error }, { baseDir, canSkip } = {}) {
                if (typeof canSkip === 'function' && canSkip(baseDir, value)) {
                    return value;
                }
                try {
                    fs_1.default.statSync(path_1.default.join(baseDir, value));
                    return value;
                }
                catch (e) {
                    switch (e.code) {
                        case 'ENOENT':
                            return error('file.enoent', { file: value });
                        default:
                    }
                    return error('file.error.generic', { message: e.message });
                }
            },
        },
    },
});
exports.fileExtension = fileExtension;
const didExtension = (joi) => ({
    type: 'DID',
    base: joi.string(),
    validate(value, { error }) {
        if (!value || typeof value !== 'string') {
            return { errors: error('did.empty', { did: value }) };
        }
        if ((0, did_1.isValid)(value) === false) {
            return { errors: error('did.invalid', { did: value }) };
        }
        return { value };
    },
    messages: {
        'did.empty': 'did "{{#did}}" must be non-empty string',
        'did.invalid': 'did "{{#did}}" is not valid',
    },
});
exports.didExtension = didExtension;
exports.default = {
    fileExtension,
    didExtension,
};
