"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fixService = exports.fixInterfaces = exports.parsePerson = exports.formatPerson = exports.fixTags = exports.fixPerson = exports.fixKeywords = exports.fixFiles = exports.fixRepository = exports.fixRequired = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const get_1 = __importDefault(require("lodash/get"));
const gitInfo = __importStar(require("hosted-git-info"));
const debug_1 = __importDefault(require("debug"));
const validate_1 = require("./validate");
Object.defineProperty(exports, "fixService", { enumerable: true, get: function () { return validate_1.fixAndValidateService; } });
const constants_1 = __importDefault(require("./constants"));
const debug = (0, debug_1.default)('@blocklet/meta:fix');
const { BLOCKLET_DEFAULT_VERSION, BLOCKLET_DEFAULT_PORT_NAME, BLOCKLET_DYNAMIC_PATH_PREFIX, BLOCKLET_INTERFACE_TYPE_WEB, BLOCKLET_INTERFACE_PUBLIC, } = constants_1.default;
// Assign sensible defaults: description/main/group/version/public_url
const fixRequired = (data, dir) => {
    if (!data.description) {
        data.description = `Blocklet from ${dir}`;
    }
    if (!data.version) {
        data.version = BLOCKLET_DEFAULT_VERSION;
    }
    if (!data.main && !data.group) {
        debug('guess main and group', dir);
        data.group = 'static';
        const items = ['.'].concat(fs_1.default.readdirSync(dir));
        const item = items.find((x) => fs_1.default.existsSync(path_1.default.resolve(dir, x, 'index.html')) || fs_1.default.existsSync(path_1.default.resolve(dir, x, 'index.htm')));
        if (item) {
            data.main = item;
        }
    }
    if (!data.group) {
        const main = path_1.default.join(dir, data.main);
        try {
            const stat = fs_1.default.statSync(main);
            if (stat.isDirectory()) {
                data.group = 'static';
            }
            else {
                data.group = 'dapp';
            }
        }
        catch (err) {
            data.group = 'static';
        }
    }
};
exports.fixRequired = fixRequired;
const fixRepository = (data) => {
    if (!data.repository)
        return;
    if (typeof data.repository === 'string') {
        data.repository = {
            type: 'git',
            url: data.repository,
        };
    }
    if (data.repository.url) {
        const info = gitInfo.fromUrl(data.repository.url);
        if (info) {
            data.repository.url = info.getDefaultRepresentation() === 'shortcut' ? info.https() : info.toString();
        }
    }
};
exports.fixRepository = fixRepository;
const fixFiles = (data) => {
    if (!Array.isArray(data.files)) {
        delete data.files;
    }
    else if (data.files) {
        data.files = data.files.filter((file) => {
            return !(!file || typeof file !== 'string');
        });
    }
};
exports.fixFiles = fixFiles;
const fixKeywords = (data) => {
    if (typeof data.keywords === 'string') {
        data.keywords = data.keywords.split(/,\s+/);
    }
    if (data.keywords && !Array.isArray(data.keywords)) {
        delete data.keywords;
    }
    else if (data.keywords) {
        data.keywords = data.keywords.filter((kw) => {
            return !(typeof kw !== 'string' || !kw);
        });
    }
};
exports.fixKeywords = fixKeywords;
const fixTags = (data) => {
    if (typeof data.tags === 'string') {
        data.tags = data.tags.split(/,\s+/);
    }
    if (data.tags && !Array.isArray(data.tags)) {
        delete data.tags;
    }
    else if (data.tags) {
        data.tags = data.tags.filter((t) => {
            return !(typeof t !== 'string' || !t);
        });
    }
};
exports.fixTags = fixTags;
const updatePerson = (data, fn) => {
    if (data.author)
        data.author = fn(data.author);
    ['maintainers', 'contributors'].forEach((key) => {
        if (!Array.isArray(data[key])) {
            return;
        }
        data[key] = data[key].map(fn);
    });
    return data;
};
const formatPerson = (person) => {
    if (!person) {
        return '';
    }
    if (typeof person === 'string') {
        return person;
    }
    const name = person.name || '';
    const u = person.url || person.web;
    const url = u ? ` (${u})` : '';
    const e = person.email || person.mail;
    const email = e ? ` <${e}>` : '';
    return name + email + url;
};
exports.formatPerson = formatPerson;
const parsePerson = (person) => {
    if (typeof person !== 'string') {
        return person;
    }
    const name = person.match(/^([^(<]+)/);
    const url = person.match(/\(([^)]+)\)/);
    const email = person.match(/<([^>]+)>/);
    const obj = {};
    if (name && name[0].trim())
        obj.name = name[0].trim();
    if (email) {
        [, obj.email] = email;
    }
    if (url) {
        [, obj.url] = url;
    }
    return obj;
};
exports.parsePerson = parsePerson;
const fixPerson = (data) => {
    updatePerson(data, formatPerson);
    updatePerson(data, parsePerson);
    return data;
};
exports.fixPerson = fixPerson;
const fixInterfaces = (meta, removeMerged = true) => {
    if (!Array.isArray(meta.interfaces)) {
        meta.interfaces = [];
    }
    if (meta.interfaces.length) {
        // Web interfaces should always use http protocol
        meta.interfaces.forEach((x) => {
            if (x.type === BLOCKLET_INTERFACE_TYPE_WEB) {
                x.protocol = 'http';
            }
        });
        return meta;
    }
    const supportDynamicPathPrefix = (0, get_1.default)(meta, 'capabilities.dynamicPathPrefix', true);
    const prefix = supportDynamicPathPrefix ? BLOCKLET_DYNAMIC_PATH_PREFIX : '/';
    const addInterface = ({ type = 'web', name, path: _path = '/', // eslint-disable-line no-shadow
    protocol = 'http', port = BLOCKLET_DEFAULT_PORT_NAME, }) => {
        meta.interfaces.push({ type, name, path: _path, prefix, port, protocol });
    };
    [BLOCKLET_INTERFACE_PUBLIC].forEach((x) => {
        if (meta[x]) {
            addInterface({ name: x, path: meta[x] });
        }
    });
    if (Array.isArray(meta.exposeServices)) {
        meta.exposeServices.forEach((x) => {
            addInterface({
                type: 'service',
                name: x.protocol,
                protocol: x.protocol,
                port: {
                    internal: `BLOCKLET_${x.protocol}_PORT`.toUpperCase(),
                    external: x.port,
                },
            });
        });
    }
    if (removeMerged) {
        delete meta.publicUrl;
        delete meta.adminUrl;
        delete meta.configUrl;
        delete meta.docUrl;
        delete meta.exposeServices;
        if (meta.capabilities) {
            delete meta.capabilities.dynamicPathPrefix;
        }
    }
    return meta;
};
exports.fixInterfaces = fixInterfaces;
exports.default = {
    fixRequired,
    fixRepository,
    fixFiles,
    fixKeywords,
    fixPerson,
    fixTags,
    formatPerson,
    parsePerson,
    fixInterfaces,
    fixService: validate_1.fixAndValidateService,
};
