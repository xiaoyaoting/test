declare const checkLink: (value: string) => boolean;
interface DeepWalkCallback {
    (current: any, parent: any, options: DeepWalkCallbackOptions): void;
}
interface DeepWalkCallbackOptions {
    index: number;
    level: number;
}
/**
 *
 * @param {object} tree 需要深度遍历的数状结构
 * @param {function} cb 每一个节点的回调函数，回调的参数：当前节点数据，父亲节点数据，{index:当前节点所属的数组中的序号，level: 当前节点所处的深度}
 * @param {object} param 深度遍历的参数
 * @param {string} param.key 孩子数组的 key 值
 * @param {number} param.index 当前节点所属的数组中的序号
 * @param {object} param.parent 当前节点的父节点
 * @param {number} param.level 当前节点的深度
 */
type TreeNode<K extends string> = Record<string, any> & {
    [key in K]?: TreeNode<K>[];
};
declare function deepWalk<K extends string>(tree: TreeNode<K>, cb: DeepWalkCallback, { key, order }: {
    key: K;
    order?: 'first' | 'last';
}): void;
declare function deepWalk(tree: TreeNode<'children'>, cb: DeepWalkCallback, { key, order }?: {
    key?: 'children';
    order?: 'first' | 'last';
}): void;
/**
 * 判断一个传入值是否属于一个 section
 * @param {string | array} sections 需要判断的对象
 * @param {string} section 目标 section
 */
declare function isMatchSection(sections: string[] | string, section: string): boolean;
interface NavigationItem {
    id: string;
    role?: string;
    section?: string;
    title?: string;
    link?: string;
    items?: NavigationItem[];
    component?: string;
    child?: string;
    [key: string]: any;
}
interface ComponentItem {
    name: string;
    link: string;
}
declare function joinLink(navigation: NavigationItem, components: ComponentItem[]): NavigationItem;
interface FlatternNavigationOption {
    transform?: (current: any, parent?: any) => any;
    depth?: number;
}
/**
 * 将树状结构的导航列表进行扁平化处理
 * @param {array} navigationList 树状结构的导航列表
 * @param {object} params 配置参数
 * @param {number} params.depth 扁平化的层级，默认为 1（全拍平）
 * @param {function} params.transform 当发生拍平处理时
 * @returns 扁平化后的导航列表
 */
declare function flatternNavigation(list?: NavigationItem[], { depth, transform }?: FlatternNavigationOption): any[];
/**
 * 根据导航中每一个子菜单所属的 section，将原由的导航数据分离为多个导航数据（此时每一个导航 item 只会包含一个 section）
 * @param {array} navigation 导航列表数据（树状结构，目前只适用于两层的树状结构）
 * @returns
 */
declare function splitNavigationBySection(navigation: NavigationItem[]): any[];
/**
 * 将导航数据进行层叠处理
 * @param {array} list 扁平化的导航数据
 * @returns 处理后的导航
 */
declare function nestNavigationList(list?: any[]): any[];
declare function filterNavigation(navigationList: NavigationItem[], components?: ComponentItem[]): any[];
declare function cleanOrphanNavigation(list: NavigationItem[]): NavigationItem[];
interface Blocklet {
    settings?: {
        navigations?: NavigationItem[];
    };
}
interface ParseNavigationOption {
    beforeProcess?: (data: any) => any;
}
declare function parseNavigation(blocklet?: Blocklet, options?: ParseNavigationOption): {
    navigationList: any[];
    components: any[];
    builtinList: any[];
};
export { parseNavigation, deepWalk, isMatchSection, nestNavigationList, filterNavigation, cleanOrphanNavigation, joinLink, checkLink, flatternNavigation, splitNavigationBySection, };
