"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const get_1 = __importDefault(require("lodash/get"));
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const isEqual_1 = __importDefault(require("lodash/isEqual"));
const normalize_path_prefix_1 = __importDefault(require("@abtnode/util/lib/normalize-path-prefix"));
const parseLinkString = (link, prefix = '') => link.startsWith('/') ? (0, normalize_path_prefix_1.default)(`${prefix}${link || '/'}`) : link;
const parseLink = (input, prefix) => {
    if (Object.prototype.toString.call(input) === '[object Object]') {
        return Object.entries(input).reduce((o, [key, value]) => {
            o[key] = parseLinkString(value, prefix);
            return o;
        }, {});
    }
    return parseLinkString(input, prefix);
};
const getGroups = (navigation) => {
    const groups = {};
    for (const nav of navigation) {
        const sections = !nav.section || !nav.section.length ? ['__undefined__'] : nav.section;
        for (const sec of sections) {
            if (!groups[sec]) {
                groups[sec] = [];
            }
            const item = Object.assign({}, nav);
            if (nav.section) {
                item.section = sec === '__undefined__' ? [] : [sec];
            }
            groups[sec].push(item);
        }
    }
    return Object.values(groups);
};
const getChildName = (nav) => nav.component || nav.child;
const doParseNavigation = (navigation, blocklet, prefix = '/', _level = 1) => {
    const result = [];
    (navigation || []).forEach((nav) => {
        var _a, _b;
        if (!getChildName(nav)) {
            if (_level > 1 && ((_a = nav.items) === null || _a === void 0 ? void 0 : _a.length)) {
                const list = doParseNavigation(nav.items, blocklet, prefix, _level + 1);
                result.push(...list);
                return;
            }
            const item = {
                title: nav.title,
                id: undefined,
            };
            if (nav.section) {
                item.section = nav.section;
            }
            if (nav.icon) {
                item.icon = nav.icon;
            }
            if (nav.link) {
                item.link = parseLink(nav.link, prefix);
            }
            else {
                item.link = '';
            }
            if (nav.role) {
                item.role = nav.role;
            }
            if ((_b = nav.items) === null || _b === void 0 ? void 0 : _b.length) {
                const list = doParseNavigation(nav.items, blocklet, prefix, _level + 1);
                if (list.length) {
                    item.items = list;
                }
            }
            result.push(item);
            return;
        }
        if (!blocklet) {
            return;
        }
        // parse child
        const child = (blocklet.children || []).find((x) => [x.meta.name, x.meta.did].includes(getChildName(nav)));
        if (!child) {
            return;
        }
        const childTitle = child.meta.title || child.meta.name;
        const itemProto = {
            title: nav.title || childTitle,
            id: undefined,
        };
        if (nav.section) {
            itemProto.section = nav.section;
        }
        if (nav.icon) {
            itemProto.icon = nav.icon;
        }
        if (nav.role) {
            itemProto.role = nav.role;
        }
        // get groups by section
        const groups = getGroups((0, get_1.default)(child, 'meta.navigation', []));
        if (!groups.length) {
            // child does not declares menu
            const item = (0, cloneDeep_1.default)(itemProto);
            item.link = parseLink(child.mountPoint || '/', prefix);
            result.push(item);
        }
        else {
            for (const childNavigation of groups) {
                if (childNavigation.length === 1) {
                    // child declares one menu
                    const childNav = childNavigation[0];
                    const item = (0, cloneDeep_1.default)(itemProto);
                    item.title = nav.title || childNav.title || childTitle;
                    if (childNav.icon) {
                        item.icon = item.icon || childNav.icon;
                    }
                    if (childNav.role) {
                        item.role = item.role || childNav.role;
                    }
                    if (childNav.section) {
                        item.section = item.section || childNav.section;
                    }
                    item.link = parseLink(childNavigation[0].link || '/', (0, normalize_path_prefix_1.default)(`${prefix}${child.mountPoint}`));
                    // doParseNavigation because child nav depth may be > 1
                    const list = doParseNavigation(childNavigation, child, (0, normalize_path_prefix_1.default)(`${prefix}${child.mountPoint}`), _level + 1);
                    if (list.length > 1) {
                        // more than 1 child nav
                        delete item.link;
                        result.push(Object.assign(Object.assign({}, item), { items: list }));
                    }
                    else {
                        // only 1 child nav
                        item.link = list[0].link;
                        result.push(item);
                    }
                }
                else {
                    // child declares multiple menus
                    const groupSection = childNavigation[0].section || [];
                    const list = doParseNavigation(childNavigation, child, (0, normalize_path_prefix_1.default)(`${prefix}${child.mountPoint}`), _level + 1);
                    if (_level === 1) {
                        // primary menu
                        const item = (0, cloneDeep_1.default)(itemProto);
                        if (groupSection.length) {
                            item.section = item.section || groupSection;
                        }
                        item.items = list;
                        result.push(Object.assign(Object.assign({}, item), { items: list }));
                    }
                    else {
                        // secondary menu
                        result.push(...list);
                    }
                }
            }
        }
    });
    return result;
};
const markDuplicate = (navigation, compares = []) => {
    navigation.forEach((item) => {
        const compare = { link: item.link, section: item.section || [] };
        if (item.link && compares.some((x) => (0, isEqual_1.default)(x, compare))) {
            item.duplicate = true;
        }
        if (item.link) {
            compares.push(compare);
        }
        if (item.items) {
            markDuplicate(item.items, compares);
        }
    });
    return navigation;
};
const filterDuplicate = (navigation) => {
    const res = navigation.filter((x) => !x.duplicate);
    res.forEach((item) => {
        if (item.items) {
            item.items = filterDuplicate(item.items);
        }
    });
    return res;
};
const uniq = (navigation) => {
    return filterDuplicate(markDuplicate(navigation));
};
const parseNavigation = (...args) => {
    // @ts-expect-error
    const res = doParseNavigation(...args);
    return uniq(res).filter((x) => x.link || (x.items && x.items.length));
};
module.exports = parseNavigation;
