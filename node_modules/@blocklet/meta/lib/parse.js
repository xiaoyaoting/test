"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const camelCase_1 = __importDefault(require("lodash/camelCase"));
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const debug_1 = __importDefault(require("debug"));
const constants_1 = __importDefault(require("./constants"));
const schema_1 = require("./schema");
const fix_1 = require("./fix");
const debug = (0, debug_1.default)('@blocklet/meta:parse');
const { BLOCKLET_META_FILE, BLOCKLET_META_FILE_ALT } = constants_1.default;
/**
 * Get blocklet meta from blocklet.yml
 * @param {string} dir blocklet directory
 * @param {object} options.extraRawAttrs extra attributes, will be used as base attributes
 * @param {boolean} options.ensureMain should we verify that main exists
 * @param {boolean} options.ensureDist should we verify that dist exists
 * @param {boolean} options.ensureFiles should we verify that logo and files exists
 */
const parse = (dir, { ensureMain = false, ensureFiles = false, ensureDist = false, ensureComponentStore = true, extraRawAttrs = {}, schemaOptions = {}, defaultStoreUrl, fix = true, } = {}) => {
    var _a;
    let result;
    const blockletMetaFile = path_1.default.join(dir, BLOCKLET_META_FILE);
    const blockletMetaFileAlt = path_1.default.join(dir, BLOCKLET_META_FILE_ALT);
    if (fs_1.default.existsSync(blockletMetaFile)) {
        try {
            result = js_yaml_1.default.load(fs_1.default.readFileSync(blockletMetaFile).toString(), { json: true });
            debug(`parse ${blockletMetaFile}`, result);
        }
        catch (err) {
            console.error(`parse_blocklet_meta from ${BLOCKLET_META_FILE} failed`, err);
        }
    }
    else if (fs_1.default.existsSync(blockletMetaFileAlt)) {
        try {
            result = Object.assign({}, js_yaml_1.default.load(fs_1.default.readFileSync(blockletMetaFileAlt).toString(), { json: true }));
            debug(`parse ${blockletMetaFileAlt}`, result);
        }
        catch (err) {
            console.error(`parse_blocklet_meta from ${BLOCKLET_META_FILE_ALT} failed`, err);
        }
    }
    else {
        throw new Error(`no ${BLOCKLET_META_FILE} or ${BLOCKLET_META_FILE_ALT} found`);
    }
    // User Can override with extra meta attrs: useful for registry
    if (extraRawAttrs) {
        result = Object.assign(result, extraRawAttrs);
    }
    if (!fix) {
        // @ts-ignore
        return result;
    }
    // Fix
    (0, fix_1.fixRequired)(result, dir);
    (0, fix_1.fixRepository)(result);
    (0, fix_1.fixFiles)(result);
    (0, fix_1.fixKeywords)(result);
    (0, fix_1.fixTags)(result);
    (0, fix_1.fixPerson)(result);
    (0, fix_1.fixService)(result);
    if (defaultStoreUrl && ((_a = result.components) === null || _a === void 0 ? void 0 : _a.length)) {
        result.components.forEach((x) => {
            if ('name' in x.source) {
                if (!x.source.store) {
                    x.source.store = typeof defaultStoreUrl === 'function' ? defaultStoreUrl((0, cloneDeep_1.default)(x)) : defaultStoreUrl;
                }
            }
        });
    }
    // We will overwrite did anyway
    result.path = `/${result.group}/${result.name}`;
    // Ensure camelCase
    result = Object.keys(result).reduce((acc, k) => {
        acc[(0, camelCase_1.default)(k)] = result[k];
        return acc;
    }, {});
    debug('fix', result);
    // Validate and cleanup
    const schema = (0, schema_1.createBlockletSchema)(dir, Object.assign({ ensureMain,
        ensureFiles,
        ensureDist,
        ensureComponentStore }, schemaOptions));
    const { value, error } = schema.validate(result);
    if (error) {
        throw new Error(`Invalid blocklet.yml: ${error.details
            .map((x) => {
            try {
                // 根据 navigation 校验规则定制特殊的错误消息显示
                if (x.type === 'array.unique' && x.path[0] === 'navigation') {
                    return `${x.message}: ${x.context.value.id}`;
                }
            }
            catch (_a) {
                //
            }
            return x.message;
        })
            .join(', ')}`);
    }
    return value;
};
module.exports = parse;
