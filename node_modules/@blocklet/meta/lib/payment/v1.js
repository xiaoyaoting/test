"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNftFactoryItx = exports.createShareContract = void 0;
const url_join_1 = __importDefault(require("url-join"));
const util_1 = require("@ocap/util");
const asset_1 = require("@ocap/asset");
const did_util_1 = require("@arcblock/did-util");
const nft_templates_1 = require("../nft-templates");
const createShareContract = ({ tokens = [], shares = [], }) => {
    const zeroBN = new util_1.BN(0);
    const decimals = 1000000; // we only support 6 decimals on share ratio
    const decimalsBN = new util_1.BN(decimals);
    const contract = [];
    const shareSum = shares.reduce((sum, x) => sum + x.value, 0);
    if (shareSum > 1) {
        throw new Error('payment.share invalid: share sum should not be greater than 1');
    }
    if (Array.isArray(tokens)) {
        tokens.forEach(({ address: tokenAddress, value: valueItem }) => {
            const valueBN = new util_1.BN(valueItem);
            if (valueBN.lt(zeroBN)) {
                throw new Error('token price must be greater than or equal to zero');
            }
            shares.forEach(({ address, value }) => {
                const ratio = new util_1.BN(value * decimals);
                const amount = valueBN.mul(ratio).div(decimalsBN);
                contract.push(`transferToken('${tokenAddress}','${address}','${amount.toString()}')`);
            });
        });
    }
    return contract.join(';\n');
};
exports.createShareContract = createShareContract;
// we need to ensure that blocklet purchase factory does not change across changes
const createNftFactoryItx = ({ meta, tokens, shares, issuers, serviceUrl, }) => {
    const factoryOutput = (0, nft_templates_1.getBlockletPurchaseTemplate)(serviceUrl);
    const itx = {
        name: meta.title || meta.name,
        description: `Purchase NFT factory for blocklet ${meta.name}`,
        settlement: 'instant',
        limit: 0,
        trustedIssuers: issuers,
        input: {
            tokens: [...tokens],
            assets: [],
            variables: [],
        },
        output: {
            issuer: '{{ctx.issuer.id}}',
            parent: '{{ctx.factory}}',
            moniker: 'BlockletPurchaseNFT',
            readonly: true,
            transferrable: false,
            data: factoryOutput,
        },
        data: {
            type: 'json',
            value: {
                did: meta.did,
                url: (0, url_join_1.default)(serviceUrl, `/blocklet/${meta.did}`),
                name: meta.name,
            },
        },
        hooks: [
            {
                name: 'mint',
                type: 'contract',
                hook: createShareContract({ tokens, shares }),
            },
        ],
    };
    // @ts-ignore
    itx.address = (0, did_util_1.toFactoryAddress)(itx);
    (0, asset_1.isValidFactory)(itx);
    return itx;
};
exports.createNftFactoryItx = createNftFactoryItx;
exports.default = {
    createShareContract,
    createNftFactoryItx,
};
