import { TBlockletMeta } from '../types';
declare const VERSION = "2.0.0";
export interface Store {
    id: string;
    pk: string;
    url: string;
    components: Array<{
        did: string;
        version: string;
    }>;
}
export interface Component {
    meta: TBlockletMeta;
    storeInfo: {
        id: string;
        pk: string;
    };
    storeUrl: string;
    children: Component[];
}
/**
 * Used by CLI and Store to independent compute factory itx
 *
 * @param {{
 *   blockletMeta: TBlockletMeta,
 *   ocapClient: OcapClient,
 *   issuers: Array<string>,
 *   storeUrl: string,
 * }}
 * @returns {{
 *   itx: Itx
 *   store: Array<{id, url}>
 *   shares: Array<{
 *     accountName: string
 *     accountAddress: DID
 *     tokenAddress: DID
 *     amount: string|number,
 *   }>
 * }}
 */
declare const createNftFactoryItx: ({ blockletMeta, ocapClient, issuers, storeUrl, }: {
    blockletMeta: TBlockletMeta;
    ocapClient: any;
    issuers: string[];
    storeUrl: string;
}) => Promise<{
    itx: any;
    stores: {
        id: string;
        url: string;
    }[];
    shares: {
        amount: string;
        tokenAddress: string;
        accountAddress: string;
    }[];
}>;
/**
 * Used by Store before generating payment signature
 *
 * @param {{
 *   integrity: string,
 *   blockletMeta: TBlockletMeta,
 *   ocapClient: OcapClient,
 *   storeId: string
 * }}
 * @returns {string} integrity
 */
declare const verifyPaymentIntegrity: ({ integrity: expected, blockletMeta, ocapClient, storeId, }: {
    integrity: string;
    blockletMeta: TBlockletMeta;
    ocapClient: any;
    storeId: string;
}) => Promise<string>;
/**
 * Used by Store before generating downloadToken
 *
 * @param {{
 *   {FactoryState} factoryState
 *   {Wallet} signerWallet
 * }}
 *
 * @returns {{
 *   components: Array<{did: string, version: string}>
 * }}
 */
declare const verifyNftFactory: ({ factoryState, signerWallet, }: {
    factoryState: {
        data: {
            value: string;
        };
        input?: any;
        address?: string;
        hooks?: Array<{
            type: string;
            hook: string;
        }>;
    };
    signerWallet: any;
}) => Promise<any>;
/**
 * Check blocklet and all of components are free
 * Throw Error if not free
 *
 * @param {TBlockletMeta} meta
 */
declare const checkFreeBlocklet: (blockletMeta: TBlockletMeta) => Promise<boolean>;
export declare const _test: {
    getPriceTokens: (meta: any, ocapClient: any) => Promise<any>;
    getFactoryInput: (inputTokens: Array<{
        address: string;
        value: string | number;
        decimal: number;
    }>, { formatToken }?: {
        formatToken?: boolean;
    }) => {
        tokens: Array<{
            address: string;
            value: string | number;
            decimal: number;
        }>;
        assets: [];
        variables: [];
    };
    getPaymentIntegrity: ({ contract, factoryInput, storeComponents, meta, client, storeId, }: {
        contract?: string;
        factoryInput?: any;
        storeComponents?: any;
        meta?: any;
        client?: any;
        storeId?: string;
    }) => Promise<string>;
    getComponents: (inputMeta: any) => Promise<{
        components: Component[];
        stores: Store[];
    }>;
    getContract: ({ meta, priceTokens, components, }: {
        meta: TBlockletMeta;
        priceTokens: Array<{
            decimal: number;
        }>;
        components: any;
    }) => Promise<{
        code: string;
        shares: {
            amount: string;
            tokenAddress: string;
            accountAddress: string;
        }[];
    }>;
};
export { createNftFactoryItx };
export { verifyPaymentIntegrity };
export { verifyNftFactory };
export { checkFreeBlocklet };
export { VERSION as version };
declare const _default: {
    createNftFactoryItx: ({ blockletMeta, ocapClient, issuers, storeUrl, }: {
        blockletMeta: TBlockletMeta;
        ocapClient: any;
        issuers: string[];
        storeUrl: string;
    }) => Promise<{
        itx: any;
        stores: {
            id: string;
            url: string;
        }[];
        shares: {
            amount: string;
            tokenAddress: string;
            accountAddress: string;
        }[];
    }>;
    verifyPaymentIntegrity: ({ integrity: expected, blockletMeta, ocapClient, storeId, }: {
        integrity: string;
        blockletMeta: TBlockletMeta;
        ocapClient: any;
        storeId: string;
    }) => Promise<string>;
    verifyNftFactory: ({ factoryState, signerWallet, }: {
        factoryState: {
            data: {
                value: string;
            };
            input?: any;
            address?: string;
            hooks?: {
                type: string;
                hook: string;
            }[];
        };
        signerWallet: any;
    }) => Promise<any>;
    checkFreeBlocklet: (blockletMeta: TBlockletMeta) => Promise<boolean>;
    version: string;
    _test: {
        getPriceTokens: (meta: any, ocapClient: any) => Promise<any>;
        getFactoryInput: (inputTokens: {
            address: string;
            value: string | number;
            decimal: number;
        }[], { formatToken }?: {
            formatToken?: boolean;
        }) => {
            tokens: {
                address: string;
                value: string | number;
                decimal: number;
            }[];
            assets: [];
            variables: [];
        };
        getPaymentIntegrity: ({ contract, factoryInput, storeComponents, meta, client, storeId, }: {
            contract?: string;
            factoryInput?: any;
            storeComponents?: any;
            meta?: any;
            client?: any;
            storeId?: string;
        }) => Promise<string>;
        getComponents: (inputMeta: any) => Promise<{
            components: Component[];
            stores: Store[];
        }>;
        getContract: ({ meta, priceTokens, components, }: {
            meta: TBlockletMeta;
            priceTokens: {
                decimal: number;
            }[];
            components: any;
        }) => Promise<{
            code: string;
            shares: {
                amount: string;
                tokenAddress: string;
                accountAddress: string;
            }[];
        }>;
    };
};
export default _default;
