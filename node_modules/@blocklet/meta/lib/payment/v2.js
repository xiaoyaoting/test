"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.version = exports.checkFreeBlocklet = exports.verifyNftFactory = exports.verifyPaymentIntegrity = exports.createNftFactoryItx = exports._test = void 0;
/* eslint-disable no-await-in-loop */
const crypto_1 = __importDefault(require("crypto"));
const debug_1 = __importDefault(require("debug"));
const url_join_1 = __importDefault(require("url-join"));
const json_stable_stringify_1 = __importDefault(require("json-stable-stringify"));
const get_1 = __importDefault(require("lodash/get"));
const pick_1 = __importDefault(require("lodash/pick"));
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const axios_1 = __importDefault(require("@abtnode/util/lib/axios"));
const util_1 = require("@ocap/util");
const asset_1 = require("@ocap/asset");
const wallet_1 = require("@ocap/wallet");
const did_util_1 = require("@arcblock/did-util");
const did = __importStar(require("@arcblock/did"));
const constant_1 = __importDefault(require("@abtnode/constant"));
const nft_templates_1 = require("../nft-templates");
const validate_1 = require("../validate");
const util_2 = require("../util");
const util_meta_1 = require("../util-meta");
const debug = (0, debug_1.default)('@blocklet/meta:payment');
const { toTypeInfo } = did;
const { BLOCKLET_STORE_META_PATH } = constant_1.default;
const VERSION = '2.0.0';
exports.version = VERSION;
const ZeroBN = new util_1.BN(0);
const defaultDecimals = 1e6; // we only support 6 decimals on share ratio
const defaultDecimalsBN = new util_1.BN(defaultDecimals);
const getComponentConfig = (meta) => meta.components || meta.children;
const safeMul = (a, b) => Number((0, util_1.fromUnitToToken)((0, util_1.fromTokenToUnit)(a)
    .mul(new util_1.BN(b * defaultDecimals))
    .div(defaultDecimalsBN)));
const md5 = (str) => crypto_1.default.createHash('md5').update(str).digest('hex');
const getStoreInfo = (url) => __awaiter(void 0, void 0, void 0, function* () {
    const storeMetaUrl = (0, url_join_1.default)(new URL(url).origin, BLOCKLET_STORE_META_PATH);
    const { data: info } = yield axios_1.default.get(storeMetaUrl, { timeout: 8000 });
    return info;
});
/**
 * @typedef {{
 *   meta: Object
 *   storeInfo: Object
 *   storeUrl: string
 *   children: Array<Component>
 * }} Component
 *
 * @param {TBlockletMeta} inputMeta
 * @param {{
 *   ancestors: Array<{TBlockletMeta}>
 *   bundles: {
 *     <bundleName>: <storeId>
 *   }
 * }} context
 *
 * @returns {Array<Component>}
 */
const innerGetComponents = (inputMeta, context = {}) => __awaiter(void 0, void 0, void 0, function* () {
    // FIXME 是否需要验证: 在同一个链上; 重复的 component
    const { ancestors = [], bundles = {} } = context;
    // check ancestor length
    if (ancestors.length > 40) {
        throw new Error('The depth of component should not exceed 40');
    }
    const configs = getComponentConfig(inputMeta);
    if (!configs || !configs.length) {
        return [];
    }
    const children = [];
    for (const config of configs) {
        // get component meta
        const urls = (0, util_meta_1.getSourceUrlsFromConfig)(config);
        let meta;
        let url;
        try {
            const res = yield (0, util_meta_1.getBlockletMetaFromUrls)(urls, {
                returnUrl: true,
                validateFn: (m) => (0, validate_1.validateMeta)(m),
                ensureTarball: false,
            });
            meta = res.meta;
            url = res.url;
        }
        catch (err) {
            throw new Error(`Failed get component meta: ${config.title || config.name}: ${err.message}`);
        }
        // check is component
        if (!(0, util_2.isComponentBlocklet)(meta)) {
            throw new Error(`The blocklet cannot be a component: ${meta.title}`);
        }
        // check circular dependencies
        if (ancestors.map((x) => { var _a; return (_a = x.meta) === null || _a === void 0 ? void 0 : _a.did; }).indexOf(meta.did) > -1) {
            throw new Error('Blocklet components have circular dependencies');
        }
        // generate child
        const child = {
            meta,
        };
        // child store info
        if (config.source.store) {
            const storeInfo = yield getStoreInfo(url);
            // check uniq bundle did in different stores
            if (!bundles[child.meta.did]) {
                bundles[child.meta.did] = storeInfo.id;
            }
            else if (bundles[child.meta.did] !== storeInfo.id) {
                throw new Error('Bundles with the same did cannot in different stores');
            }
            child.storeInfo = storeInfo;
            child.storeUrl = new URL(url).origin;
        }
        // child children
        child.children = yield innerGetComponents(meta, {
            ancestors: [...ancestors, { meta }],
            bundles,
        });
        children.push(child);
    }
    return children;
});
/**
 * @param {Array<Component>} components
 * @param {Array<Store>} _stores
 * @returns {Array<Store>}
 */
const getStores = (components, _stores = []) => {
    for (const { meta, storeInfo, storeUrl, children } of components) {
        if (storeInfo && (!(0, util_2.isFreeBlocklet)(meta) || !(0, util_2.isFreeComponent)(meta))) {
            const store = _stores.find((x) => x.id === storeInfo.id);
            if (!store) {
                _stores.push({
                    id: storeInfo.id,
                    pk: storeInfo.pk,
                    url: storeUrl,
                    components: [{ did: meta.did, version: meta.version }],
                });
            }
            else if (!store.components.some((x) => x.did === meta.did && x.version === meta.version)) {
                store.components.push({ did: meta.did, version: meta.version });
            }
        }
        if (children && children.length > 0) {
            getStores(children, _stores);
        }
    }
    return _stores;
};
const getComponents = (inputMeta) => __awaiter(void 0, void 0, void 0, function* () {
    const components = yield innerGetComponents(inputMeta);
    const stores = yield getStores(components);
    return { components, stores };
});
const getPriceTokens = (meta, ocapClient) => __awaiter(void 0, void 0, void 0, function* () {
    const priceTokens = (0, cloneDeep_1.default)((0, get_1.default)(meta, 'payment.price', []));
    for (const token of priceTokens) {
        // eslint-disable-next-line no-await-in-loop
        const { state } = yield ocapClient.getTokenState({ address: token.address });
        if (!state) {
            throw new Error(`Token specified in blocklet meta was not found on chain: ${token.address}`);
        }
        token.decimal = state.decimal;
    }
    return priceTokens;
});
const getChildShare = (childMeta, parentPrice) => {
    var _a;
    if (!((_a = childMeta === null || childMeta === void 0 ? void 0 : childMeta.payment) === null || _a === void 0 ? void 0 : _a.componentPrice)) {
        return 0;
    }
    const priceList = childMeta.payment.componentPrice;
    let price = 0;
    for (const { type, value, parentPriceRange } of priceList) {
        const isDefault = !parentPriceRange || !parentPriceRange.length;
        const skip = isDefault && price !== 0;
        const inRange = isDefault || (parentPriceRange && parentPrice >= parentPriceRange[0] && parentPrice <= parentPriceRange[1]);
        if (!skip && inRange) {
            if (type === 'fixed') {
                price = value;
            }
            else if (type === 'percentage') {
                price = safeMul(parentPrice, value);
            }
        }
    }
    return price;
};
/**
 * @returns {Array<{
 *   tokenAddress: string
 *   accountAddress: string
 *   amount: BN
 * }>}
 */
const getTokenTransfers = ({ priceToken, shares = [], components = [], }) => {
    // check share
    const shareSum = shares.reduce((sum, x) => sum + x.value, 0);
    if (shareSum > 1) {
        throw new Error('payment.share invalid: share sum should not be greater than 1');
    }
    const { value: price } = priceToken;
    let parentShareBN = (0, util_1.fromTokenToUnit)(price, priceToken.decimal);
    const contracts = [];
    for (const child of components) {
        if (!(0, util_2.isFreeComponent)(child.meta)) {
            // // check same token
            const [token] = child.meta.payment.price || [];
            if (token && token.address !== priceToken.address) {
                throw new Error(`The token address of the component "${child.meta.title || child.meta.name}" is inconsistent with the blocklet. Component: ${priceToken.address}, Composite Blocklet: ${token.address}`);
            }
            const childShare = getChildShare(child.meta, price);
            parentShareBN = parentShareBN.sub((0, util_1.fromTokenToUnit)(childShare, priceToken.decimal));
            const componentContracts = getTokenTransfers({
                priceToken: Object.assign(Object.assign({}, priceToken), { value: childShare }),
                shares: child.meta.payment.share,
                components: child.children || [],
            });
            contracts.push(...componentContracts);
        }
    }
    if (parentShareBN.lt(ZeroBN)) {
        const needPrice = (0, util_1.fromUnitToToken)((0, util_1.fromTokenToUnit)(price, priceToken.decimal).sub(parentShareBN));
        throw new Error(`Price for composite blocklet must be greater than ${needPrice} because paid components are included.`);
    }
    shares.forEach(({ name, address: accountAddress, value: ratio }) => {
        contracts.push({
            tokenAddress: priceToken.address,
            accountName: name,
            accountAddress,
            amount: parentShareBN.mul(new util_1.BN(ratio * defaultDecimals)).div(defaultDecimalsBN),
        });
    });
    const mergedContracts = [];
    contracts.forEach((x) => {
        const index = mergedContracts.findIndex((y) => y.tokenAddress === x.tokenAddress && y.accountAddress === x.accountAddress);
        if (index > -1) {
            mergedContracts[index].amount = mergedContracts[index].amount.add(x.amount);
        }
        else {
            mergedContracts.push(x);
        }
    });
    return mergedContracts;
};
const getContract = ({ meta, priceTokens, components, }) => __awaiter(void 0, void 0, void 0, function* () {
    const shares = meta.payment.share || [];
    const [priceToken] = priceTokens;
    const contracts = getTokenTransfers({ priceToken, shares, components });
    const code = contracts
        .map((x) => `transferToken('${x.tokenAddress}','${x.accountAddress}','${x.amount.toString()}')`)
        .join(';\n');
    const shareList = contracts.map((x) => (Object.assign(Object.assign({}, x), { amount: (0, util_1.fromUnitToToken)(x.amount, priceToken.decimal) })));
    return {
        code,
        shares: shareList,
    };
});
/**
 * we need to ensure that blocklet purchase factory does not change across changes
 *
 * @typedef {{
 *   data: {
 *     type: 'json'
 *     value: {
 *       did: string
 *       url: string
 *       name: string
 *       version: string
 *       payment: {
 *         version: string
 *       }
 *       stores: Array<{
 *         signer: string
 *         pk: string
 *         signature: string
 *         components: Array<{did: string, version: string}>
 *         paymentIntegrity: string
 *       }>
 *     }
 *   }
 * }} Itx
 * @returns {Itx}
 */
const innerCreateNftFactoryItx = ({ meta, issuers, serviceUrl, storeSignatures, factoryInput, contract, }) => {
    const factoryOutput = (0, nft_templates_1.getBlockletPurchaseTemplate)(serviceUrl);
    const itx = {
        name: meta.title || meta.name,
        description: `Purchase NFT factory for blocklet ${meta.name}`,
        settlement: 'instant',
        limit: 0,
        trustedIssuers: issuers,
        input: factoryInput,
        output: {
            issuer: '{{ctx.issuer.id}}',
            parent: '{{ctx.factory}}',
            moniker: 'BlockletPurchaseNFT',
            readonly: true,
            transferrable: false,
            data: factoryOutput,
        },
        data: {
            type: 'json',
            value: {
                did: meta.did,
                url: (0, url_join_1.default)(serviceUrl, `/blocklet/${meta.did}`),
                name: meta.name,
                version: meta.version,
                payment: {
                    version: VERSION,
                },
                stores: storeSignatures.map((x) => (0, pick_1.default)(x, ['signer', 'pk', 'signature', 'components', 'paymentIntegrity'])),
            },
        },
        hooks: [
            {
                name: 'mint',
                type: 'contract',
                hook: contract,
            },
        ],
    };
    itx.address = (0, did_util_1.toFactoryAddress)(itx);
    // @ts-expect-error FIXME: help wanted
    (0, asset_1.isValidFactory)(itx, true);
    return itx;
};
const getFactoryInput = (inputTokens, { formatToken = true } = {}) => {
    const tokens = (0, cloneDeep_1.default)(inputTokens);
    tokens.forEach((token) => {
        if (formatToken) {
            token.value = (0, util_1.fromTokenToUnit)(token.value, token.decimal).toString();
        }
        delete token.decimal;
    });
    return {
        tokens,
        assets: [],
        variables: [],
    };
};
const getPaymentIntegrity = ({ contract, factoryInput, storeComponents, meta, client, storeId, }) => __awaiter(void 0, void 0, void 0, function* () {
    if (!contract && !factoryInput && !storeComponents) {
        const priceTokens = yield getPriceTokens(meta, client);
        const { components, stores } = yield getComponents(meta);
        const store = stores.find((x) => x.id === storeId);
        // eslint-disable-next-line no-param-reassign
        contract = (yield getContract({ meta, components, priceTokens })).code;
        // eslint-disable-next-line no-param-reassign
        factoryInput = yield getFactoryInput(priceTokens);
        // eslint-disable-next-line no-param-reassign
        storeComponents = (store === null || store === void 0 ? void 0 : store.components) || [];
    }
    const paymentData = {
        factoryInput,
        contract,
        components: storeComponents || [],
    };
    const integrity = md5((0, json_stable_stringify_1.default)(paymentData));
    return integrity;
});
const getStoreSignatures = ({ meta, stores, factoryInput, contract, }) => __awaiter(void 0, void 0, void 0, function* () {
    const storeSignatures = [];
    for (const store of stores) {
        const { id, url, pk, components: storeComponents } = store;
        const paymentIntegrity = yield getPaymentIntegrity({ factoryInput, contract, storeComponents });
        /**
         * protocol: /api/payment/signature
         * method: POST
         * body: { blockletMeta, paymentIntegrity, paymentVersion }
         * return: { signer, pk, signature}
         */
        const { data: res } = yield axios_1.default.post(`${url}/api/payment/signature`, {
            blockletMeta: meta,
            paymentIntegrity,
            paymentVersion: VERSION,
        }, { timeout: 20000 });
        if (res.signer !== id) {
            throw new Error('store signature: store id does not match');
        }
        if (res.pk !== pk) {
            throw new Error('store signature: store pk does not match');
        }
        // verify sig
        const type = toTypeInfo(id);
        const wallet = (0, wallet_1.fromPublicKey)(pk, type);
        const verifyRes = wallet.verify(paymentIntegrity, res.signature);
        if (verifyRes !== true) {
            throw new Error('verify store signature failed');
        }
        storeSignatures.push({
            signer: res.signer,
            pk: res.pk,
            signature: res.signature,
            components: storeComponents,
            paymentIntegrity,
            storeUrl: url,
        });
    }
    return {
        storeSignatures,
    };
});
/**
 * Used by CLI and Store to independent compute factory itx
 *
 * @param {{
 *   blockletMeta: TBlockletMeta,
 *   ocapClient: OcapClient,
 *   issuers: Array<string>,
 *   storeUrl: string,
 * }}
 * @returns {{
 *   itx: Itx
 *   store: Array<{id, url}>
 *   shares: Array<{
 *     accountName: string
 *     accountAddress: DID
 *     tokenAddress: DID
 *     amount: string|number,
 *   }>
 * }}
 */
const createNftFactoryItx = ({ blockletMeta, ocapClient, issuers, storeUrl, }) => __awaiter(void 0, void 0, void 0, function* () {
    const priceTokens = yield getPriceTokens(blockletMeta, ocapClient);
    const { components, stores } = yield getComponents(blockletMeta);
    const factoryInput = getFactoryInput(priceTokens);
    const { code: contract, shares } = yield getContract({
        meta: blockletMeta,
        priceTokens,
        components,
    });
    const { storeSignatures } = yield getStoreSignatures({
        meta: blockletMeta,
        stores,
        factoryInput,
        contract,
    });
    return {
        itx: innerCreateNftFactoryItx({
            meta: blockletMeta,
            issuers,
            serviceUrl: storeUrl,
            storeSignatures,
            factoryInput,
            contract,
        }),
        stores: storeSignatures.map((x) => ({ id: x.signer, url: x.storeUrl })),
        shares,
    };
});
exports.createNftFactoryItx = createNftFactoryItx;
/**
 * Used by Store before generating payment signature
 *
 * @param {{
 *   integrity: string,
 *   blockletMeta: TBlockletMeta,
 *   ocapClient: OcapClient,
 *   storeId: string
 * }}
 * @returns {string} integrity
 */
const verifyPaymentIntegrity = ({ integrity: expected, blockletMeta, ocapClient, storeId, }) => __awaiter(void 0, void 0, void 0, function* () {
    const actual = yield getPaymentIntegrity({ meta: blockletMeta, client: ocapClient, storeId });
    if (actual !== expected) {
        throw new Error('verify payment integrity failed');
    }
    return expected;
});
exports.verifyPaymentIntegrity = verifyPaymentIntegrity;
/**
 * Used by Store before generating downloadToken
 *
 * @param {{
 *   {FactoryState} factoryState
 *   {Wallet} signerWallet
 * }}
 *
 * @returns {{
 *   components: Array<{did: string, version: string}>
 * }}
 */
const verifyNftFactory = ({ factoryState, signerWallet, }) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const data = JSON.parse((_a = factoryState === null || factoryState === void 0 ? void 0 : factoryState.data) === null || _a === void 0 ? void 0 : _a.value);
    const stores = (data === null || data === void 0 ? void 0 : data.stores) || [];
    const store = stores.find((x) => x.signer === signerWallet.address);
    if (!store) {
        throw new Error(`Signer does not found in factory. factory: ${factoryState.address}, signer: ${signerWallet.address}`);
    }
    const c = factoryState.hooks.find((x) => x.type === 'contract');
    const { components } = store;
    // Token 的字段和 factory 中的字段不一致
    const factoryInput = getFactoryInput(factoryState.input.tokens.map((x) => (0, pick_1.default)(x, ['address', 'value'])), { formatToken: false });
    const integrity = yield getPaymentIntegrity({
        contract: c.hook,
        factoryInput,
        storeComponents: components,
    });
    if (signerWallet.sign(integrity) !== store.signature) {
        debug(store, factoryInput, integrity, components, c.hook);
        throw new Error(`verify nft factory failed: ${factoryState.address}`);
    }
    return { components };
});
exports.verifyNftFactory = verifyNftFactory;
/**
 * Check blocklet and all of components are free
 * Throw Error if not free
 *
 * @param {TBlockletMeta} meta
 */
const checkFreeBlocklet = (blockletMeta) => __awaiter(void 0, void 0, void 0, function* () {
    if (!(0, util_2.isFreeBlocklet)(blockletMeta)) {
        return Promise.reject(new Error('blocklet is not free'));
    }
    const { components } = yield getComponents(blockletMeta);
    const shouldAllComponentFree = (arr) => {
        arr.forEach(({ meta, children }) => {
            if (!(0, util_2.isFreeBlocklet)(meta) || !(0, util_2.isFreeComponent)(meta)) {
                // throw new Error(`Found paid component "${meta.title || meta.name}" in free blocklet`);
                throw new Error(`Paid component "${meta.title || meta.name}" found in free blocklet "${blockletMeta.title || blockletMeta.name}", which is forbidden`);
            }
            shouldAllComponentFree(children || []);
        });
    };
    shouldAllComponentFree(components);
    return true;
});
exports.checkFreeBlocklet = checkFreeBlocklet;
// eslint-disable-next-line @typescript-eslint/naming-convention
exports._test = {
    getPriceTokens,
    getFactoryInput,
    getPaymentIntegrity,
    getComponents,
    getContract,
};
exports.default = {
    createNftFactoryItx,
    verifyPaymentIntegrity,
    verifyNftFactory,
    checkFreeBlocklet,
    version: VERSION,
    _test: exports._test,
};
