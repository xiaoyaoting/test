"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.authConfigSchema = exports.statsSchema = exports.titleSchema = exports.themeSchema = exports.signatureSchema = exports.serviceSchema = exports.scriptsSchema = exports.personSchema = exports.navigationSchema = exports.navigationItemSchema = exports.mountPointSchema = exports.logoSchema = exports.interfaceSchema = exports.environmentNameSchema = exports.environmentSchema = exports.engineSchema = exports.endpointSchema = exports.distSchema = exports.descriptionSchema = exports.createBlockletSchema = exports.componentSchema = exports.blockletNameSchema = exports.blockletMetaSchema = void 0;
const fs_1 = __importDefault(require("fs"));
const joi_1 = __importDefault(require("joi"));
// eslint-disable-next-line import/no-named-default
const cjk_length_1 = __importDefault(require("cjk-length"));
const is_glob_1 = __importDefault(require("is-glob"));
const joi_extension_semver_1 = require("joi-extension-semver");
const is_var_name_1 = __importDefault(require("is-var-name"));
const constant_1 = require("@abtnode/constant");
const did_1 = __importDefault(require("./did"));
const extension_1 = require("./extension");
const name_1 = require("./name");
const constants_1 = __importDefault(require("./constants"));
const parse_navigation_from_blocklet_1 = require("./parse-navigation-from-blocklet");
const cjkLength = cjk_length_1.default.default;
const { BLOCKLET_GROUPS, BLOCKLET_PLATFORMS, BLOCKLET_ARCHITECTURES, BLOCKLET_INTERFACE_TYPES, BLOCKLET_INTERFACE_PROTOCOLS, BLOCKLET_ENTRY_FILE, BLOCKLET_BUNDLE_FILE, BLOCKLET_DEFAULT_PORT_NAME, BLOCKLET_DYNAMIC_PATH_PREFIX, BlockletGroup, BLOCKLET_LATEST_REQUIREMENT_SERVER, BLOCKLET_INTERFACE_TYPE_WEB, BLOCKLET_INTERFACE_TYPE_WELLKNOWN, BLOCKLET_APP_SPACE_ENDPOINTS, BLOCKLET_CONFIGURABLE_KEY, } = constants_1.default;
const WELLKNOWN_PATH_PREFIX = '/.well-known';
const MAX_TITLE_LENGTH = 24;
const MAX_NAME_LENGTH = 32;
const Joi = joi_1.default.extend(joi_extension_semver_1.semver)
    .extend(joi_extension_semver_1.semverRange)
    .extend(extension_1.fileExtension)
    .extend(extension_1.didExtension);
const checkLinkHelper = (value, helper) => {
    if ((0, parse_navigation_from_blocklet_1.checkLink)(value)) {
        return value;
    }
    // @ts-expect-error
    return helper.message(`Invalid navigation link: ${value}

A valid navigation link should be a relative url which start with '/' or a absolute url, such as:
- /en/home
- /zh/home
- https://www.arcblock.io`);
};
const checkId = (value, helper) => {
    if (!value || (0, is_var_name_1.default)(value)) {
        return value;
    }
    // @ts-expect-error
    return helper.message(`Invalid navigation id: ${value}

A valid navigation id is should follow the rules of javascript variables, such as:
- foo
- fooBar
- foo123

see detail in https://www.npmjs.com/package/is-var-name`);
};
const titleSchema = Joi.string()
    .trim()
    .min(1)
    .custom((value) => {
    if (cjkLength(value) > MAX_TITLE_LENGTH) {
        throw new Error(`title length should not exceed ${MAX_TITLE_LENGTH} (see: https://www.npmjs.com/package/cjk-length)`);
    }
    return value;
})
    .meta({ className: 'TTitle' });
exports.titleSchema = titleSchema;
const descriptionSchema = Joi.string().trim().min(3).max(160).meta({ className: 'TDescription' });
exports.descriptionSchema = descriptionSchema;
const logoSchema = Joi.string()
    .uri({ scheme: ['http', 'https'], allowRelative: true })
    .allow('')
    .custom((value, helper) => {
    if (value.includes(constant_1.WELLKNOWN_BLOCKLET_LOGO_PATH)) {
        // @ts-expect-error
        return helper.message(`logo url should not include ${constant_1.WELLKNOWN_BLOCKLET_LOGO_PATH}`);
    }
    return value;
})
    .meta({ className: 'TLogo' });
exports.logoSchema = logoSchema;
const mountPointSchema = Joi.string().trim().min(1).meta({ className: 'TMountPoint' });
exports.mountPointSchema = mountPointSchema;
const blockletNameSchema = Joi.string()
    .custom((value) => {
    (0, name_1.validateName)(value);
    return value;
})
    .max(MAX_NAME_LENGTH)
    .meta({ className: 'TBlockletName' });
exports.blockletNameSchema = blockletNameSchema;
const ENV_NAME_WHITE_LIST = [BLOCKLET_CONFIGURABLE_KEY.BLOCKLET_WALLET_TYPE];
const environmentNameSchema = Joi.string()
    .trim()
    .min(1)
    .max(50)
    .required()
    .custom((name, helper) => {
    if (name.startsWith('BLOCKLET')) {
        if (!ENV_NAME_WHITE_LIST.includes(name)) {
            // @ts-expect-error
            return helper.message('Env name can not start with BLOCKLET_');
        }
    }
    if (name.startsWith('COMPONENT')) {
        // @ts-expect-error
        return helper.message('Env name can not start with COMPONENT_');
    }
    if (name.startsWith('ABTNODE')) {
        // @ts-expect-error
        return helper.message('Env name can not start with ABTNODE_');
    }
    if (/[^\w]/.test(name)) {
        // @ts-expect-error
        return helper.message('Env name can include only numbers or letters or "_"');
    }
    return name;
})
    .meta({
    className: 'TEnvironmentName',
    unknownType: 'any',
});
exports.environmentNameSchema = environmentNameSchema;
const environmentSchema = Joi.object({
    name: environmentNameSchema.required(),
    description: Joi.string().trim().required(),
    default: Joi.string().optional().allow('').default(''),
    required: Joi.boolean().default(false),
    secure: Joi.boolean().default(false),
    validation: Joi.string().optional(),
    shared: Joi.boolean().default((parent) => !parent.secure),
})
    .custom((x, helper) => {
    if (x.secure && x.default) {
        // @ts-expect-error
        return helper.message(`Cannot declare default value for secure env ${x.name}`);
    }
    return x;
})
    .meta({
    className: 'TEnvironment',
    unknownType: 'any',
});
exports.environmentSchema = environmentSchema;
const scriptsSchema = Joi.object({
    dev: Joi.string().trim().min(1),
    e2eDev: Joi.string().trim().min(1),
    preInstall: Joi.string().trim().min(1),
    postInstall: Joi.string().trim().min(1),
    preStart: Joi.string().trim().min(1),
    postStart: Joi.string().trim().min(1),
    preStop: Joi.string().trim().min(1),
    preUninstall: Joi.string().trim().min(1),
    preConfig: Joi.string().trim().min(1),
})
    .rename('pre-install', 'preInstall')
    .rename('post-install', 'postInstall')
    .rename('pre-start', 'preStart')
    .rename('post-start', 'postStart')
    .rename('pre-stop', 'preStop')
    .rename('pre-uninstall', 'preUninstall')
    .rename('pre-config', 'preConfig')
    .optional()
    .meta({
    className: 'TScripts',
    unknownType: 'any',
});
exports.scriptsSchema = scriptsSchema;
// Different services have different config schema
// - Auth: https://github.com/ArcBlock/abtnode-docs/blob/master/src/developer/auth-service/index.md
const serviceSchema = Joi.object({
    name: Joi.string().required().trim(),
    config: Joi.object().optional().default({}),
})
    .unknown(true)
    .meta({
    className: 'TService',
    unknownType: 'any',
});
exports.serviceSchema = serviceSchema;
const endpointSchema = Joi.object({
    type: Joi.string().trim(true).min(1).required(),
    path: Joi.string().required(),
    meta: Joi.object({
        vcType: Joi.string(),
        payable: Joi.boolean(),
        params: Joi.array().items({
            name: Joi.string().required().trim(),
            description: Joi.string().required().trim(),
        }),
    }),
}).meta({
    className: 'TEndpoint',
    unknownType: 'any',
});
exports.endpointSchema = endpointSchema;
const interfaceSchema = Joi.object({
    type: Joi.string()
        .lowercase()
        .valid(...BLOCKLET_INTERFACE_TYPES)
        .required(),
    // Human readable name of the interface, such as `public_url`
    name: Joi.string().trim().required(),
    // The path where the interface is served from the blocklet
    path: Joi.string().trim().default('/'),
    // `*` means the interface can be mounted at any path prefix
    prefix: Joi.string().trim().min(1).default(BLOCKLET_DYNAMIC_PATH_PREFIX),
    protocol: Joi.string()
        .lowercase()
        .valid(...BLOCKLET_INTERFACE_PROTOCOLS)
        .default('http'),
    // Can be a string or an object
    port: Joi.alternatives()
        .try(Joi.string().uppercase().default(BLOCKLET_DEFAULT_PORT_NAME), Joi.object({
        internal: Joi.string().uppercase().required(),
        external: Joi.number().port().required(),
    }))
        .default(BLOCKLET_DEFAULT_PORT_NAME),
    services: Joi.array().items(serviceSchema).unique('name'),
    endpoints: Joi.array().items(endpointSchema).unique('type'),
}).meta({
    className: 'TInterface',
    unknownType: 'any',
});
exports.interfaceSchema = interfaceSchema;
const engineSchema = Joi.object({
    platform: Joi.string()
        .valid(...BLOCKLET_PLATFORMS)
        .optional(),
    interpreter: Joi.string().valid('binary', 'node').default('node'),
    script: Joi.string().required(),
    args: Joi.array().items(Joi.string()).optional().default([]),
}).meta({
    className: 'TEngine',
    unknownType: 'any',
});
exports.engineSchema = engineSchema;
const personSchema = Joi.object({
    name: Joi.string().min(1).required(),
    email: Joi.string().email().optional(),
    url: Joi.string().uri().optional(),
}).meta({
    className: 'TPerson',
    unknownType: 'any',
});
exports.personSchema = personSchema;
const distSchema = Joi.object({
    tarball: Joi.alternatives().try(Joi.string().uri(), Joi.string()).required(),
    integrity: Joi.string().required(),
    size: Joi.number().optional(),
}).meta({
    className: 'TDist',
    unknownType: 'any',
});
exports.distSchema = distSchema;
const statsSchema = Joi.object({
    downloads: Joi.number().integer().greater(-1),
    star: Joi.number().default(0),
    purchases: Joi.number().default(0),
}).meta({
    className: 'TStats',
    unknownType: 'any',
});
exports.statsSchema = statsSchema;
const urlListSchema = Joi.alternatives().try(Joi.string().uri(), Joi.array().items(Joi.string().uri()).min(1));
const componentSchemaProps = {
    name: blockletNameSchema.required(),
    title: titleSchema,
    description: descriptionSchema,
    mountPoint: mountPointSchema,
    services: Joi.array().items(serviceSchema).unique('name'),
    source: Joi.alternatives().try(Joi.object({
        url: urlListSchema.required(),
    }), Joi.object({
        store: urlListSchema,
        name: blockletNameSchema.required(),
        // TODO 目前只能支持锁死的版本号，接下载需要支持自适应的版本号，比如 4.x
        version: Joi.alternatives().try(Joi.string().valid('latest'), Joi.semver().valid()).default('latest'),
    })),
    resolved: Joi.alternatives().try(Joi.string().uri(), Joi.string()),
    mountPoints: Joi.array() // deprecated
        .items(Joi.object({
        root: Joi.object({
            interfaceName: Joi.string().trim().required(),
            prefix: Joi.string().trim().min(1).required(),
        }).required(),
        child: Joi.object({
            interfaceName: Joi.string().trim().required(),
        }).required(),
        services: Joi.array().items(serviceSchema).unique('name'),
    }))
        .optional(),
};
const createComponentSchema = (allowEmptyStore) => Joi.object(componentSchemaProps).custom((value, helper) => {
    if (!value.mountPoint && (!value.mountPoints || !value.mountPoints.length)) {
        // @ts-expect-error
        return helper.message('child mountPoint is required');
    }
    if (!value.source && !value.resolved) {
        // @ts-expect-error
        return helper.message('child source is required');
    }
    if (!allowEmptyStore && value.source && value.source.name && !value.source.store) {
        // @ts-expect-error
        return helper.message(`missing 'store' in source of component ${value.name}`);
    }
    return value;
});
const componentSchema = createComponentSchema().meta({
    className: 'TComponent',
    unknownType: 'any',
});
exports.componentSchema = componentSchema;
const componentSchemaWithoutStoreCheck = createComponentSchema(true);
const componentsSchema = (checkStore) => Joi.array()
    .items(checkStore ? componentSchema : componentSchemaWithoutStoreCheck)
    .unique('name')
    .optional()
    .default([]);
const signatureSchema = Joi.object({
    type: Joi.string().required(),
    name: Joi.string().required(),
    signer: Joi.string().required(),
    pk: Joi.string().required(),
    created: Joi.string().isoDate().required(),
    sig: Joi.string().required(),
    excludes: Joi.array().items(Joi.string()).optional(),
    appended: Joi.array().items(Joi.string()).optional(),
    // delegation token 校验所需字段
    delegatee: Joi.string(),
    delegateePk: Joi.string(),
    delegation: Joi.string(),
}).meta({
    className: 'TSignature',
    unknownType: 'any',
});
exports.signatureSchema = signatureSchema;
const localeList = ['en', 'zh', 'fr', 'ru', 'ar', 'es', 'de', 'pt', 'ja', 'hi'];
const navigationItemProps = {
    id: Joi.string().custom(checkId),
    title: Joi.alternatives()
        .try(Joi.string().min(1).max(MAX_TITLE_LENGTH), Joi.object()
        .min(1)
        .pattern(Joi.string().valid(...localeList), Joi.string().min(1).max(MAX_TITLE_LENGTH)))
        .required(),
    link: Joi.alternatives().try(Joi.string().custom(checkLinkHelper), Joi.object()
        .min(1)
        .pattern(Joi.string().valid(...localeList), Joi.string().custom(checkLinkHelper))),
    component: Joi.string().min(1),
    section: Joi.array().items(Joi.string().min(1)).single(),
    role: Joi.array().items(Joi.string().min(1)).single(),
    icon: Joi.string().min(1),
    visible: Joi.boolean(),
};
const navigationItemSchema = Joi.object(Object.assign(Object.assign({}, navigationItemProps), { items: Joi.array().items(Joi.object(Object.assign({}, navigationItemProps)).rename('child', 'component')) }))
    .rename('child', 'component')
    .meta({
    className: 'TNavigationItem',
    unknownType: 'any',
});
exports.navigationItemSchema = navigationItemSchema;
const navigationSchema = Joi.array()
    .items(navigationItemSchema)
    .unique((a, b) => {
    if (a.id && b.id) {
        return a.id === b.id;
    }
    return false;
})
    .meta({
    className: 'TNavigation',
    unknownType: 'any',
});
exports.navigationSchema = navigationSchema;
const themeSchema = Joi.object({
    background: Joi.alternatives().try(Joi.string().min(1), Joi.object({
        header: Joi.string().min(1),
        footer: Joi.string().min(1),
        default: Joi.string().min(1),
    }).min(1)),
}).meta({
    className: 'TTheme',
    unknownType: 'any',
});
exports.themeSchema = themeSchema;
const authConfigSchema = Joi.object({
    whoCanAccess: Joi.string().valid('owner', 'invited', 'all'),
    profileFields: Joi.array().items(Joi.string().valid('fullName', 'email', 'avatar', 'phone')).unique(),
    ignoreUrls: Joi.array().items(Joi.string().min(1)),
    allowSwitchProfile: Joi.boolean(),
    blockUnauthenticated: Joi.boolean(),
    blockUnauthorized: Joi.boolean(),
})
    .options({ stripUnknown: true })
    .meta({
    className: 'TAuthConfig',
    unknownType: 'any',
});
exports.authConfigSchema = authConfigSchema;
const blockletMetaProps = {
    did: Joi.DID().trim().required(),
    version: Joi.semver().valid().required(),
    name: blockletNameSchema.required(),
    description: descriptionSchema.required(),
    group: Joi.string()
        .valid(...BLOCKLET_GROUPS)
        .required(),
    main: Joi.string().trim().required(),
    title: titleSchema.optional().allow(''),
    logo: Joi.string().trim().optional(),
    specVersion: Joi.semver().valid().gte('1.0.0').optional(),
    author: personSchema.optional(),
    contributors: Joi.array().items(personSchema).optional(),
    maintainers: Joi.array().items(personSchema).optional(),
    community: Joi.string().uri().optional().allow('').default(''),
    documentation: Joi.string().uri().optional().allow('').default(''),
    homepage: Joi.string().uri().optional().allow('').default(''),
    license: Joi.string().optional().allow('').default(''),
    support: Joi.alternatives().try(Joi.string().uri(), Joi.string().email()).optional(),
    // which asset factory to mint blocklet purchase nft
    // This is usually created and maintained by `blocklet publish` command
    nftFactory: Joi.DID().optional().allow('').default(''),
    // Set the price and share of the blocklet
    payment: Joi.object({
        // Currently only supports 1 token
        price: Joi.array()
            .max(1)
            .items(Joi.object({
            value: Joi.number().greater(0).required(),
            address: Joi.DID().required(), // token address
        }))
            .default([]),
        // List of beneficiaries that share the token earns from blocklet purchase
        // If left empty, blocklet publish workflow will enforce both the developer and the registry account
        // If not, the blocklet publish workflow will enforce the registry account
        // In theory, the developer can split as many share as he wants
        // Such as, some developers coauthored the blocklet, and their income get instant settlement on blocklet purchase
        // For performance reasons, we need to set a hard limit for share count
        share: Joi.array()
            .max(4)
            .items(Joi.object({
            name: Joi.string().required(),
            address: Joi.DID().required(),
            value: Joi.number().greater(0).max(1).required(),
        }))
            .default([])
            .custom((value) => {
            // If share is not empty, the total value should be 1
            if (value.length === 0) {
                return value;
            }
            const total = value.reduce((acc, cur) => acc + cur.value, 0);
            if (total !== 1) {
                throw new Error(`Invalid blocklet payment share config: total share must be 1, got ${total}`);
            }
            return value;
        }, 'invalid blocklet share'),
        componentPrice: Joi.array()
            .items(Joi.object({
            parentPriceRange: Joi.array()
                .items(Joi.number())
                // FIXME
                // 1. 有重叠的区间时
                // 2. 区间不连续时
                // 3. 区间边界
                .custom((value, helper) => {
                if (value.length !== 2) {
                    // @ts-expect-error
                    return helper.message('length of range should be 2');
                }
                if (value[0] < 0) {
                    // @ts-expect-error
                    return helper.message('the first value should not less than 0 in range');
                }
                if (value[1] <= value[0]) {
                    // @ts-expect-error
                    return helper.message('the second value should greater than the first value in range');
                }
                return value;
            }),
            type: Joi.string().valid('fixed', 'percentage').required(),
            value: Joi.number().greater(0).required(),
        }))
            .single(),
    }).default({ price: [], share: [] }),
    keywords: Joi.alternatives()
        .try(Joi.string().trim().min(1), Joi.array().items(Joi.string().min(1)))
        .optional(),
    tags: Joi.alternatives()
        .try(Joi.string().trim().min(1), Joi.array().items(Joi.string().min(1)))
        .optional(),
    gitHash: Joi.string().optional().allow(''),
    repository: Joi.alternatives()
        .try(Joi.string().min(1), Joi.object({
        type: Joi.string().valid('git', 'https', 'svn').required(),
        url: Joi.string().uri().required(),
        directory: Joi.string(),
    }))
        .optional(),
    timeout: Joi.object({
        start: Joi.number().min(10).max(600), // start check timeout, 10 seconds ~ 10 minutes
    }).default({ start: 60 }),
    requirements: Joi.object({
        abtnode: Joi.semverRange().valid(),
        server: Joi.semverRange().valid(),
        os: Joi.alternatives().try(Joi.string().valid('*', ...BLOCKLET_PLATFORMS), Joi.array()
            .items(Joi.string().valid(...BLOCKLET_PLATFORMS))
            .min(1)),
        cpu: Joi.alternatives().try(Joi.string().valid('*', ...BLOCKLET_ARCHITECTURES), Joi.array()
            .items(Joi.string().valid(...BLOCKLET_ARCHITECTURES))
            .min(1)),
        fuels: Joi.array().items(Joi.object({
            endpoint: Joi.string().trim().required(),
            address: Joi.string().trim(),
            value: Joi.string().trim().required(),
            reason: Joi.string().trim().required(),
        })),
        nodejs: Joi.semverRange().valid(),
    }).default({ server: BLOCKLET_LATEST_REQUIREMENT_SERVER, os: '*', cpu: '*', nodejs: '*' }),
    // interfaces: https://github.com/blocklet/blocklet-specification/issues/2
    interfaces: Joi.array()
        .items(interfaceSchema)
        .unique('name')
        .min(1)
        .custom((value, helper) => {
        const webItems = value.filter((x) => x.type === BLOCKLET_INTERFACE_TYPE_WEB);
        if (webItems.length > 1) {
            // @ts-expect-error
            return helper.message(`Only one ${BLOCKLET_INTERFACE_TYPE_WEB} interface can be declared`);
        }
        const wellknownItems = value.filter((x) => x.type === BLOCKLET_INTERFACE_TYPE_WELLKNOWN);
        for (const x of wellknownItems) {
            if (!x.prefix.startsWith(WELLKNOWN_PATH_PREFIX)) {
                // @ts-expect-error
                return helper.message(`Wellknown path prefix must start with: ${WELLKNOWN_PATH_PREFIX}`);
            }
        }
        return value;
    })
        .default([]),
    // environments
    environments: Joi.array()
        .items(environmentSchema)
        .default([])
        .optional()
        .custom((data, helper) => {
        if (data && data.length) {
            const duplicates = data.filter((x, index) => data.findIndex((y) => y.name === x.name) !== index);
            if (duplicates.length) {
                // @ts-expect-error
                return helper.message(`find duplicate environment names ${duplicates.map((x) => x.name).join(', ')}`);
            }
        }
        return data;
    }),
    // scripts & hooks
    scripts: scriptsSchema,
    // capabilities
    capabilities: Joi.object({
        clusterMode: Joi.boolean().default(false),
        // added in 1.2.2
        component: Joi.boolean().default(true),
        didSpace: Joi.string()
            .valid(...Object.values(BLOCKLET_APP_SPACE_ENDPOINTS))
            .optional(),
        navigation: Joi.boolean().default(true), // Should blocklet join navigation auto-merge process
    }).default({
        clusterMode: false,
        component: true,
    }),
    // Other contents to be included in the bundle
    files: Joi.array().items(Joi.string().trim()).optional(),
    // TODO: this field should be refactored in future version
    engine: Joi.alternatives().try(engineSchema, Joi.array().items(engineSchema)).optional(),
    // NOTE: following fields are appended by registry or bundling process
    screenshots: Joi.array().items(Joi.string().min(1)).optional().default([]),
    logoUrl: Joi.string().optional().allow(''),
    dist: distSchema.optional(),
    stats: statsSchema.optional(),
    htmlAst: Joi.any().optional(),
    path: Joi.string().optional(),
    signatures: Joi.array().items(signatureSchema).optional(),
    lastPublishedAt: Joi.string().isoDate().optional(),
    // blocklet component support
    components: componentsSchema(),
    // navigation & theme
    navigation: navigationSchema,
    theme: themeSchema,
    copyright: Joi.object({
        owner: Joi.string().min(1),
        year: Joi.alternatives().try(Joi.string(), Joi.number()),
    }),
    // NOTE: following fields only exist in blocklet server and cannot be set manually
    bundleName: Joi.string(),
    bundleDid: Joi.DID().trim(),
    storeId: Joi.string(),
};
const blockletMetaSchema = Joi.object(blockletMetaProps).options({ stripUnknown: true, noDefaults: false }).meta({
    className: 'TBlockletMeta',
    unknownType: 'any',
});
exports.blockletMetaSchema = blockletMetaSchema;
const createBlockletSchema = (baseDir, _a = {}) => {
    var { ensureMain = false, ensureFiles = false, ensureDist = false, ensureComponentStore = true } = _a, schemaOptions = __rest(_a, ["ensureMain", "ensureFiles", "ensureDist", "ensureComponentStore"]);
    if (!baseDir || !fs_1.default.existsSync(baseDir)) {
        // eslint-disable-next-line no-param-reassign
        ensureFiles = false;
    }
    return Joi.object(Object.assign(Object.assign({}, blockletMetaProps), { main: Joi.when('group', {
            is: Joi.valid(BlockletGroup.gateway),
            then: Joi.forbidden(),
            otherwise: ensureMain ? Joi.file().exists({ baseDir }).required() : Joi.string().trim().required(),
        }), logo: ensureFiles ? Joi.file().trim().exists({ baseDir }).optional() : Joi.string().trim().optional(), 
        // Other contents to be included in the bundle
        files: Joi.array()
            .items(ensureFiles
            ? // eslint-disable-next-line
                Joi.file().exists({ baseDir, canSkip: (dir, name) => [BLOCKLET_ENTRY_FILE, BLOCKLET_BUNDLE_FILE].includes(name) || (0, is_glob_1.default)(name) }) // prettier-ignore
            : Joi.string().trim())
            .optional(), dist: ensureDist ? distSchema.required() : distSchema.optional(), components: componentsSchema(ensureComponentStore) }))
        .options(Object.assign({ stripUnknown: true, noDefaults: false }, schemaOptions))
        .rename('children', 'components')
        .custom((data, helper) => {
        const { did, name } = data;
        const expectDid = (0, did_1.default)(name);
        if (expectDid !== did) {
            // @ts-expect-error
            return helper.message(`the did of name "${name}" should be "${expectDid}"`);
        }
        return data;
    });
};
exports.createBlockletSchema = createBlockletSchema;
exports.default = {
    blockletNameSchema,
    componentSchema,
    endpointSchema,
    serviceSchema,
    createBlockletSchema,
    interfaceSchema,
    environmentSchema,
    environmentNameSchema,
    scriptsSchema,
    personSchema,
    distSchema,
    titleSchema,
    descriptionSchema,
    logoSchema,
    navigationSchema,
    themeSchema,
    mountPointSchema,
    authConfigSchema,
};
