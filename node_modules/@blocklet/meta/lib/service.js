"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setService = exports.findService = exports.getDefaultServiceConfig = exports.getServiceConfig = void 0;
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const constant_1 = __importDefault(require("@abtnode/constant"));
const schema_1 = require("./schema");
const { NODE_SERVICES } = constant_1.default;
const SERVICES = {};
const setService = (meta) => {
    SERVICES[meta.name] = {
        validate: meta.schema.validate.bind(meta.schema),
        defaultConfig: meta.default,
    };
};
exports.setService = setService;
setService({
    name: 'auth',
    schema: schema_1.authConfigSchema,
    default: {},
});
// backward compatible
SERVICES[NODE_SERVICES.AUTH_SERVICE] = Object.assign(Object.assign({}, SERVICES[NODE_SERVICES.AUTH]), { meta: Object.assign(Object.assign({}, SERVICES[NODE_SERVICES.AUTH].meta), { name: NODE_SERVICES.AUTH_SERVICE }) });
const getService = (serviceName) => {
    if (!serviceName) {
        throw new Error('service name should not be empty');
    }
    const service = SERVICES[serviceName];
    if (!service) {
        throw new Error(`service ${serviceName} does not exist`);
    }
    return service;
};
const getServiceConfig = (serviceName, customConfig, { validate } = {}) => {
    const service = getService(serviceName);
    const data = (0, cloneDeep_1.default)(customConfig || {});
    const { value, error } = service.validate(data);
    if (validate && error) {
        throw new Error(`Invalid blocklet service config: ${error.details.map((x) => x.message).join(', ')}`);
    }
    return value;
};
exports.getServiceConfig = getServiceConfig;
const getDefaultServiceConfig = (serviceName) => {
    const { defaultConfig } = getService(serviceName);
    return defaultConfig;
};
exports.getDefaultServiceConfig = getDefaultServiceConfig;
const findService = (services, name) => {
    const names = [name];
    // backward compatible
    if (name === NODE_SERVICES.AUTH) {
        names.push(NODE_SERVICES.AUTH_SERVICE);
    }
    return (services || []).find((x) => names.includes(x.name));
};
exports.findService = findService;
exports.default = {
    getServiceConfig,
    getDefaultServiceConfig,
    findService,
    setService,
};
