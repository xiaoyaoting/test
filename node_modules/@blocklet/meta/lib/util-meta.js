"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSourceUrlsFromConfig = exports.getBlockletMetaFromUrls = exports.getBlockletMetaFromUrl = exports.getBlockletMetaByUrl = exports.validateUrl = void 0;
const url_1 = require("url");
const fs_1 = __importDefault(require("fs"));
const axios_1 = __importDefault(require("@abtnode/util/lib/axios"));
const promise_any_1 = __importDefault(require("promise.any"));
const url_join_1 = __importDefault(require("url-join"));
const constant_1 = __importDefault(require("@abtnode/constant"));
const did_1 = __importDefault(require("./did"));
const validate_1 = require("./validate");
const { BLOCKLET_STORE_API_BLOCKLET_PREFIX } = constant_1.default;
const validateUrl = (url, expectedHttpResTypes = ['application/json', 'text/plain']) => __awaiter(void 0, void 0, void 0, function* () {
    const parsed = new URL(url);
    const { protocol } = parsed;
    // file
    if (protocol.startsWith('file')) {
        const decoded = decodeURIComponent((0, url_1.fileURLToPath)(url));
        if (!fs_1.default.existsSync(decoded)) {
            throw new Error(`File does not exist: ${decoded}`);
        }
        return true;
    }
    // http(s)
    if (protocol.startsWith('http')) {
        let res;
        try {
            res = yield (0, axios_1.default)({ url, method: 'HEAD', timeout: 1000 * 10 });
        }
        catch (err) {
            throw new Error(`Cannot get content-type from ${url}: ${err.message}`);
        }
        if (res.headers['content-type'] &&
            expectedHttpResTypes.some((x) => res.headers['content-type'].includes(x)) === false) {
            throw new Error(`Unexpected content-type from ${url}: ${res.headers['content-type']}`);
        }
        return true;
    }
    throw new Error(`Invalid url protocol: ${protocol.replace(/:$/, '')}`);
});
exports.validateUrl = validateUrl;
const validateBlockletMeta = (meta, opts = {}) => {
    (0, validate_1.fixAndValidateService)(meta);
    return (0, validate_1.validateMeta)(meta, opts);
};
const getBlockletMetaByUrl = (url) => __awaiter(void 0, void 0, void 0, function* () {
    const { protocol } = new URL(url);
    if (protocol.startsWith('file')) {
        const decoded = decodeURIComponent((0, url_1.fileURLToPath)(url));
        if (!fs_1.default.existsSync(decoded)) {
            throw new Error(`File does not exist: ${decoded}`);
        }
        const d = yield fs_1.default.promises.readFile(decoded);
        // @ts-expect-error TS(2345) FIXME: Argument of type 'Buffer' is not assignable to par... Remove this comment to see the full error message
        const meta = JSON.parse(d);
        return meta;
    }
    if (protocol.startsWith('http')) {
        const { data: meta } = yield (0, axios_1.default)({ url, method: 'GET', timeout: 1000 * 20 });
        if (Object.prototype.toString.call(meta) !== '[object Object]') {
            throw new Error('Url is not valid');
        }
        return meta;
    }
    throw new Error(`Invalid url protocol: ${protocol.replace(/:$/, '')}`);
});
exports.getBlockletMetaByUrl = getBlockletMetaByUrl;
const getBlockletMetaFromUrl = (url, { validateFn = validateBlockletMeta, returnUrl = false, ensureTarball = true, logger, } = {}) => __awaiter(void 0, void 0, void 0, function* () {
    const meta = yield getBlockletMetaByUrl(url);
    delete meta.htmlAst;
    const newMeta = validateFn(meta, { ensureDist: true });
    if (ensureTarball) {
        try {
            const { href } = new URL(newMeta.dist.tarball, url);
            const tarball = decodeURIComponent(href);
            try {
                yield validateUrl(tarball, ['application/octet-stream', 'application/x-gzip']);
            }
            catch (error) {
                if (!error.message.startsWith('Cannot get content-type')) {
                    throw error;
                }
            }
            newMeta.dist.tarball = tarball;
        }
        catch (err) {
            const msg = `Invalid blocklet meta: dist.tarball is not a valid url ${err.message}`;
            if (logger) {
                logger.error(msg);
            }
            throw new Error(msg);
        }
    }
    if (returnUrl) {
        return { meta: newMeta, url };
    }
    return newMeta;
});
exports.getBlockletMetaFromUrl = getBlockletMetaFromUrl;
const getBlockletMetaFromUrls = (urls, { validateFn, returnUrl = false, ensureTarball = true, logger, } = {}) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const res = yield (0, promise_any_1.default)(urls.map((url) => getBlockletMetaFromUrl(url, { validateFn, returnUrl, ensureTarball, logger })));
        return res;
    }
    catch (err) {
        let { message } = err;
        if (Array.isArray(err.errors)) {
            message = err.errors.map((x) => x.message).join(', ');
        }
        if (logger) {
            logger.error('failed get blocklet meta', { urls, message });
        }
        throw new Error(message);
    }
});
exports.getBlockletMetaFromUrls = getBlockletMetaFromUrls;
/**
 * @param {*} config defined in componentSchema in blocklet meta schema
 */
const getSourceUrlsFromConfig = (config) => {
    if (config.source) {
        if (config.source.url) {
            return [config.source.url].flat();
        }
        const { store, version, name } = config.source;
        return [store]
            .flat()
            .map((x) => (0, url_join_1.default)(x, BLOCKLET_STORE_API_BLOCKLET_PREFIX, (0, did_1.default)(name), !version || version === 'latest' ? '' : version, 'blocklet.json'));
    }
    if (config.resolved) {
        return [config.resolved];
    }
    throw new Error('Invalid child config');
};
exports.getSourceUrlsFromConfig = getSourceUrlsFromConfig;
exports.default = {
    validateUrl,
    getBlockletMetaByUrl,
    getBlockletMetaFromUrl,
    getBlockletMetaFromUrls,
    getSourceUrlsFromConfig,
};
