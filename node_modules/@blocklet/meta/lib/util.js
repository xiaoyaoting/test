"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRolesFromAuthConfig = exports.isPreferenceKey = exports.isExternalBlocklet = exports.getChainInfo = exports.getConnectAppUrl = exports.getParentComponentName = exports.findComponentById = exports.getComponentBundleId = exports.getComponentName = exports.getComponentId = exports.urlFriendly = exports.replaceSlotToIp = exports.getWhoCanAccess = exports.findServiceFromMeta = exports.findWebInterface = exports.fixBlockletStatus = exports.getDisplayName = exports.hasRunnableComponent = exports.wipeSensitiveData = exports.isEnvShareable = exports.getComponentMissingConfigs = exports.getAppMissingConfigs = exports.getSharedConfigObj = exports.isDeletableBlocklet = exports.forEachChildSync = exports.forEachChild = exports.forEachBlockletSync = exports.forEachBlocklet = exports.isComponentBlocklet = exports.isFreeComponent = exports.isFreeBlocklet = void 0;
/* eslint-disable no-await-in-loop */
const get_1 = __importDefault(require("lodash/get"));
const slugify_1 = __importDefault(require("slugify"));
const url_join_1 = __importDefault(require("url-join"));
const p_limit_1 = __importDefault(require("p-limit"));
const constant_1 = __importDefault(require("@abtnode/constant"));
const constants_1 = __importDefault(require("./constants"));
const { NODE_SERVICES, SLOT_FOR_IP_DNS_SITE, WHO_CAN_ACCESS, WHO_CAN_ACCESS_PREFIX_ROLES } = constant_1.default;
const { BlockletGroup, fromBlockletStatus, fromBlockletSource, BLOCKLET_INTERFACE_TYPE_WEB, BLOCKLET_CONFIGURABLE_KEY, CHAIN_INFO_CONFIG, BLOCKLET_PREFERENCE_PREFIX, } = constants_1.default;
const getComponentId = (component, ancestors = []) => `${ancestors.map((x) => (x && x.meta ? x.meta.did : '')).join('/')}${ancestors.length ? '/' : ''}${component && component.meta ? component.meta.did : ''}`;
exports.getComponentId = getComponentId;
const getComponentName = (component, ancestors = []) => `${ancestors.map((x) => (x && x.meta ? x.meta.name : '')).join('/')}${ancestors.length ? '/' : ''}${component && component.meta ? component.meta.name : ''}`;
exports.getComponentName = getComponentName;
const getComponentBundleId = (component) => `${component.meta.bundleName}@${component.meta.version}`;
exports.getComponentBundleId = getComponentBundleId;
/**
 * a => ''
 * @a/b => ''
 * a/b => a
 * @a/b/c => @a/b
 * a/@b/c => a
 * @a/b/@c/d => @a/b
 * @a/b/@c/d/e => @a/b/@c/d
 * @a/b/@c/d/@e/f => @a/b/@c/d
 */
const getParentComponentName = (name) => {
    if (!name) {
        return '';
    }
    const arr = name.split('/');
    arr.pop();
    if (!arr.length) {
        return '';
    }
    if (arr[arr.length - 1].startsWith('@')) {
        arr.pop();
    }
    if (!arr.length) {
        return '';
    }
    return arr.join('/');
};
exports.getParentComponentName = getParentComponentName;
const forEachBlocklet = (blocklet, cb, { parallel = false, concurrencyLimit = 5, sync, params: inputParams, _parent, _root, _level = 0, _tasks: inputTasks, _ancestors = [], _limit, } = {}) => {
    const root = _root || _parent || blocklet;
    // id maybe meaningless if no meta in blocklet or _ancestors
    const id = getComponentId(blocklet, _ancestors);
    const newAncestors = _ancestors.concat(blocklet);
    // sync
    if (sync) {
        const params = cb(blocklet, {
            parent: _parent,
            root,
            level: _level,
            params: inputParams,
            ancestors: _ancestors,
            id,
        });
        if (blocklet.children) {
            for (const child of blocklet.children) {
                forEachBlocklet(child, cb, {
                    sync,
                    params,
                    _parent: blocklet,
                    _root: root,
                    _level: _level + 1,
                    _ancestors: newAncestors,
                });
            }
        }
        return null;
    }
    // serial
    if (!parallel) {
        // eslint-disable-next-line no-async-promise-executor
        return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
            try {
                const params = yield cb(blocklet, {
                    parent: _parent,
                    root,
                    level: _level,
                    ancestors: _ancestors,
                    params: inputParams,
                    id,
                });
                if (blocklet.children) {
                    for (const child of blocklet.children) {
                        yield forEachBlocklet(child, cb, {
                            params,
                            _parent: blocklet,
                            _root: root,
                            _level: _level + 1,
                            _ancestors: newAncestors,
                        });
                    }
                }
                resolve(null);
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    // parallel
    const limit = _limit || (0, p_limit_1.default)(concurrencyLimit);
    const tasks = inputTasks || [];
    tasks.push(limit(() => cb(blocklet, { parent: _parent, root, level: _level, ancestors: _ancestors, id })));
    if (blocklet.children) {
        for (const child of blocklet.children) {
            forEachBlocklet(child, cb, {
                parallel,
                _parent: blocklet,
                _root: root,
                _level: _level + 1,
                _tasks: tasks,
                _ancestors: newAncestors,
                _limit: limit,
            });
        }
    }
    if (inputTasks) {
        return null;
    }
    return Promise.all(tasks);
};
exports.forEachBlocklet = forEachBlocklet;
const forEachBlockletSync = (blocklet, cb) => forEachBlocklet(blocklet, cb, { sync: true });
exports.forEachBlockletSync = forEachBlockletSync;
const forEachChild = (blocklet, cb, params) => {
    return forEachBlocklet(blocklet, (b, opt) => {
        if (opt.level === 0) {
            return {};
        }
        return cb(b, opt);
    }, params);
};
exports.forEachChild = forEachChild;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const forEachChildSync = (blocklet, cb) => forEachChild(blocklet, cb, { sync: true });
exports.forEachChildSync = forEachChildSync;
const findComponentById = (blocklet, componentId, { _ancestors = [], returnAncestors = false, } = {}) => {
    if (Array.isArray(componentId)) {
        // eslint-disable-next-line no-param-reassign
        componentId = componentId.join('/');
    }
    const id = getComponentId(blocklet, _ancestors);
    if (componentId === id) {
        if (returnAncestors) {
            return {
                component: blocklet,
                ancestors: _ancestors,
            };
        }
        return blocklet;
    }
    for (const child of blocklet.children || []) {
        const ancestors = _ancestors.concat(blocklet);
        const component = findComponentById(child, componentId, { _ancestors: ancestors, returnAncestors });
        if (component) {
            return component;
        }
    }
    return null;
};
exports.findComponentById = findComponentById;
const isEnvShareable = (env) => {
    return (!!env &&
        !!(env.key || env.name) &&
        !env.secure &&
        env.shared !== false &&
        !BLOCKLET_CONFIGURABLE_KEY[env.key || env.name]);
};
exports.isEnvShareable = isEnvShareable;
const getSharedConfigObj = (component, ancestors) => {
    const res = {};
    if (!ancestors) {
        return res;
    }
    for (let i = ancestors.length - 1; i >= 0; i--) {
        const ancestor = ancestors[i];
        if (Array.isArray(ancestor.configs)) {
            ancestor.configs.forEach(({ key, value, secure, shared }) => {
                if (res[key]) {
                    return;
                }
                if (!value || secure !== false || shared === false || BLOCKLET_CONFIGURABLE_KEY[key]) {
                    return;
                }
                const config = (component.configs || []).find((x) => x.key === key);
                if (config && config.value) {
                    return;
                }
                res[key] = value;
            });
        }
    }
    return res;
};
exports.getSharedConfigObj = getSharedConfigObj;
const isPreferenceKey = (x) => x.key.startsWith(BLOCKLET_PREFERENCE_PREFIX) === true;
exports.isPreferenceKey = isPreferenceKey;
const getAppMissingConfigs = (blocklet = {}) => {
    const missingConfigs = [];
    forEachBlockletSync(blocklet, (b, { ancestors }) => {
        const configs = b.configs || [];
        const sharedConfigObj = getSharedConfigObj(b, ancestors);
        configs.forEach((item) => {
            if (item.required && !item.value && !sharedConfigObj[item.key]) {
                missingConfigs.push({ did: b.meta.did, key: item.key, description: item.description });
            }
        });
    });
    return missingConfigs.filter((x) => !isPreferenceKey(x));
};
exports.getAppMissingConfigs = getAppMissingConfigs;
const getComponentMissingConfigs = (component = {}, ancestors = []) => {
    const missingConfigs = [];
    const configs = component.configs || [];
    const sharedConfigObj = getSharedConfigObj(component, ancestors);
    configs.forEach((item) => {
        if (item.required && !item.value && !sharedConfigObj[item.key]) {
            missingConfigs.push({ did: component.meta.did, key: item.key, description: item.description });
        }
    });
    return missingConfigs;
};
exports.getComponentMissingConfigs = getComponentMissingConfigs;
const isFreeBlocklet = (meta) => {
    if (!meta.payment) {
        return true;
    }
    const priceList = (meta.payment.price || []).map((x) => x.value || 0);
    return priceList.every((x) => x === 0);
};
exports.isFreeBlocklet = isFreeBlocklet;
const isFreeComponent = (meta) => {
    if (!meta.payment) {
        return true;
    }
    if (!meta.payment.componentPrice) {
        return true;
    }
    return !meta.payment.componentPrice.length;
};
exports.isFreeComponent = isFreeComponent;
const isComponentBlocklet = (meta) => {
    return (0, get_1.default)(meta, 'capabilities.component') !== false;
};
exports.isComponentBlocklet = isComponentBlocklet;
const wipeSensitiveData = (blocklet) => {
    if (!blocklet) {
        return blocklet;
    }
    forEachBlocklet(blocklet, (d) => {
        if (d.configs) {
            d.configs = d.configs.filter((x) => !isPreferenceKey(x));
            d.configs.forEach((x) => {
                if (x.secure) {
                    x.value = x.value ? '__encrypted__' : '';
                }
            });
        }
        (d.environments || []).forEach((x) => {
            if (['BLOCKLET_APP_SK'].includes(x.key)) {
                x.value = '__encrypted__';
            }
        });
        // @ts-ignore
        delete blocklet.configObj;
        // @ts-ignore
        delete blocklet.environmentObj;
    }, { sync: true });
    return blocklet;
};
exports.wipeSensitiveData = wipeSensitiveData;
const isDeletableBlocklet = (blocklet) => {
    if (!blocklet) {
        return false;
    }
    const config = blocklet.environments.find((x) => x.key === 'BLOCKLET_DELETABLE');
    if (!config) {
        return true;
    }
    return config.value === 'yes';
};
exports.isDeletableBlocklet = isDeletableBlocklet;
const hasRunnableComponent = (blocklet) => {
    let has = false;
    forEachBlockletSync(blocklet, (x) => {
        if (x.meta.group !== BlockletGroup.gateway) {
            has = true;
        }
    });
    return has;
};
exports.hasRunnableComponent = hasRunnableComponent;
/**
 * 获取 blocklet 的 name
 * @param {Object} blocklet 应用数据
 * @param {Boolean} onlyUseMeta 优先使用应用元数据的name
 * @returns blocklet display name
 */
const getDisplayName = (blocklet, onlyUseMeta = false) => {
    if (!blocklet) {
        return '';
    }
    const { meta } = blocklet;
    let displayName;
    if (!onlyUseMeta && blocklet.environments) {
        const target = blocklet.environments.find((e) => e.key === 'BLOCKLET_APP_NAME');
        if (target && target.value) {
            displayName = target.value;
        }
    }
    return displayName || meta.title || meta.name;
};
exports.getDisplayName = getDisplayName;
const fixBlockletStatus = (blocklet) => {
    if (!blocklet) {
        return;
    }
    forEachBlockletSync(blocklet, (b) => {
        b.status = fromBlockletStatus(b.status);
        if (b.source !== undefined) {
            b.source = fromBlockletSource(b.source);
        }
    });
    if (blocklet.settings) {
        (blocklet.settings.children || []).forEach((child) => {
            forEachBlockletSync(child, (b) => {
                b.status = fromBlockletStatus(b.status);
                if (b.source !== undefined) {
                    b.source = fromBlockletSource(b.source);
                }
            });
        });
    }
};
exports.fixBlockletStatus = fixBlockletStatus;
const findWebInterface = (blocklet) => {
    if (!blocklet) {
        return null;
    }
    // @ts-ignore
    const meta = blocklet.meta || blocklet || {};
    const { interfaces = [] } = meta;
    if (!Array.isArray(interfaces)) {
        return null;
    }
    return interfaces.find((x) => x.type === BLOCKLET_INTERFACE_TYPE_WEB);
};
exports.findWebInterface = findWebInterface;
const findServiceFromMeta = (meta, ServiceName) => {
    const names = [ServiceName];
    // backward compatible
    if (ServiceName === NODE_SERVICES.AUTH) {
        names.push(NODE_SERVICES.AUTH_SERVICE);
    }
    const webInterface = findWebInterface(meta);
    if (!webInterface) {
        return null;
    }
    return (webInterface.services || []).find((x) => names.includes(x.name));
};
exports.findServiceFromMeta = findServiceFromMeta;
const getWhoCanAccess = (blocklet) => {
    if (!blocklet) {
        return WHO_CAN_ACCESS.ALL;
    }
    if ((0, get_1.default)(blocklet, 'settings.whoCanAccess')) {
        return blocklet.settings.whoCanAccess;
    }
    // @ts-ignore
    const service = findServiceFromMeta(blocklet.meta, NODE_SERVICES.AUTH);
    if ((0, get_1.default)(service, 'config.whoCanAccess')) {
        return service.config.whoCanAccess;
    }
    return WHO_CAN_ACCESS.ALL;
};
exports.getWhoCanAccess = getWhoCanAccess;
const getConnectAppUrl = ({ request, baseUrl }) => {
    const blockletDid = request.headers['x-blocklet-did'] || '';
    const blockletRealDid = request.headers['x-blocklet-real-did'] || '';
    const pathPrefix = request.headers['x-path-prefix'] || '/';
    const groupPathPrefix = request.headers['x-group-path-prefix'] || '/';
    // Child blocklets should set appInfo.link to exactly the same path as the root blocklet
    let appUrl = baseUrl;
    if (blockletDid !== blockletRealDid && pathPrefix !== groupPathPrefix) {
        appUrl = (0, url_join_1.default)((0, url_join_1.default)(appUrl, '/').replace(pathPrefix, groupPathPrefix), '');
    }
    return appUrl;
};
exports.getConnectAppUrl = getConnectAppUrl;
const replaceSlotToIp = (url, ip) => (url || '').replace(SLOT_FOR_IP_DNS_SITE, (ip || '').replace(/\./g, '-'));
exports.replaceSlotToIp = replaceSlotToIp;
const urlFriendly = (name) => (0, slugify_1.default)(name.replace(/^[@./-]/, '').replace(/[@./_]/g, '-'));
exports.urlFriendly = urlFriendly;
// transform process.env.CHAIN_x => { x: v }
const getChainInfo = (env) => Object.entries(CHAIN_INFO_CONFIG).reduce((info, x) => {
    // @ts-expect-error TS(2488) FIXME: Type 'unknown' must have a '[Symbol.iterator]()' m... Remove this comment to see the full error message
    const [envName, [key, value]] = x;
    info[key] = (0, get_1.default)(env, envName) || value;
    return info;
}, {});
exports.getChainInfo = getChainInfo;
const isExternalBlocklet = (blocklet) => !!(blocklet === null || blocklet === void 0 ? void 0 : blocklet.controller);
exports.isExternalBlocklet = isExternalBlocklet;
const getRolesFromAuthConfig = (config) => {
    if (!config.whoCanAccess.startsWith(WHO_CAN_ACCESS_PREFIX_ROLES)) {
        return [];
    }
    return config.whoCanAccess.substring(WHO_CAN_ACCESS_PREFIX_ROLES.length).split(',');
};
exports.getRolesFromAuthConfig = getRolesFromAuthConfig;
exports.default = {
    isFreeBlocklet,
    isFreeComponent,
    isComponentBlocklet,
    forEachBlocklet,
    forEachBlockletSync,
    forEachChild,
    forEachChildSync,
    isDeletableBlocklet,
    getSharedConfigObj,
    getAppMissingConfigs,
    getComponentMissingConfigs,
    isEnvShareable,
    wipeSensitiveData,
    hasRunnableComponent,
    getDisplayName,
    fixBlockletStatus,
    findWebInterface,
    findServiceFromMeta,
    getWhoCanAccess,
    replaceSlotToIp,
    urlFriendly,
    getComponentId,
    getComponentName,
    getComponentBundleId,
    findComponentById,
    getParentComponentName,
    getConnectAppUrl,
    getChainInfo,
    isExternalBlocklet,
    isPreferenceKey,
    getRolesFromAuthConfig,
};
