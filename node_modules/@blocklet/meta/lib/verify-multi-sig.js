"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
/* eslint-disable @typescript-eslint/indent */
const get_1 = __importDefault(require("lodash/get"));
const omit_1 = __importDefault(require("lodash/omit"));
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const json_stable_stringify_1 = __importDefault(require("json-stable-stringify"));
const did_1 = require("@arcblock/did");
const wallet_1 = require("@ocap/wallet");
const jwt_1 = require("@arcblock/jwt");
const util_1 = require("@ocap/util");
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)('@blocklet/meta:verifyMultiSig');
function verifyDelegationToken(signature) {
    if (signature.delegation) {
        // @ts-ignore
        const payload = JSON.parse((0, util_1.fromBase64)(signature.delegation.split('.')[1]));
        if (payload.from !== signature.signer) {
            debug('verify payload.from failed', { payload, signature });
            return false;
        }
        if (payload.to !== signature.delegatee) {
            debug('verify payload.to failed', { payload, signature });
            return false;
        }
        if (!(0, get_1.default)(payload, 'permissions', []).includes('publish_blocklet')) {
            debug('verify payload.permissions failed', payload);
            return false;
        }
        // 验证一下delegation token
        if (!(0, jwt_1.verify)(signature.delegation, signature.pk)) {
            debug('verify delegation token failed', signature);
            return false;
        }
    }
    return true;
}
const verifyMultiSig = (blockletMeta) => {
    const { signatures: tmpSignatures } = blockletMeta, meta = __rest(blockletMeta, ["signatures"]);
    const signatures = (0, cloneDeep_1.default)(tmpSignatures);
    if (!Array.isArray(signatures)) {
        throw new Error('Invalid signatures, signatures should be an array');
    }
    if (signatures.length === 0) {
        throw new Error('Invalid signatures, found empty');
    }
    const { length } = signatures;
    let lastSignature = null;
    for (let i = 0; i < length; i++) {
        const signature = signatures.shift();
        // 验证delegation token
        if (!verifyDelegationToken(signature)) {
            return false;
        }
        const { sig, signer, pk } = signature.delegation
            ? {
                sig: signature.sig,
                signer: signature.delegatee,
                pk: signature.delegateePk,
            }
            : signature;
        delete signature.sig;
        debug('verify', { signer });
        let toBeVerifiedMeta = Object.assign({}, meta);
        if (lastSignature && lastSignature.appended) {
            debug('appended fields', { signer, appended: lastSignature.appended });
            lastSignature.appended.forEach((field) => {
                toBeVerifiedMeta = (0, omit_1.default)(toBeVerifiedMeta, field);
            });
        }
        if (signature.excludes && signature.excludes.length > 0) {
            debug('excludes fields', { signer, excludes: signature.excludes });
            signature.excludes.forEach((field) => {
                toBeVerifiedMeta = (0, omit_1.default)(toBeVerifiedMeta, field);
            });
        }
        const type = (0, did_1.toTypeInfo)(signer);
        const wallet = (0, wallet_1.fromPublicKey)(pk, type);
        const verifyRes = wallet.verify((0, json_stable_stringify_1.default)(Object.assign(Object.assign({}, toBeVerifiedMeta), { signatures: [signature, ...signatures] })), sig);
        if (verifyRes !== true) {
            debug('verify failed', { signer });
            return verifyRes;
        }
        lastSignature = signature;
    }
    return true;
};
module.exports = verifyMultiSig;
