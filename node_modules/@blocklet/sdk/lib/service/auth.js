"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
/* eslint-disable max-classes-per-file */
/* eslint-disable @typescript-eslint/indent */
const pickBy_1 = __importDefault(require("lodash/pickBy"));
const url_join_1 = __importDefault(require("url-join"));
const client_1 = __importDefault(require("@abtnode/client"));
const mcrypto_1 = require("@ocap/mcrypto");
const wallet_1 = require("@ocap/wallet");
const constant_1 = __importDefault(require("@abtnode/constant"));
const check_blocklet_env_1 = __importDefault(require("../util/check-blocklet-env"));
const version_1 = require("../version");
const { NODE_SERVICES, WELLKNOWN_SERVICE_PATH_PREFIX, USER_AVATAR_URL_PREFIX, USER_AVATAR_PATH_PREFIX } = constant_1.default;
const VERSION = version_1.version; // version of notification sdk
const isNotNullOrUndefined = (x) => ![null, undefined].includes(x);
const type = process.env.BLOCKLET_WALLET_TYPE !== 'eth'
    ? (0, wallet_1.WalletType)({ role: mcrypto_1.types.RoleType.ROLE_APPLICATION, pk: mcrypto_1.types.KeyType.ED25519, hash: mcrypto_1.types.HashType.SHA3 })
    : 'eth';
const fixAvatar = (user) => {
    const avatar = user === null || user === void 0 ? void 0 : user.avatar;
    if (avatar && avatar.startsWith(USER_AVATAR_URL_PREFIX)) {
        user.avatar = (0, url_join_1.default)(WELLKNOWN_SERVICE_PATH_PREFIX, USER_AVATAR_PATH_PREFIX, avatar.replace(USER_AVATAR_URL_PREFIX, ''));
    }
    return user;
};
class AuthClient extends client_1.default {
    constructor(httpEndpoint) {
        (0, check_blocklet_env_1.default)();
        super(httpEndpoint || `http://127.0.0.1:${process.env.ABT_NODE_PORT}/api/gql`.trim(), `BlockletSDK/${VERSION}`);
        this.setAuthAccessKey({
            accessKeyId: process.env.BLOCKLET_APP_ID,
            accessKeySecret: process.env.BLOCKLET_APP_SK,
            type,
        });
    }
    _getAuthHeaders() {
        const headers = super._getAuthHeaders();
        headers['x-access-blocklet'] = process.env.BLOCKLET_DID;
        // x-access-service is not used since 1.8.35
        headers['x-access-service'] = NODE_SERVICES.AUTH_SERVICE;
        return headers;
    }
}
// Auth 相关的功能 API 都在这里
// core/state/lib/api/team.js L42
// 所有可配置调用的函数在这里，如果需要额外增加，则需要在这里新增对应的函数
// core/gql/lib/config.js L25
class AuthService {
    constructor(httpEndpoint) {
        const client = new AuthClient(httpEndpoint);
        const apiList = [
            // user
            'getUsers',
            'getUser',
            'getOwner',
            // 'removeUser',
            // 'updateUserRole',
            'updateUserApproval',
            // invitation
            // 'getInvitations',
            // 'createMemberInvitation',
            // 'deleteInvitation',
            // rbac
            'getRoles',
            'createRole',
            'updateRole',
            'deleteRole',
            'grantPermissionForRole',
            'revokePermissionFromRole',
            'updatePermissionsForRole',
            'hasPermission',
            // user passport
            'issuePassportToUser',
            'revokeUserPassport',
            'enableUserPassport',
            // 'getPassportIssuances',
            // 'createPassportIssuance',
            // 'deletePassportIssuance',
            // permission
            'getPermissions',
            'createPermission',
            'updatePermission',
            'deletePermission',
            'getPermissionsByRole',
            // disabled in current
            // 'configTrustedPassports',
        ];
        const teamDid = process.env.BLOCKLET_DID;
        const apiFallback = (fn) => (params = {}, ...args) => fn(Object.assign({ input: Object.assign(Object.assign({}, params), { teamDid }) }, args));
        // const apiConvertDid = (fn: Function) => (did: string) => fn({ input: { user: { did }, teamDid } });
        const apiFnMap = {
            getUser: (fn) => (did) => __awaiter(this, void 0, void 0, function* () {
                const res = yield fn({ input: { user: { did }, teamDid } });
                fixAvatar(res.user);
                return res;
            }),
            getUsers: (fn) => (args) => __awaiter(this, void 0, void 0, function* () {
                const res = yield fn({ input: Object.assign({ teamDid }, args) });
                (res.users || []).forEach(fixAvatar);
                return res;
            }),
            // removeUser: apiConvertDid,
            // updateUserRole: (fn: Function) => (did: string, role: string) => fn({ input: { user: { did, role }, teamDid } }),
            updateUserApproval: (fn) => (did, approved) => fn({ input: { user: { did, approved }, teamDid } }),
            getPermissionsByRole: (fn) => (name) => fn({ input: { role: { name }, teamDid } }),
            createRole: (fn) => ({ name, title, description }) => fn({ input: Object.assign(Object.assign({}, (0, pickBy_1.default)({ name, title, description }, isNotNullOrUndefined)), { teamDid }) }),
            updateRole: (fn) => (name, { title, description }) => fn({ input: { role: (0, pickBy_1.default)({ name, title, description }, isNotNullOrUndefined), teamDid } }),
            deleteRole: (fn) => (name) => fn({ input: { name, teamDid } }),
            grantPermissionForRole: (fn) => (roleName, permissionName) => fn({ input: { teamDid, roleName, grantName: permissionName } }),
            revokePermissionFromRole: (fn) => (roleName, permissionName) => fn({ input: { teamDid, roleName, grantName: permissionName } }),
            updatePermissionsForRole: (fn) => (roleName, permissionNames) => fn({ input: { teamDid, roleName, grantNames: permissionNames } }),
            createPermission: (fn) => ({ name, description }) => fn({ input: Object.assign(Object.assign({}, (0, pickBy_1.default)({ name, description }, isNotNullOrUndefined)), { teamDid }) }),
            updatePermission: (fn) => (name, { description }) => fn({ input: { permission: (0, pickBy_1.default)({ name, description }, isNotNullOrUndefined), teamDid } }),
            deletePermission: (fn) => (name) => fn({ input: { name, teamDid } }),
            hasPermission: (fn) => (role, permission) => fn({ input: { teamDid, role, permission } }),
        };
        apiList.forEach((api) => {
            const fn = client[api];
            this[api] = apiFnMap[api] ? apiFnMap[api](fn) : apiFallback(fn);
        });
        // eslint-disable-next-line no-constructor-return
        return new Proxy(this, {
            get(target, propKey) {
                if (!apiList.includes(propKey)) {
                    return undefined;
                }
                return target[propKey];
            },
        });
    }
}
module.exports = AuthService;
