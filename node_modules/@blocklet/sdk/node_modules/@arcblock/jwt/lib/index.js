"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verify = exports.decode = exports.sign = void 0;
/* eslint-disable @typescript-eslint/ban-ts-comment */
const json_stable_stringify_1 = __importDefault(require("json-stable-stringify"));
const semver_1 = __importDefault(require("semver"));
const util_1 = require("@ocap/util");
const did_1 = require("@arcblock/did");
const mcrypto_1 = require("@ocap/mcrypto");
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)('@arcblock/jwt');
// we start hashing before signing after 1.1
const JWT_VERSION_REQUIRE_HASH_BEFORE_SIGN = '1.1.0';
// since ios requires a fixed length of input to sign, we use sha3 here before sign
const hasher = mcrypto_1.Hasher.SHA3.hash256;
/**
 *
 *
 * @param {string} signer - address string
 * @param {string} sk - hex encoded secret key
 * @param {*} [payload={}] - data to be included before signing
 * @param {boolean} [doSign=true] - do we need to sign the payload or just return the content to be signed
 * @param {string} [version='1.0.0']
 * @return {*}  {string} - hex encoded signature
 */
function sign(signer, sk, payload = {}, doSign = true, version = '1.0.0') {
    if ((0, did_1.isValid)(signer) === false) {
        throw new Error('Cannot do sign with invalid signer');
    }
    const type = (0, did_1.toTypeInfo)(signer);
    const headers = {
        [mcrypto_1.types.KeyType.SECP256K1]: {
            alg: 'ES256K',
            type: 'JWT',
        },
        [mcrypto_1.types.KeyType.ED25519]: {
            alg: 'Ed25519',
            type: 'JWT',
        },
        [mcrypto_1.types.KeyType.ETHEREUM]: {
            alg: 'Ethereum',
            type: 'JWT',
        },
    };
    // make header
    const header = headers[type.pk];
    const headerB64 = (0, util_1.toBase64)((0, json_stable_stringify_1.default)(header));
    // make body
    const now = Math.floor(Date.now() / 1000);
    const body = Object.assign({ iss: (0, did_1.toDid)(signer), iat: String(now), nbf: String(now), exp: String(now + 5 * 60), version }, (payload || {}));
    // remove empty keys
    Object.keys(body).forEach((x) => {
        if (typeof body[x] === 'undefined' || body[x] == null || body[x] === '') {
            delete body[x];
        }
    });
    const bodyB64 = (0, util_1.toBase64)((0, json_stable_stringify_1.default)(body));
    debug('sign.body', body);
    // istanbul ignore if
    if (!doSign) {
        return `${headerB64}.${bodyB64}`;
    }
    // @ts-ignore make signature
    const msgHex = (0, util_1.toHex)(`${headerB64}.${bodyB64}`);
    const msgHash = semver_1.default.gte(semver_1.default.coerce(version).version, JWT_VERSION_REQUIRE_HASH_BEFORE_SIGN)
        ? hasher(msgHex)
        : msgHex;
    const sigHex = (0, mcrypto_1.getSigner)(type.pk).sign(msgHash, sk);
    const sigB64 = (0, util_1.toBase64)(sigHex);
    return [headerB64, bodyB64, sigB64].join('.');
}
exports.sign = sign;
function decode(token, bodyOnly = true) {
    const [headerB64, bodyB64, sigB64] = token.split('.');
    const header = JSON.parse((0, util_1.fromBase64)(headerB64).toString());
    const body = JSON.parse((0, util_1.fromBase64)(bodyB64).toString());
    const sig = Buffer.from((0, util_1.fromBase64)(sigB64)).toString('hex');
    if (bodyOnly) {
        return body;
    }
    return { header, body, signature: `0x${(0, did_1.toStrictHex)(sig)}` };
}
exports.decode = decode;
/**
 * Verify a jwt token
 *
 * @param {string} token  - the jwt token
 * @param {string} signerPk - signer public key
 * @param {{
 *     tolerance: number; - number of seconds to tolerant expire
 *     enforceTimestamp: boolean; - whether should be verify timestamps?
 *     signerKey: string; - which field should be used to pick the signer
 *   }} [{
 *     tolerance,
 *     enforceTimestamp,
 *     signerKey,
 *   }={
 *       tolerance: 5,
 *       enforceTimestamp: true,
 *       signerKey: 'iss',
 *     }]
 * @return {*}  {boolean}
 */
function verify(token, signerPk, options) {
    const { tolerance, enforceTimestamp, signerKey } = Object.assign({
        tolerance: 5,
        enforceTimestamp: true,
        signerKey: 'iss',
    }, options);
    try {
        const [headerB64, bodyB64] = token.split('.');
        const { header, body, signature } = decode(token, false);
        if (!signature) {
            debug('verify.error.emptySig');
            return false;
        }
        if (!header.alg) {
            debug('verify.error.emptyAlg');
            return false;
        }
        const signerDid = body[signerKey];
        if (!signerDid) {
            debug('verify.error.emptySignerDid');
            return false;
        }
        if ((0, did_1.isFromPublicKey)(signerDid, signerPk) === false) {
            debug('verify.error.signerDidAndPkNotMatch');
            return false;
        }
        if (enforceTimestamp) {
            const now = Math.ceil(Date.now() / 1000);
            const exp = Number(body.exp) || 0;
            const iat = Number(body.iat) || 0;
            const nbf = Number(body.nbf) || 0;
            debug('verify.enforceTimestamp', { now, exp, iat, nbf });
            if (exp && exp + tolerance < now) {
                debug('verify.error.expired');
                return false;
            }
            if (iat && iat > now && iat - now > tolerance) {
                debug('verify.error.issuedAt');
                return false;
            }
            if (nbf && nbf > now && nbf - now > tolerance) {
                debug('verify.error.notBefore');
                return false;
            }
        }
        const signers = {
            secp256k1: (0, mcrypto_1.getSigner)(mcrypto_1.types.KeyType.SECP256K1),
            es256k: (0, mcrypto_1.getSigner)(mcrypto_1.types.KeyType.SECP256K1),
            ed25519: (0, mcrypto_1.getSigner)(mcrypto_1.types.KeyType.ED25519),
            ethereum: (0, mcrypto_1.getSigner)(mcrypto_1.types.KeyType.ETHEREUM),
        };
        const alg = header.alg.toLowerCase();
        if (signers[alg]) {
            // @ts-ignore
            const msgHex = (0, util_1.toHex)(`${headerB64}.${bodyB64}`);
            // If we are using v1.1 protocol, the message should be hashed before verify
            const version = body.version && semver_1.default.coerce(body.version) ? semver_1.default.coerce(body.version).version : '';
            if (version && version === JWT_VERSION_REQUIRE_HASH_BEFORE_SIGN) {
                return signers[alg].verify(hasher(msgHex), signature, signerPk);
            }
            return signers[alg].verify(msgHex, signature, signerPk);
        }
        debug('verify.error.crypto');
        return false;
    }
    catch (err) {
        debug('verify.error.exception');
        debug(err);
        return false;
    }
}
exports.verify = verify;
