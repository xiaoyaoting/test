"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.patterns = exports.schemas = exports.Joi = void 0;
const joi_1 = __importDefault(require("joi"));
const bn_1 = require("./extension/bn");
const did_1 = require("./extension/did");
exports.Joi = joi_1.default.extend(did_1.DIDExtension).extend(bn_1.BNExtension);
const txHash = /^(0x)?([A-Fa-f0-9]{64})$/;
const context = exports.Joi.object({
    genesisTime: exports.Joi.date().iso().required().raw(),
    genesisTx: exports.Joi.string().regex(txHash).required().allow(''),
    renaissanceTime: exports.Joi.date().iso().required().raw(),
    renaissanceTx: exports.Joi.string().regex(txHash).required().allow(''),
});
const tokenInput = exports.Joi.object({
    address: exports.Joi.DID().prefix().role('ROLE_TOKEN').required(),
    value: exports.Joi.BN().positive().required(),
});
const variableInput = exports.Joi.object({
    name: exports.Joi.string().min(1).max(256).required(),
    value: exports.Joi.string().min(1).max(1024).required(),
    description: exports.Joi.string().min(1).max(256).optional().allow(''),
    required: exports.Joi.boolean().optional().default(false),
});
const tokenHolder = exports.Joi.alternatives().try(exports.Joi.DID().prefix().role('ROLE_ACCOUNT'), exports.Joi.DID().prefix().role('ROLE_APPLICATION'), exports.Joi.DID().prefix().wallet('ethereum'));
const multiInput = exports.Joi.array().items(exports.Joi.object({
    owner: tokenHolder.required(),
    tokensList: exports.Joi.array().items(tokenInput).default([]),
    assetsList: exports.Joi.array().items(exports.Joi.DID().prefix().role('ROLE_ASSET')).default([]),
}));
const multiSig = exports.Joi.array().items({
    signer: exports.Joi.DID().prefix().required(),
    pk: exports.Joi.any().required(),
    signature: exports.Joi.any().required(),
    delegator: exports.Joi.DID().prefix().valid('').optional(),
    data: exports.Joi.any().optional(),
});
const foreignToken = exports.Joi.object({
    type: exports.Joi.string().min(1).max(32).required(),
    contractAddress: exports.Joi.DID().prefix().wallet('ethereum').required(),
    chainType: exports.Joi.string().min(1).max(32).required(),
    chainName: exports.Joi.string().min(1).max(32).required(),
    chainId: exports.Joi.number().positive().required(),
});
const nftDisplay = exports.Joi.object({
    type: exports.Joi.string().valid('svg', 'url', 'uri').required(),
    content: exports.Joi.string()
        .when('type', { is: 'uri', then: exports.Joi.string().max(20480).dataUri().required() }) // 20kb
        .when('type', { is: 'url', then: exports.Joi.string().max(2048).uri({ scheme: ['http', 'https'] }).required() }), // prettier-ignore
});
const nftEndpoint = exports.Joi.object({
    id: exports.Joi.string().max(2048).uri({ scheme: ['http', 'https'] }).required(),
    scope: exports.Joi.string().valid('public', 'private').default('public'),
});
const nftIssuer = exports.Joi.object({
    id: exports.Joi.DID().prefix().required(),
    pk: exports.Joi.string().required(),
    name: exports.Joi.string().min(1).max(256).required(),
});
const assetProps = {
    address: exports.Joi.DID().prefix().role('ROLE_ASSET').required(),
    moniker: exports.Joi.string().min(2).max(255).required(),
    data: exports.Joi.any().required(),
    readonly: exports.Joi.boolean().default(false),
    transferrable: exports.Joi.boolean().default(false),
    ttl: exports.Joi.number().min(0).default(0),
    parent: exports.Joi.DID().prefix().optional().allow(''),
    issuer: exports.Joi.DID().prefix().optional().allow(''),
    endpoint: nftEndpoint.optional().allow(null).default(null),
    display: nftDisplay.optional().allow(null).default(null),
    tags: exports.Joi.array().items(exports.Joi.string().min(1).max(36)).max(4).optional(),
};
const factoryProps = {
    address: exports.Joi.DID().prefix().role('ROLE_FACTORY').required(),
    name: exports.Joi.string().min(2).max(255).required(),
    description: exports.Joi.string().min(2).max(255).required(),
    settlement: exports.Joi.string().valid('instant', 'periodic').default('instant'),
    limit: exports.Joi.number().integer().min(0).default(0),
    trustedIssuers: exports.Joi.array().items(exports.Joi.DID().prefix()).max(8).optional(),
    data: exports.Joi.any().optional().allow(null).default(null),
    display: nftDisplay.optional().allow(null).default(null),
    input: exports.Joi.object({
        value: exports.Joi.BN().positive().min('0').default('0'),
        tokens: exports.Joi.array().items(tokenInput).max(8).optional(),
        assets: exports.Joi.array()
            .items(exports.Joi.alternatives().try(exports.Joi.DID().prefix().role('ROLE_ASSET'), exports.Joi.DID().prefix().role('ROLE_FACTORY')))
            .max(8)
            .optional(),
        variables: exports.Joi.array()
            .items(exports.Joi.object({
            name: exports.Joi.string().min(1).max(255).required(),
            description: exports.Joi.string().max(255).optional().allow(''),
            required: exports.Joi.boolean().required(),
        }))
            .optional(),
    }),
    output: exports.Joi.object({
        moniker: exports.Joi.string().min(2).max(255).required(),
        data: exports.Joi.any().required(),
        readonly: exports.Joi.boolean().default(false),
        transferrable: exports.Joi.boolean().default(false),
        ttl: exports.Joi.number().min(0).default(0),
        parent: exports.Joi.string().max(255).required(),
        issuer: exports.Joi.string().max(255).required(),
        endpoint: nftEndpoint.optional(),
        display: nftDisplay.optional(),
        tags: exports.Joi.array().items(exports.Joi.string().min(1).max(36)).max(4).optional(),
    }),
    hooks: exports.Joi.array()
        .items(exports.Joi.object({
        name: exports.Joi.string().valid('mint', 'postMint', 'preMint').required(),
        type: exports.Joi.string().valid('url', 'contract').required(),
        hook: exports.Joi.string().min(1).max(4096).required(),
        compiled: exports.Joi.array().items(exports.Joi.object()).optional(),
    }))
        .optional(),
};
exports.schemas = {
    context,
    tokenInput,
    multiInput,
    multiSig,
    foreignToken,
    variableInput,
    nftDisplay,
    nftEndpoint,
    nftIssuer,
    tokenHolder,
    assetProps,
    assetSchema: exports.Joi.object(assetProps).options({ stripUnknown: true, noDefaults: false }),
    factoryProps,
    factorySchema: exports.Joi.object(factoryProps).options({ stripUnknown: true, noDefaults: false }),
};
exports.patterns = {
    txHash,
};
