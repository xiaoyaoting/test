{"version":3,"sources":["../src/extension.js"],"names":["get","require","omit","cloneDeep","camelCase","toTypeInfoStr","isValid","transactions","typeUrls","multiSignTxs","multiSignV2Txs","toTxHash","createMessage","getMessageType","toTypeUrl","bytesToHex","toBase58","toBase64","toHex","toBuffer","fromTokenToUnit","fromUnitToToken","DEFAULT_TOKEN_DECIMAL","formatFactoryState","preMintFromFactory","isValidFactory","toDelegateAddress","toAssetAddress","toFactoryAddress","toTokenAddress","toStakeAddress","toRollupAddress","debug","name","createExtensionMethods","client","Object","defineProperty","value","loading","ready","callbacks","token","getContext","decimal","amount","getTxSendMethods","map","x","getTxEncodeMethods","getTxSignMethods","getTxMultiSignMethods","concat","getType","fn","decodeTx","input","Transaction","deserializeBinary","toObject","ctx","context","Promise","resolve","push","result","doRawQuery","chainId","consensus","txConfig","vaults","tokenStateMap","Map","forEach","cb","getTokenStateMap","addressList","notExistAddressList","address","has","set","size","length","getTokenState","code","state","Error","all","getWallet","wallet","publicKey","toAddress","pk","txEncodeFn","tx","delegator","w","from","nonce","Date","now","signatures","Array","isArray","signaturesList","itx","typeUrl","type","feeConfig","find","t","txObj","signature","Buffer","serviceFee","fee","txToSignBytes","serializeBinary","object","buffer","encodeMethod","__tx__","txSendFn","commit","extra","encoded","res","sign","reject","txHash","txMsg","txBytes","txStr","hash","sendTx","err","sendMethod","_formatEncodedTx","encoding","txSignFn","signMethod","includes","txMultiSignFn","data","unshift","signer","multiSignMethod","item","s","declare","moniker","issuer","itxData","sendDeclareTx","migrateAccount","to","sendAccountMigrateTx","delegate","privileges","ops","rules","txTypes","values","filter","startsWith","some","sendDelegateTx","revokeDelegate","sendRevokeDelegateTx","Boolean","toString","createAsset","parent","ttl","readonly","transferrable","display","endpoint","tags","payload","sendCreateAssetTx","updateAsset","sendUpdateAssetTx","createAssetFactory","factory","description","settlement","limit","trustedIssuers","output","hooks","sendCreateFactoryTx","preMintAsset","inputs","owner","options","ignoreFields","factoryState","issuerState","getFactoryState","getAccountState","asset","variables","assign","entries","key","acquireAsset","sendAcquireAssetV2Tx","mintAsset","sendMintAssetTx","transfer","assets","tokens","memo","contextToken","tmpTokens","tokensMap","sendTransferV2Tx","stake","slashers","locked","message","multiSignStakeTx","receiver","signStakeTx","sendStakeTx","revokeStake","sendRevokeStakeTx","outputs","slashStake","reason","sendSlashStakeTx","slashedStake","claimStake","evidence","sendClaimStakeTx","createRollup","props","requiredProps","tokenAddress","foreignToken","toBNStr","n","maxStakeAmount","minStakeAmount","minSignerCount","maxSignerCount","minBlockSize","maxBlockSize","minBlockInterval","minBlockConfirmation","minDepositAmount","maxDepositAmount","minWithdrawAmount","maxWithdrawAmount","depositFeeRate","withdrawFeeRate","publisherFeeShare","proposerFeeShare","minDepositFee","maxDepositFee","minWithdrawFee","maxWithdrawFee","leaveWaitingPeriod","publishWaitingPeriod","publishSlashRate","sendCreateRollupTx","prepareExchange","offerToken","offerAssets","demandToken","demandAssets","offerTokens","demandTokens","tmpOfferTokens","tmpDemandTokens","signExchangeV2Tx","sender","finalizeExchange","multiSignExchangeV2Tx","exchange","sendExchangeV2Tx","createToken","symbol","unit","icon","totalSupply","initialSupply","tokenDecimal","sendCreateTokenTx","module","exports"],"mappings":"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","file":"extension.js","sourcesContent":["/* eslint-disable prefer-object-spread */\n/* eslint-disable no-underscore-dangle */\n/* eslint-disable object-curly-newline */\nconst get = require('lodash/get');\nconst omit = require('lodash/omit');\nconst cloneDeep = require('lodash/cloneDeep');\nconst camelCase = require('lodash/camelCase');\nconst { toTypeInfoStr, isValid } = require('@arcblock/did');\nconst { transactions, typeUrls, multiSignTxs, multiSignV2Txs } = require('@ocap/proto');\nconst { toTxHash } = require('@ocap/mcrypto');\nconst { createMessage, getMessageType, toTypeUrl } = require('@ocap/message');\nconst { bytesToHex, toBase58, toBase64, toHex, toBuffer, fromTokenToUnit, fromUnitToToken } = require('@ocap/util');\nconst { DEFAULT_TOKEN_DECIMAL } = require('@ocap/util/lib/constant');\nconst { formatFactoryState, preMintFromFactory, isValidFactory } = require('@ocap/asset');\nconst {\n  toDelegateAddress,\n  toAssetAddress,\n  toFactoryAddress,\n  toTokenAddress,\n  toStakeAddress,\n  toRollupAddress,\n} = require('@arcblock/did-util');\n\nconst debug = require('debug')(require('../package.json').name);\n\n/**\n * Generate extension methods on the fly\n *\n * @public\n * @param {GraphQLClient} client\n */\nconst createExtensionMethods = (client) => {\n  Object.defineProperty(client, 'ctx', {\n    value: {\n      loading: false,\n      ready: false,\n      callbacks: [],\n    },\n  });\n\n  /**\n   * Format big number presentation amount to token number\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#fromUnitToToken\n   * @param {string} value\n   * @returns {string}\n   */\n  client.fromUnitToToken = async (value) => {\n    const { token } = await client.getContext();\n    return fromUnitToToken(value, token.decimal);\n  };\n\n  /**\n   * Encode amount to corresponding token big number presentation\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#fromTokenToUnit\n   * @param {number} amount\n   * @returns {BN}\n   */\n  client.fromTokenToUnit = async (amount) => {\n    const { token } = await client.getContext();\n    return fromTokenToUnit(amount, token.decimal);\n  };\n\n  /**\n   * List all transaction send methods\n   * Each method can send one kind of transactions supported by forge core, such as `DeclareTx`\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#getTxSendMethods\n   * @returns {Array<string>} method name list\n   */\n  client.getTxSendMethods = () => transactions.map((x) => camelCase(`send_${x}`));\n\n  /**\n   * List all transaction encode methods, each method can be used to encode transaction to buffer and object\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#getTxEncodeMethods\n   * @returns {Array<string>} method name list\n   */\n  client.getTxEncodeMethods = () => transactions.map((x) => camelCase(`encode_${x}`));\n\n  /**\n   * List all transaction sign methods, each method can be used to sign transaction to an object\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#getTxSignMethods\n   * @returns {Array<string>} method name list\n   */\n  client.getTxSignMethods = () => transactions.map((x) => camelCase(`sign_${x}`));\n\n  /**\n   * List all transaction multi sign methods, each method can be used to do multi sign a transaction\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#getTxMultiSignMethods\n   * @returns {Array<string>} method name list\n   */\n  client.getTxMultiSignMethods = () => multiSignTxs.concat(multiSignV2Txs).map((x) => camelCase(`multi_sign_${x}`));\n\n  /**\n   * Get protobuf message class by name, only supports forge-built-in types\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#getType\n   * @param {string} x\n   * @returns {class|null} message type\n   */\n  client.getType = (x) => getMessageType(x).fn;\n\n  /**\n   * Decode transaction buffer/base64/base58 to an object\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#decodeTx\n   * @param {buffer|hex|base48|base64} input\n   * @returns {object} transaction object\n   */\n  client.decodeTx = (input) => {\n    const Transaction = client.getType('Transaction');\n    return Transaction.deserializeBinary(toBuffer(input)).toObject();\n  };\n\n  /**\n   * Ensure a connection is bootstrapped with some meta info fetched from chain node\n   *\n   * @private\n   * @param {string} [conn=undefined]\n   * @returns {object}\n   */\n  client.getContext = async () => {\n    if (client.ctx.ready) {\n      return client.context;\n    }\n\n    if (client.ctx.loading) {\n      return new Promise((resolve) => {\n        client.ctx.callbacks.push(() => resolve(client.context));\n      });\n    }\n\n    client.ctx.loading = true;\n    const result = await client.doRawQuery(`{\n      getChainInfo {\n        code\n        info {\n          network\n          consensusVersion\n        }\n      }\n      getForgeState {\n        code\n        state {\n          token {\n            decimal\n            symbol\n          }\n          vaults {\n            slashedStake\n            txFee\n            txGas\n          }\n          txConfig {\n            txFee {\n              fee\n              typeUrl\n            }\n            txGas {\n              price\n              createState\n              updateState\n              dataStorage\n              minStake\n              maxStake\n              stakeLockPeriod\n            }\n          }\n        }\n      }\n    }`);\n\n    client.context = {\n      chainId: get(result, 'getChainInfo.info.network'),\n      consensus: get(result, 'getChainInfo.info.consensusVersion'),\n      token: get(result, 'getForgeState.state.token'),\n      txConfig: get(result, 'getForgeState.state.txConfig'),\n      vaults: get(result, 'getForgeState.state.vaults'),\n      tokenStateMap: new Map(),\n    };\n\n    client.ctx.ready = true;\n    client.ctx.loading = false;\n    client.ctx.callbacks.forEach((cb) => cb());\n    debug('context ready');\n\n    return client.context;\n  };\n\n  client.getTokenStateMap = async (addressList) => {\n    const result = new Map();\n    const notExistAddressList = [];\n    addressList.forEach((address) => {\n      if (client.context.tokenStateMap.has(address)) {\n        result.set(address, client.context.tokenStateMap.get(address));\n      } else {\n        notExistAddressList.push(address);\n      }\n    });\n\n    if (result.size === addressList.length) {\n      return result;\n    }\n\n    const getTokenState = async (address) => {\n      const {\n        getTokenState: { code, state },\n      } = await client.doRawQuery(`{\n        getTokenState(address: \"${address}\") {\n          code\n          state {\n            decimal\n          }\n        }\n      }`);\n\n      if (code !== 'OK') {\n        throw new Error(`get token ${address} state failed`);\n      }\n\n      result.set(address, state);\n      client.context.tokenStateMap.set(address, state);\n    };\n\n    await Promise.all(notExistAddressList.map((address) => getTokenState(address)));\n\n    return result;\n  };\n\n  // Unify a client wallet | forge managed wallet\n  const getWallet = (wallet) => {\n    if (!wallet) {\n      return {\n        address: '',\n        publicKey: '',\n      };\n    }\n\n    if (typeof wallet.toAddress === 'function') {\n      return {\n        address: wallet.address,\n        publicKey: wallet.publicKey,\n      };\n    }\n\n    return {\n      address: wallet.address,\n      publicKey: wallet.pk || wallet.publicKey || '',\n    };\n  };\n\n  // Generate transaction sign/send/encode functions on fly\n  transactions.forEach((x) => {\n    /**\n     * Encode a transaction\n     *\n     * @param {object} input\n     * @param {object} input.tx - data of the transaction\n     * @param {object} input.tx.itx - the actual transaction object\n     * @param {object} [input.tx.from] - the sender address, can be derived from wallet\n     * @param {object} [input.tx.nonce] - the tx nonce, defaults to Date.now if not set\n     * @param {object} [input.tx.chainId] - the chainId\n     * @param {object} [input.tx.signature] - the signature\n     * @param {object} [input.tx.signatures] - the signature list\n     * @param {object} input.wallet - the wallet used to sign the transaction\n     * @param {object} input.delegator - the wallet address that delegated permissions to the `input.wallet` address\n     * @returns Promise\n     */\n    const txEncodeFn = async ({ tx, wallet, delegator }) => {\n      const w = getWallet(wallet);\n      const context = await client.getContext();\n\n      // Determine sender address\n      const address = tx.from || w.address;\n      const pk = tx.pk || w.publicKey;\n\n      // Determine chainId & nonce, only attach new one when not exist\n      const nonce = typeof tx.nonce === 'undefined' ? Date.now() : tx.nonce;\n      let chainId = tx.chainId || '';\n      if (!chainId) {\n        // eslint-disable-next-line prefer-destructuring\n        chainId = context.chainId;\n      }\n\n      // Determine signatures for multi sig\n      let signatures = [];\n      if (Array.isArray(tx.signatures)) {\n        // eslint-disable-next-line prefer-destructuring\n        signatures = tx.signatures;\n      }\n      if (Array.isArray(tx.signaturesList)) {\n        signatures = tx.signaturesList;\n      }\n\n      // Determine itx\n      let itx = null;\n      if (tx.itx.typeUrl && tx.itx.value) {\n        // eslint-disable-next-line prefer-destructuring\n        itx = tx.itx;\n      } else {\n        itx = { type: x, value: tx.itx };\n      }\n\n      const type = itx.typeUrl || toTypeUrl(itx.type);\n      const feeConfig = get(context, 'txConfig.txFee', []).find((t) => t.typeUrl === type);\n\n      const txObj = createMessage('Transaction', {\n        from: tx.delegator ? address : delegator || address,\n        nonce,\n        pk,\n        chainId,\n        signature: tx.signature || Buffer.from([]),\n        signatures,\n        delegator: tx.delegator || (delegator ? address : ''),\n        itx,\n        serviceFee: feeConfig ? feeConfig.fee : '0',\n      });\n      const txToSignBytes = txObj.serializeBinary();\n\n      debug(`encodeTx.${x}.txObj`, txObj.toObject());\n\n      return { object: txObj.toObject(), buffer: Buffer.from(txToSignBytes) };\n    };\n\n    const encodeMethod = camelCase(`encode_${x}`);\n    txEncodeFn.__tx__ = encodeMethod;\n    client[encodeMethod] = txEncodeFn;\n\n    /**\n     * Send a transaction\n     *\n     * @param {object} input\n     * @param {object} input.tx - data of the transaction\n     * @param {object} input.tx.itx - the actual transaction object\n     * @param {object} [input.tx.from] - the sender address, can be derived from wallet\n     * @param {object} [input.tx.nonce] - the tx nonce, defaults to Date.now if not set\n     * @param {object} [input.tx.chainId] - the chainId\n     * @param {object} [input.tx.signature] - the signature\n     * @param {object} [input.tx.signatures] - the signatures\n     * @param {object} [input.commit=false] - whether we should wait for transaction commit\n     * @param {object} input.wallet - the wallet used to sign the transaction, either a forge managed wallet or user managed wallet\n     * @param {object} [input.signature] - the signature of the tx, if exist, we will not sign the transaction\n     * @param {object} input.delegator - the wallet address that delegated permissions to the `input.wallet` address\n     * @returns {Promise<string>}\n     */\n    const txSendFn = async ({ tx, wallet, signature, delegator, commit = false }, extra = {}) => {\n      let encoded;\n      if (signature) {\n        encoded = tx;\n        encoded.signature = signature;\n      } else if (tx.signature) {\n        const res = await txEncodeFn({ tx, wallet, delegator });\n        encoded = res.object;\n      } else {\n        const res = await txEncodeFn({ tx, wallet, delegator });\n        encoded = res.object;\n        encoded.signature = wallet.sign(bytesToHex(res.buffer));\n      }\n\n      // eslint-disable-next-line no-async-promise-executor\n      return new Promise(async (resolve, reject) => {\n        let txHash = null;\n        try {\n          const txMsg = createMessage('Transaction', encoded);\n          const txBytes = txMsg.serializeBinary();\n          const txStr = toBase64(txBytes);\n          txHash = toTxHash(txBytes);\n          debug(`sendTx.${x}.txObj`, txMsg.toObject());\n          const { hash } = await client.sendTx({ tx: txStr, commit }, extra);\n          resolve(hash);\n        } catch (err) {\n          err.txHash = txHash;\n          reject(err);\n        }\n      });\n    };\n\n    const sendMethod = camelCase(`send_${x}`);\n    txSendFn.__tx__ = sendMethod;\n    client[sendMethod] = txSendFn;\n\n    const _formatEncodedTx = async (tx, encoding) => {\n      if (encoding) {\n        const { buffer: txBytes } = await txEncodeFn({ tx });\n        if (encoding === 'base64') {\n          return toBase64(txBytes);\n        }\n        if (encoding === 'base58') {\n          return toBase58(txBytes);\n        }\n        if (encoding === 'base16' || encoding === 'hex') {\n          return toHex(txBytes);\n        }\n        return txBytes;\n      }\n\n      return tx;\n    };\n\n    // Generate transaction signing function\n    const txSignFn = async ({ tx, wallet, delegator, encoding = '' }) => {\n      if (tx.signature) {\n        delete tx.signature;\n      }\n\n      const { object, buffer } = await txEncodeFn({ tx, wallet, delegator });\n      object.signature = wallet.sign(buffer);\n\n      return _formatEncodedTx(object, encoding);\n    };\n    const signMethod = camelCase(`sign_${x}`);\n    txSignFn.__tx__ = signMethod;\n    client[signMethod] = txSignFn;\n\n    // TODO: verify existing signatures before adding new signatures\n    // Generate transaction multi sign function\n    if (multiSignTxs.includes(x)) {\n      const txMultiSignFn = async ({ tx, wallet, delegator, data, encoding = '' }) => {\n        if (typeof wallet.toAddress !== 'function') {\n          throw new Error('Multisig requires a valid wallet');\n        }\n        tx.signaturesList = tx.signatures || tx.signaturesList || [];\n        if (delegator) {\n          tx.signaturesList.unshift({\n            pk: wallet.publicKey,\n            signer: delegator,\n            delegator: wallet.address,\n            data,\n          });\n        } else {\n          tx.signaturesList.unshift({\n            pk: wallet.publicKey,\n            signer: wallet.address,\n            delegator: '',\n            data,\n          });\n        }\n\n        const { object, buffer } = await txEncodeFn({ tx, wallet });\n        object.signaturesList[0].signature = wallet.sign(bytesToHex(buffer));\n        return _formatEncodedTx(object, encoding);\n      };\n      const multiSignMethod = camelCase(`multi_sign_${x}`);\n      txMultiSignFn.__tx__ = multiSignMethod;\n      client[multiSignMethod] = txMultiSignFn;\n    }\n\n    if (multiSignV2Txs.includes(x)) {\n      const txMultiSignFn = async ({ tx, wallet, encoding = '' }) => {\n        if (typeof wallet.toAddress !== 'function') {\n          throw new Error('Multisig requires a valid wallet');\n        }\n\n        const signer = wallet.address;\n        const signatures = cloneDeep(tx.signatures || tx.signaturesList || []);\n        const item = signatures.find((s) => s.signer === signer || s.delegator === signer);\n        if (!item) {\n          throw new Error('Signer not in the list');\n        }\n\n        tx.signaturesList = signatures.map((s) => omit(s, ['signature']));\n        const { object, buffer } = await txEncodeFn({ tx, wallet });\n\n        item.signature = wallet.sign(bytesToHex(buffer));\n        object.signaturesList = signatures;\n        return _formatEncodedTx(object, encoding);\n      };\n      const multiSignMethod = camelCase(`multi_sign_${x}`);\n      txMultiSignFn.__tx__ = multiSignMethod;\n      client[multiSignMethod] = txMultiSignFn;\n    }\n  });\n\n  /**\n   * Declare an DID and it's public key on chain\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#declare\n   * @param {object} params\n   * @param {string} params.moniker - user nickname\n   * @param {string} [params.issuer=\"\"] - who issued the account\n   * @param {object} [params.data=undefined] - who issued the account\n   * @param {WalletObject} params.wallet - wallet to sign the tx\n   * @param {object} extra - other param to underlying client implementation\n   * @returns {Promise} the transaction hash once resolved\n   */\n  client.declare = ({ moniker, issuer = '', data, wallet }, extra) => {\n    let itxData = data;\n\n    // If there is no data attached to the account, we can attach wallet type by default\n    if (!itxData) {\n      itxData = { typeUrl: 'json', value: toTypeInfoStr(wallet.address) };\n    }\n\n    return client.sendDeclareTx(\n      {\n        tx: {\n          itx: { moniker, issuer, data: itxData },\n        },\n        wallet,\n      },\n      extra\n    );\n  };\n\n  /**\n   * Migrate current account to a new account\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#migrateAccount\n   * @param {object} params\n   * @param {WalletObject} params.from - which account to migrate from\n   * @param {WalletObject} params.to - which account to migrate to\n   * @param {object} extra - other param to underlying client implementation\n   * @returns {Promise} the transaction hash once resolved\n   */\n  client.migrateAccount = ({ from, to }, extra) =>\n    client.sendAccountMigrateTx(\n      {\n        tx: {\n          itx: {\n            address: to.address,\n            pk: to.publicKey,\n            type: to.type,\n          },\n        },\n        wallet: from,\n      },\n      extra\n    );\n\n  /**\n   * Delegate some privileges to another account\n   * So that that account can send transactions on behalf of the delegator\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#delegate\n   * @param {object} params\n   * @param {WalletObject} params.from - the delegator, who grants the privilege to others\n   * @param {WalletObject} params.to - the delegatee, who is authorized to send transactions\n   * @param {Array} params.privileges - the privilege settings\n   * @param {object} extra - other param to underlying client implementation\n   * @returns {Promise} the `[transactionHash, delegateAddress]` once resolved\n   */\n  client.delegate = async ({ from, to, privileges }, extra) => {\n    let ops = Array.isArray(privileges) ? privileges : [privileges];\n    ops = ops.map((x) => {\n      if (x.typeUrl && Array.isArray(x.rules)) {\n        return x;\n      }\n\n      return { typeUrl: x.typeUrl, rules: [] };\n    });\n\n    const txTypes = Object.values(typeUrls).filter((x) => x.startsWith('fg:t:'));\n    if (ops.some((x) => txTypes.includes(x.typeUrl) === false)) {\n      throw new Error('Invalid type url provided for delegation');\n    }\n\n    const address = toDelegateAddress(from.address, to.address);\n    const hash = await client.sendDelegateTx(\n      {\n        tx: {\n          itx: {\n            address,\n            to: to.address,\n            ops,\n          },\n        },\n        wallet: from,\n      },\n      extra\n    );\n\n    return [hash, address];\n  };\n\n  /**\n   * Revoke a previous delegation\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#revokeDelegate\n   * @param {object} params\n   * @param {WalletObject} params.from - the delegator, who grants the privilege to others\n   * @param {WalletObject} params.to - the delegatee, who is authorized to send transactions\n   * @param {Array} params.privileges - the privilege settings\n   * @param {object} extra - other param to underlying client implementation\n   * @returns {Promise} the transaction hash once resolved\n   */\n  client.revokeDelegate = ({ from, to, privileges }, extra) =>\n    client.sendRevokeDelegateTx(\n      {\n        tx: {\n          itx: {\n            address: toDelegateAddress(from.address, to.address),\n            to: to.address,\n            typeUrls: privileges.filter(Boolean).map((x) => x.toString()),\n          },\n        },\n        wallet: from,\n      },\n      extra\n    );\n\n  /**\n   * Create an new asset (non-fungible-token)\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#createAsset\n   * @param {object} params\n   * @param {string} params.moniker - asset name\n   * @param {string} params.parent - asset parent\n   * @param {object} params.data - asset data payload\n   * @param {number} params.ttl - ttl after first consumption\n   * @param {boolean} params.readonly - whether the asset can be updated after creation\n   * @param {boolean} params.transferrable - whether the asset can be transferred to another account\n   * @param {object} params.display - the display of the asset\n   * @param {object} params.endpoint - the endpoint of the asset\n   * @param {string} params.tags - the tag list of the asset\n   * @param {string} params.delegator - who authorized this transaction\n   * @param {WalletObject} params.wallet - the initial owner of the asset\n   * @param {object} extra - other param to underlying client implementation\n   * @returns {Promise} the `[transactionHash, assetAddress]` once resolved\n   */\n  client.createAsset = async (\n    {\n      moniker,\n      parent = '',\n      ttl = 0,\n      data,\n      readonly = false,\n      transferrable = true,\n      display,\n      endpoint,\n      tags = [],\n      delegator = '',\n      wallet,\n    },\n    extra\n  ) => {\n    const payload = { moniker, parent, ttl, readonly, transferrable, data, display, endpoint, tags };\n    const address = toAssetAddress(payload);\n    payload.address = address;\n    const hash = await client.sendCreateAssetTx(\n      {\n        tx: { itx: payload },\n        delegator,\n        wallet,\n      },\n      extra\n    );\n    return [hash, address];\n  };\n\n  /**\n   * Update an existing asset (non-fungible-token)\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#updateAsset\n   * @param {object} params\n   * @param {string} params.address - asset address\n   * @param {string} params.moniker - asset name\n   * @param {object} params.data - asset data payload\n   * @param {WalletObject} params.wallet - the wallet to sign the transaction\n   * @param {object} extra - other param to underlying client implementation\n   * @returns {Promise} the `transactionHash` once resolved\n   */\n  client.updateAsset = ({ address, moniker, data, wallet }, extra) =>\n    client.sendUpdateAssetTx(\n      {\n        tx: {\n          itx: {\n            moniker,\n            address,\n            data,\n          },\n        },\n        wallet,\n      },\n      extra\n    );\n\n  /**\n   * Create an asset factory that can be used to mint new assets in future transactions\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#createAssetFactory\n   * @param {object} params\n   * @param {string} params.factory - asset factory\n   * @param {WalletObject} params.wallet - the initial owner of the asset\n   * @param {object} extra - other param to underlying client implementation\n   * @returns {Promise} the `[transactionHash, factoryAddress]` once resolved\n   */\n  client.createAssetFactory = async ({ factory, wallet }, extra) => {\n    const itx = {\n      name: factory.name,\n      description: factory.description,\n      settlement: factory.settlement || 'instant',\n      limit: factory.limit || 0,\n      trustedIssuers: factory.trustedIssuers || [],\n      input: factory.input,\n      output: factory.output,\n      data: factory.data || null,\n      hooks: factory.hooks || [],\n      display: factory.display || null,\n    };\n\n    itx.address = toFactoryAddress(itx);\n\n    isValidFactory(itx, true);\n\n    const hash = await client.sendCreateFactoryTx({ tx: { itx }, wallet }, extra);\n    return [hash, itx.address];\n  };\n\n  /**\n   * Prepare an acquire_asset itx\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#preMintAsset\n   * @param {object} params\n   * @param {string} params.factory - asset factory address\n   * @param {object} params.inputs - factory inputs\n   * @param {string} params.owner - who will own the asset\n   * @param {WalletObject} params.wallet - the wallet of the asset issuer\n   * @param {object} extra - other param to merge into the itx\n   * @returns {Promise} the `[transactionHash, factoryAddress]` once resolved\n   */\n  client.preMintAsset = async ({ factory, inputs = {}, owner, wallet, extra = {} }) => {\n    const options = { ignoreFields: ['context.genesisTx', 'context.renaissanceTx'] };\n    const [{ state: factoryState }, { state: issuerState }] = await Promise.all([\n      client.getFactoryState({ address: factory }, options),\n      client.getAccountState({ address: wallet.address }, options),\n    ]);\n\n    if (!factoryState) {\n      throw new Error('Factory does not exist on chain');\n    }\n\n    if (!issuerState) {\n      throw new Error('Issuer does not exist on chain');\n    }\n\n    const { asset, address, issuer, variables } = preMintFromFactory({\n      factory: formatFactoryState(factoryState),\n      inputs,\n      owner,\n      issuer: { wallet, name: issuerState.moniker },\n    });\n\n    return Object.assign({}, extra, {\n      asset: Object.assign({ address, owner, parent: factory }, asset),\n      factory,\n      address,\n      variables: Object.entries(variables).map(([key, value]) => ({ name: key, value })),\n      issuer,\n      owner,\n    });\n  };\n\n  /**\n   * Acquire an asset from factory\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#acquireAsset\n   * @param {object} params\n   * @param {AcquireAssetV2Tx} params.itx - result from preMintAsset\n   * @param {string} params.delegator - who authorized this transaction\n   * @param {WalletObject} params.wallet - the initial owner of the asset\n   * @param {object} extra - other param to underlying client implementation\n   * @returns {Promise} the `transactionHash` once resolved\n   */\n  client.acquireAsset = ({ itx, delegator = '', wallet }, extra) =>\n    client.sendAcquireAssetV2Tx({ tx: { itx }, delegator, wallet }, extra);\n\n  /**\n   * Mint an asset from factory\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#mintAsset\n   * @param {object} params\n   * @param {MintAssetTx} params.itx - result from preMintAsset\n   * @param {WalletObject} params.wallet - the initial owner of the asset\n   * @param {object} extra - other param to underlying client implementation\n   * @returns {Promise} the `transactionHash` once resolved\n   */\n  client.mintAsset = ({ itx, wallet }, extra) => client.sendMintAssetTx({ tx: { itx }, wallet }, extra);\n\n  /**\n   * Transfer token or assets to another account\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#transfer\n   * @param {object} params\n   * @param {number} params.token - how much token can be transferred\n   * @param {Array} params.assets - which assets should be transferred\n   * @param {string} params.to - who receive the transfer\n   * @param {string} params.memo - transaction note\n   * @param {string} params.delegator - who authorized this transaction\n   * @param {WalletObject} params.wallet - the wallet to sign the transaction\n   * @param {object} extra - other param to underlying client implementation\n   * @returns {Promise} the `transactionHash` once resolved\n   */\n  client.transfer = async (\n    { token = 0, assets = [], tokens = [], to = '', memo = '', delegator = '', wallet },\n    extra\n  ) => {\n    if (isValid(to) === false) {\n      throw new Error('Can not transfer without valid recipient');\n    }\n    if (!token && tokens.length === 0 && assets.length === 0) {\n      throw new Error('Can not transfer without payload');\n    }\n\n    const { token: contextToken } = await client.getContext();\n\n    let tmpTokens = [];\n    if (tokens.length > 0) {\n      const tokensMap = await client.getTokenStateMap(tokens.map((t) => t.address));\n      tmpTokens = tokens.map((t) => {\n        t.value = fromTokenToUnit(t.value, tokensMap.get(t.address).decimal).toString();\n        return t;\n      });\n    }\n\n    return client.sendTransferV2Tx(\n      {\n        tx: {\n          itx: {\n            to,\n            value: fromTokenToUnit(token, contextToken.decimal),\n            assets,\n            tokens: tmpTokens,\n            data: {\n              typeUrl: 'json',\n              value: memo || 'empty',\n            },\n          },\n        },\n        delegator,\n        wallet,\n      },\n      extra\n    );\n  };\n\n  /**\n   * Stake token or assets for another account\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#stake\n   * @param {object} params\n   * @param {Array} params.assets - which assets to stake\n   * @param {Array} params.tokens - which tokens to stake\n   * @param {string} params.to - who receive the stake\n   * @param {boolean} params.locked - is the stake locked on creation\n   * @param {string[]} params.slashers - who can slash from this, default to [to]\n   * @param {string} params.message - stake note\n   * @param {WalletObject} params.wallet - the wallet to sign the transaction\n   * @param {object} extra - other param to underlying client implementation\n   * @returns {Promise} the `transactionHash` and `stakeAddress` once resolved\n   */\n  client.stake = async (\n    { assets = [], tokens = [], slashers = [], to = '', locked = false, message = '', wallet },\n    extra\n  ) => {\n    let tmpTokens = [];\n    if (tokens.length > 0) {\n      const tokensMap = await client.getTokenStateMap(tokens.map((t) => t.address));\n      tmpTokens = tokens.map((t) => {\n        t.value = fromTokenToUnit(t.value, tokensMap.get(t.address).decimal).toString();\n        return t;\n      });\n    }\n\n    const from = wallet.address;\n    const address = toStakeAddress(from, to);\n    let tx = await client.multiSignStakeTx(\n      {\n        tx: {\n          itx: {\n            address,\n            receiver: to,\n            locked,\n            message,\n            slashers,\n            inputs: [\n              {\n                owner: from,\n                assets,\n                tokens: tmpTokens,\n              },\n            ],\n          },\n          signatures: [\n            {\n              signer: from,\n              pk: wallet.publicKey,\n            },\n          ],\n        },\n        wallet,\n      },\n      extra\n    );\n\n    tx = await client.signStakeTx({ tx, wallet });\n    const hash = await client.sendStakeTx({ tx, wallet }, extra);\n    return [hash, address];\n  };\n\n  /**\n   * Revoke token or assets from some stake\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#revokeStake\n   * @param {object} params\n   * @param {Array} params.assets - which assets to stake\n   * @param {Array} params.tokens - which tokens to stake\n   * @param {string} params.from - stake address\n   * @param {WalletObject} params.wallet - the wallet to sign the transaction\n   * @param {object} extra - other param to underlying client implementation\n   * @returns {Promise} the `transactionHash` once resolved\n   */\n  client.revokeStake = async ({ assets = [], tokens = [], from = '', wallet }, extra) => {\n    let tmpTokens = [];\n    if (tokens.length > 0) {\n      const tokensMap = await client.getTokenStateMap(tokens.map((t) => t.address));\n      tmpTokens = tokens.map((t) => {\n        t.value = fromTokenToUnit(t.value, tokensMap.get(t.address).decimal).toString();\n        return t;\n      });\n    }\n\n    return client.sendRevokeStakeTx(\n      {\n        tx: {\n          itx: {\n            address: from,\n            outputs: [\n              {\n                owner: wallet.address,\n                assets,\n                tokens: tmpTokens,\n              },\n            ],\n          },\n        },\n        wallet,\n      },\n      extra\n    );\n  };\n\n  /**\n   * Slash token or assets from some stake\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#slashStake\n   * @param {object} params\n   * @param {Array} params.assets - which assets to slash\n   * @param {Array} params.tokens - which tokens to slash\n   * @param {string} params.from - stake address\n   * @param {string} params.reason - slash reason\n   * @param {WalletObject} params.wallet - the wallet to sign the transaction\n   * @param {object} extra - other param to underlying client implementation\n   * @returns {Promise} the `transactionHash` once resolved\n   */\n  client.slashStake = async ({ assets = [], tokens = [], reason, from, wallet }, extra) => {\n    if (!reason) {\n      throw new Error('Can not slash stake without valid reason message');\n    }\n    if (!from) {\n      throw new Error('Can not slash stake without stake address');\n    }\n\n    const { vaults } = await client.getContext();\n\n    let tmpTokens = [];\n    if (tokens.length > 0) {\n      const tokensMap = await client.getTokenStateMap(tokens.map((t) => t.address));\n      tmpTokens = tokens.map((t) => {\n        t.value = fromTokenToUnit(t.value, tokensMap.get(t.address).decimal).toString();\n        return t;\n      });\n    }\n\n    return client.sendSlashStakeTx(\n      {\n        tx: {\n          itx: {\n            address: from,\n            message: reason,\n            outputs: [\n              {\n                owner: vaults.slashedStake,\n                assets,\n                tokens: tmpTokens,\n              },\n            ],\n          },\n        },\n        wallet,\n      },\n      extra\n    );\n  };\n\n  /**\n   * Claim revoked token or assets from stake\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#claimStake\n   * @param {object} params\n   * @param {string} params.from - stake address\n   * @param {Array} params.evidence - which revoke tx hash to use\n   * @param {WalletObject} params.wallet - the wallet to sign the transaction\n   * @param {object} extra - other param to underlying client implementation\n   * @returns {Promise} the `transactionHash` once resolved\n   */\n  client.claimStake = async ({ from, evidence, wallet }, extra) => {\n    if (!evidence) {\n      throw new Error('Can not claim stake without valid evidence tx hash');\n    }\n    if (!from) {\n      throw new Error('Can not claim stake without stake address');\n    }\n\n    return client.sendClaimStakeTx(\n      {\n        tx: {\n          itx: {\n            address: from,\n            evidence: { hash: evidence },\n          },\n        },\n        wallet,\n      },\n      extra\n    );\n  };\n\n  /**\n   * Create an rollup (sub-chain that lives in ocap)\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#createRollup\n   * @param {object} params\n   * @param {string} params.tokenAddress - ocap token address\n   * @param {string} params.contractAddress - rollup contract address\n   * @param {string} params.minStakeAmount\n   * @param {string} params.maxStakeAmount\n   * @param {number} params.minSignerCount\n   * @param {number} params.maxSignerCount\n   * @param {number} params.minBlockSize\n   * @param {number} params.maxBlockSize\n   * @param {number} params.minBlockInterval - in seconds\n   * @param {number} params.minBlockConfirmation\n   * @param {number} params.leaveWaitingPeriod\n   * @param {number} params.publishWaitingPeriod\n   * @param {number} params.publishSlashRate\n   * @param {Array} params.seedValidators - list of seed validators\n   * @param {object} params.data - data payload\n   * @param {WalletObject} params.wallet - the initial owner of the asset\n   * @param {object} extra - other param to underlying client implementation\n   * @returns {Promise} the `[transactionHash, rollupAddress]` once resolved\n   */\n  client.createRollup = async (props, extra) => {\n    const requiredProps = ['tokenAddress', 'vaultAddress', 'contractAddress', 'seedValidators', 'minStakeAmount'];\n    for (const key of requiredProps) {\n      if (!props[key]) {\n        throw new Error(`Missing required property: ${key} when creating rollup`);\n      }\n    }\n\n    const { state } = await client.getTokenState({ address: props.tokenAddress });\n    if (!state) {\n      throw new Error(`Token ${props.tokenAddress} not found when creating rollup`);\n    }\n    if (!state.foreignToken) {\n      throw new Error(`Token ${props.tokenAddress} does not have foreignToken attached`);\n    }\n\n    const toBNStr = (n) => fromTokenToUnit(n, state.decimal).toString(10);\n    const itx = Object.assign(\n      {\n        maxStakeAmount: props.minStakeAmount,\n        minSignerCount: 3,\n        maxSignerCount: 5,\n        minBlockSize: 1,\n        maxBlockSize: 10,\n        minBlockInterval: 1 * 60, // 1 minute\n        minBlockConfirmation: 3,\n        minDepositAmount: toBNStr(100),\n        maxDepositAmount: toBNStr(1000000),\n        minWithdrawAmount: toBNStr(100),\n        maxWithdrawAmount: toBNStr(1000000),\n        depositFeeRate: 100, // 1%\n        withdrawFeeRate: 100, // 1%\n        publisherFeeShare: 6000, // 60%\n        proposerFeeShare: 3000, // 30%\n        // validatorFeeShare: 1000, // 10%\n        minDepositFee: toBNStr(1),\n        maxDepositFee: toBNStr(10000),\n        minWithdrawFee: toBNStr(1),\n        maxWithdrawFee: toBNStr(10000),\n        leaveWaitingPeriod: 60 * 60, // 1 hour\n        publishWaitingPeriod: 60 * 60, // 1 hour\n        publishSlashRate: 10, // 0.1%\n      },\n      props\n    );\n\n    const address = toRollupAddress(itx);\n    itx.address = address;\n\n    const hash = await client.sendCreateRollupTx({ tx: { itx }, wallet: props.wallet }, extra);\n\n    return [hash, address];\n  };\n\n  /**\n   * Prepare an exchange transaction between multiple accounts\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#prepareExchange\n   * @param {object} params\n   * @param {number} params.offerToken - how much token can be sent\n   * @param {Array} params.offerAssets - which assets should be sent\n   * @param {number} params.demandToken - how much token can be received\n   * @param {Array} params.demandAssets - which assets should be received\n   * @param {string} params.receiver - who receive the transfer\n   * @param {string} params.memo - transaction note\n   * @param {string} params.delegator - which assets should be transferred\n   * @param {WalletObject} params.wallet - the wallet who is the offerer\n   * @param {object} extra - other param to underlying client implementation\n   * @returns {Promise} the `transaction` object once resolved\n   */\n  client.prepareExchange = async (\n    {\n      offerToken = 0,\n      offerAssets = [],\n      demandToken = 0,\n      demandAssets = [],\n      offerTokens = [],\n      demandTokens = [],\n      receiver = '',\n      memo = '',\n      delegator = '',\n      wallet,\n    },\n    extra\n  ) => {\n    const { token } = await client.getContext();\n    const tokensMap = await client.getTokenStateMap([...offerTokens, ...demandTokens].map((t) => t.address));\n\n    const tmpOfferTokens = offerTokens.map((t) => {\n      t.value = fromTokenToUnit(t.value, tokensMap.get(t.address).decimal).toString();\n      return t;\n    });\n    const tmpDemandTokens = demandTokens.map((t) => {\n      t.value = fromTokenToUnit(t.value, tokensMap.get(t.address).decimal).toString();\n      return t;\n    });\n\n    return client.signExchangeV2Tx(\n      {\n        tx: {\n          itx: {\n            to: receiver,\n            sender: {\n              value: fromTokenToUnit(offerToken, token.decimal),\n              assets: Array.isArray(offerAssets) ? offerAssets : [],\n              tokens: tmpOfferTokens,\n            },\n            receiver: {\n              value: fromTokenToUnit(demandToken, token.decimal),\n              assets: Array.isArray(demandAssets) ? demandAssets : [],\n              tokens: tmpDemandTokens,\n            },\n            data: {\n              typeUrl: 'json',\n              value: memo || 'empty',\n            },\n          },\n        },\n        delegator,\n        wallet,\n      },\n      extra\n    );\n  };\n\n  /**\n   * Finalize an exchange transaction between multiple accounts\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#finalizeExchange\n   * @param {object} params\n   * @param {object} params.tx - the transaction object from `prepareExchange`\n   * @param {string} params.delegator - who authorized this transaction\n   * @param {object} params.data - extra data in the multi sig\n   * @param {WalletObject} params.wallet - the wallet who is the demander\n   * @param {object} extra - other param to underlying client implementation\n   * @returns {Promise} the `transaction` object once resolved\n   */\n  client.finalizeExchange = ({ tx, delegator = '', data, wallet }, extra) =>\n    client.multiSignExchangeV2Tx({ tx, delegator, data, wallet }, extra);\n\n  /**\n   * Send an exchange transaction\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#exchange\n   * @param {object} params\n   * @param {object} params.tx - the transaction object from `finalizeExchange`\n   * @param {WalletObject} params.wallet - the wallet to sign the transaction\n   * @param {object} extra - other param to underlying client implementation\n   * @returns {Promise} the `transactionHash` once resolved\n   */\n  client.exchange = ({ tx, wallet }, extra) => client.sendExchangeV2Tx({ tx, wallet }, extra);\n\n  /**\n   * Create an new token\n   *\n   * @memberof GraphQLClient\n   * @function\n   * @name GraphQLClient#createToken\n   * @param {object} params\n   * @param {string} params.name\n   * @param {string} params.description\n   * @param {string} params.symbol\n   * @param {string} params.unit\n   * @param {string} params.icon\n   * @param {number} params.totalSupply\n   * @param {number} params.initialSupply\n   * @param {number} params.foreignToken\n   * @param {object} params.data - asset data payload\n   * @param {WalletObject} params.wallet - the initial owner of the asset\n   * @param {object} extra - other param to underlying client implementation\n   * @returns {Promise} the `[transactionHash, assetAddress]` once resolved\n   */\n  client.createToken = async (\n    { name, description, symbol, unit, decimal, icon, totalSupply, initialSupply, foreignToken, data, wallet },\n    extra\n  ) => {\n    const tokenDecimal = typeof decimal === 'undefined' ? DEFAULT_TOKEN_DECIMAL : decimal;\n\n    const payload = {\n      name,\n      description,\n      symbol,\n      unit,\n      decimal: tokenDecimal,\n      icon,\n      totalSupply: fromTokenToUnit(totalSupply, tokenDecimal).toString(),\n      initialSupply: fromTokenToUnit(initialSupply || totalSupply, tokenDecimal).toString(),\n      foreignToken: foreignToken || null,\n      data,\n    };\n\n    const address = toTokenAddress(payload);\n    payload.address = address;\n    const hash = await client.sendCreateTokenTx(\n      {\n        tx: { itx: payload },\n        wallet,\n      },\n      extra\n    );\n    return [hash, address];\n  };\n};\n\nmodule.exports = { createExtensionMethods };\n"]}