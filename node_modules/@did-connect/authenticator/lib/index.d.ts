import { JwtBody } from '@arcblock/jwt';
import { WalletObject } from '@ocap/wallet';
import { Promisable } from 'type-fest';
import type { TLocaleCode, TAppInfo, TAppResponse, TChainInfo, TAuthContext, TAnyRequest, TAnyResponse } from '@did-connect/types';
export declare type TWalletInfoFn = (params: TAuthContext) => Promisable<WalletObject>;
export declare type TAppInfoFn = (params: TAuthContext) => Promisable<TAppInfo>;
export declare type TChainInfoFn = (params: TAuthContext) => Promisable<TChainInfo>;
export declare type AuthenticatorOptions = {
    wallet: WalletObject | TWalletInfoFn;
    appInfo: TAppInfo | TAppInfoFn;
    chainInfo?: TChainInfo | TChainInfoFn;
    timeout?: number;
};
export declare type TAppResponseSigned = {
    appPk: string;
    authInfo: string;
};
export declare type WalletResponse = {
    userDid: string;
    userPk: string;
    claims: TAnyResponse[];
    action: string;
    challenge: string;
};
export declare type TWalletResponseSigned = {
    userPk: string;
    userInfo: string;
};
export declare class Authenticator {
    readonly wallet: WalletObject | TWalletInfoFn;
    readonly appInfo: TAppInfo | TAppInfoFn;
    readonly chainInfo: TChainInfo | TChainInfoFn;
    readonly timeout: number;
    /**
     * Creates an instance of DID Authenticator.
     */
    constructor({ wallet, appInfo, chainInfo, timeout }: AuthenticatorOptions);
    /**
     * Sign a plain response, usually on auth success or error
     *
     * @method
     * @param {object} data
     * @param {object} data.response - response
     * @param {string} data.errorMessage - error message, default to empty
     * @param {string} data.successMessage - success message, default to empty
     * @param {string} data.nextWorkflow - https://github.com/ArcBlock/ABT-DID-Protocol#concatenate-multiple-workflow
     * @param {object} context
     * @returns {object} { appPk, authInfo }
     */
    signJson(data: TAppResponse, context: TAuthContext): Promise<TAppResponseSigned>;
    /**
     * Sign a auth response that returned to wallet: tell the wallet the appInfo/chainInfo
     *
     * @method
     * @param {object} claims - info required by application to complete the auth
     * @param {object} context - context
     * @returns {object} { appPk, authInfo }
     */
    signClaims(claims: TAnyRequest[], context: TAuthContext): Promise<TAppResponseSigned>;
    getWalletInfo(params: TAuthContext): Promise<WalletObject>;
    /**
     * Determine appInfo on the fly
     */
    getAppInfo(context: TAuthContext): Promise<TAppInfo>;
    getChainInfo(params: TAuthContext): Promise<TChainInfo>;
    /**
     * Verify a DID connect response sent from DID Wallet
     */
    verify(data: TWalletResponseSigned, locale?: TLocaleCode, enforceTimestamp?: boolean): Promise<WalletResponse>;
    _validateAppInfo(info: TAppInfo | TAppInfoFn): TAppInfo | TAppInfoFn;
    _validateWallet(wallet: WalletObject | TWalletInfoFn): WalletObject | TWalletInfoFn;
    /**
     * Verify a DID auth response sent from DID Wallet
     *
     * @method
     * @param {object} data
     * @param {string} [locale=en]
     * @param {boolean} [enforceTimestamp=true]
     * @returns Promise<boolean>
     */
    _verify(data: TWalletResponseSigned, locale?: TLocaleCode, enforceTimestamp?: boolean): Promise<JwtBody>;
    tryWithTimeout<T>(asyncFn: Function): Promise<T>;
}
