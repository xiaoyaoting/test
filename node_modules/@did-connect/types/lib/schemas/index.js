"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnyResponse = exports.AnyRequest = exports.VerifiableCredentialResponse = exports.VerifiableCredentialRequest = exports.SignatureResponse = exports.SignatureRequest = exports.ProfileResponse = exports.ProfileRequest = exports.PrepareTxResponse = exports.PrepareTxRequest = exports.AuthPrincipalResponse = exports.AuthPrincipalRequest = exports.AssetResponse = exports.AssetRequest = exports.AgreementResponse = exports.AgreementRequest = exports.Session = exports.Context = exports.DIDWalletInfo = exports.ChainInfo = exports.AppInfo = void 0;
const validator_1 = require("@arcblock/validator");
const mcrypto_1 = require("@ocap/mcrypto");
// shared schema options
const options = { stripUnknown: true, noDefaults: false };
const capitalize = (input) => input.charAt(0).toUpperCase() + input.slice(1);
// Basic Types
const ChainInfo = validator_1.Joi.object({
    type: validator_1.Joi.string().optional().valid('arcblock', 'ethereum', 'solona').default('arcblock'),
    id: validator_1.Joi.string()
        .when('type', { is: 'arcblock', then: validator_1.Joi.string().optional().default('none') })
        .when('type', {
        is: 'ethereum',
        then: validator_1.Joi.string()
            .required()
            .pattern(/^[0-9]+$/, 'numbers'),
    })
        .when('type', {
        is: 'solona',
        then: validator_1.Joi.string()
            .required()
            .pattern(/^[0-9]+$/, 'numbers'),
    }),
    host: validator_1.Joi.string().when('id', {
        is: 'none',
        then: validator_1.Joi.string().optional().default('none'),
        otherwise: validator_1.Joi.any()
            .when('type', {
            is: 'arcblock',
            then: validator_1.Joi.string()
                .uri({ scheme: ['http', 'https'] })
                .required(),
        })
            .when('type', { is: 'ethereum', then: validator_1.Joi.string().optional().allow('') })
            .when('type', { is: 'solona', then: validator_1.Joi.string().optional().allow('') }),
    }),
})
    .options(options)
    .meta({ unknownType: 'string', className: 'TChainInfo' });
exports.ChainInfo = ChainInfo;
const AppInfo = validator_1.Joi.object({
    name: validator_1.Joi.string().required(),
    description: validator_1.Joi.string().required(),
    icon: validator_1.Joi.string()
        .uri({ scheme: ['http', 'https'] })
        .required(),
    link: validator_1.Joi.string()
        .uri({ scheme: ['http', 'https'] })
        .required(),
    path: validator_1.Joi.string()
        .uri({ scheme: ['http', 'https'] })
        .default('https://abtwallet.io/i/'),
    publisher: validator_1.Joi.string().optional(),
    updateSubEndpoint: validator_1.Joi.boolean().optional(),
    subscriptionEndpoint: validator_1.Joi.string().optional(),
    nodeDid: validator_1.Joi.DID().optional(),
})
    .options(options)
    .meta({ unknownType: 'string', className: 'TAppInfo' });
exports.AppInfo = AppInfo;
const DIDWalletInfo = validator_1.Joi.object({
    os: validator_1.Joi.string().valid('ios', 'android', 'web').allow('').required(),
    version: validator_1.Joi.string().required().allow(''),
    jwt: validator_1.Joi.string().required(),
})
    .options(options)
    .meta({ unknownType: 'string', className: 'TWalletInfo' });
exports.DIDWalletInfo = DIDWalletInfo;
const createStandardFields = (type, description, isRequest) => {
    if (isRequest) {
        return {
            type: validator_1.Joi.string().valid(type).required(),
            description: validator_1.Joi.string().min(1).required().default(description),
            chainInfo: ChainInfo,
            meta: validator_1.Joi.any().optional().default({}),
        };
    }
    return {
        type: validator_1.Joi.string().valid(type).required(),
        meta: validator_1.Joi.any().optional().default({}),
    };
};
const TrustedIssuer = validator_1.Joi.alternatives().try(validator_1.Joi.object({
    did: validator_1.Joi.DID().required(),
    endpoint: validator_1.Joi.string()
        .uri({ scheme: ['http', 'https'] })
        .required(),
}), validator_1.Joi.DID().required());
const createClaimTypes = (type, description) => {
    const claims = {
        authPrincipal: {
            request: {
                target: validator_1.Joi.DID().optional().allow('').default(''),
                targetType: validator_1.Joi.object({
                    key: validator_1.Joi.string()
                        .valid(...Object.keys(mcrypto_1.types.KeyType).map((x) => x.toLowerCase()))
                        .required(),
                    hash: validator_1.Joi.string()
                        .valid(...Object.keys(mcrypto_1.types.HashType).map((x) => x.toLowerCase()))
                        .required(),
                    role: validator_1.Joi.string()
                        .valid(...Object.keys(mcrypto_1.types.RoleType).map((x) => x.toLowerCase().split('_').pop()))
                        .required(),
                }).optional(),
                declareParams: validator_1.Joi.object({
                    moniker: validator_1.Joi.string().required(),
                    issuer: validator_1.Joi.DID().required(),
                }).optional(),
                supervised: validator_1.Joi.boolean().default(false),
            },
            response: {
                userDid: validator_1.Joi.DID().required(),
                userPk: validator_1.Joi.string().required(),
            },
        },
        profile: {
            request: {
                items: validator_1.Joi.array()
                    .items(validator_1.Joi.string().valid('fullName', 'email', 'phone', 'signature', 'avatar', 'birthday'))
                    .min(1)
                    .default(['fullName']),
            },
            response: {
                fullName: validator_1.Joi.string().optional(),
                email: validator_1.Joi.string().optional(),
                phone: validator_1.Joi.string().optional(),
                avatar: validator_1.Joi.string().optional(),
                signature: validator_1.Joi.string().optional(),
                birthday: validator_1.Joi.string().optional(),
            },
        },
        signature: {
            request: {
                typeUrl: validator_1.Joi.string()
                    .valid('fg:t:transaction', 'mime:text/plain', 'mime:text/html', 'eth:transaction', 'eth:standard-data', 'eth:personal-data', 'eth:typed-data', 'eth:legacy-data')
                    .required(),
                display: validator_1.Joi.string().allow('').default(''),
                method: validator_1.Joi.string()
                    .allow('none', ...Object.keys(mcrypto_1.types.HashType).map((x) => x.toLowerCase()))
                    .optional()
                    .default('sha3'),
                digest: validator_1.Joi.string().allow('').default(''),
                origin: validator_1.Joi.string().allow('').default(''),
            },
            response: {
                sig: validator_1.Joi.string().required(),
            },
        },
        prepareTx: {
            request: {
                display: validator_1.Joi.string().allow('').default(''),
                partialTx: validator_1.Joi.string().required(),
                requirement: validator_1.Joi.object({
                    tokens: validator_1.Joi.array()
                        .items(validator_1.Joi.object({
                        address: validator_1.Joi.DID().required(),
                        value: validator_1.Joi.BN().positive().required(),
                    }))
                        .required(),
                    assets: validator_1.Joi.object({
                        address: validator_1.Joi.array().items(validator_1.Joi.DID()).optional(),
                        parent: validator_1.Joi.array().items(validator_1.Joi.DID()).optional(),
                        issuer: validator_1.Joi.array().items(validator_1.Joi.DID()).optional(),
                    }).optional(),
                }).required(),
            },
            response: {
                finalTx: validator_1.Joi.string().required(),
            },
        },
        agreement: {
            request: {
                uri: validator_1.Joi.string()
                    .uri({ scheme: ['http', 'https'] })
                    .required()
                    .allow(''),
                method: validator_1.Joi.string()
                    .allow(...Object.keys(mcrypto_1.types.HashType).map((x) => x.toLowerCase()))
                    .optional()
                    .default('sha2'),
                digest: validator_1.Joi.string().required(),
            },
            response: {
                agreed: validator_1.Joi.boolean().required(),
                sig: validator_1.Joi.string().optional(),
            },
        },
        verifiableCredential: {
            request: {
                optional: validator_1.Joi.boolean().default(false),
                // v1
                item: validator_1.Joi.array().items(validator_1.Joi.string().min(1).required()).min(1).optional(),
                target: validator_1.Joi.DID().optional(),
                trustedIssuers: validator_1.Joi.array().items(TrustedIssuer).min(1).optional(),
                tag: validator_1.Joi.string().min(1).allow('').default(''),
                // v2
                // - multiple filter should be interpreted as OR
                // - fields inside a filter should be interpreted as AND
                // - values inside a filter field should be interpreted as OR
                filters: validator_1.Joi.array()
                    .items(validator_1.Joi.object({
                    type: validator_1.Joi.array().items(validator_1.Joi.string().min(1).required()).min(1).optional(),
                    target: validator_1.Joi.DID().optional(),
                    trustedIssuers: validator_1.Joi.array().items(TrustedIssuer).min(1).optional(),
                    tag: validator_1.Joi.string().min(1).allow('').default(''),
                }))
                    .optional(),
            },
            response: {
                optional: validator_1.Joi.boolean().default(false),
                assetDid: validator_1.Joi.DID().optional().allow('', 'none').default(''),
                presentation: validator_1.Joi.string().required(),
            },
        },
        asset: {
            request: {
                optional: validator_1.Joi.boolean().default(false),
                // v1
                address: validator_1.Joi.DID().optional(),
                trustedIssuers: validator_1.Joi.array().items(TrustedIssuer).min(1).optional(),
                trustedParents: validator_1.Joi.array().items(validator_1.Joi.DID().required()).min(1).optional(),
                tag: validator_1.Joi.string().min(1).allow('').default(''),
                // v2
                // - multiple filter should be interpreted as OR
                // - fields inside a filter should be interpreted as AND
                // - values inside a filter field should be interpreted as OR
                filters: validator_1.Joi.array()
                    .items(validator_1.Joi.object({
                    address: validator_1.Joi.DID().optional(),
                    trustedIssuers: validator_1.Joi.array().items(TrustedIssuer).min(1).optional(),
                    trustedParents: validator_1.Joi.array().items(validator_1.Joi.DID().required()).min(1).optional(),
                    tag: validator_1.Joi.string().min(1).allow('').default(''),
                }))
                    .optional(),
            },
            response: {
                asset: validator_1.Joi.DID().required(),
                ownerDid: validator_1.Joi.DID().required(),
                ownerPk: validator_1.Joi.string().required(),
                ownerProof: validator_1.Joi.string().required(),
            },
        },
    };
    const request = validator_1.Joi.object(Object.assign(Object.assign({}, createStandardFields(type, description, true)), claims[type].request))
        .options(options)
        .meta({ unknownType: 'string', className: `T${capitalize(type)}Request` });
    const response = validator_1.Joi.object(Object.assign(Object.assign({}, createStandardFields(type, description, false)), claims[type].response))
        .options(options)
        .meta({ unknownType: 'string', className: `T${capitalize(type)}Response` });
    return [request, response];
};
const [AuthPrincipalRequest, AuthPrincipalResponse] = createClaimTypes('authPrincipal', 'Please select account to continue.');
exports.AuthPrincipalRequest = AuthPrincipalRequest;
exports.AuthPrincipalResponse = AuthPrincipalResponse;
const [ProfileRequest, ProfileResponse] = createClaimTypes('profile', 'Please provide your profile to continue.');
exports.ProfileRequest = ProfileRequest;
exports.ProfileResponse = ProfileResponse;
const [SignatureRequest, SignatureResponse] = createClaimTypes('signature', 'Please provide required signature to continue.');
exports.SignatureRequest = SignatureRequest;
exports.SignatureResponse = SignatureResponse;
const [PrepareTxRequest, PrepareTxResponse] = createClaimTypes('prepareTx', 'Please provide the transaction to continue.');
exports.PrepareTxRequest = PrepareTxRequest;
exports.PrepareTxResponse = PrepareTxResponse;
const [AgreementRequest, AgreementResponse] = createClaimTypes('agreement', 'Confirm your agreement to continue.');
exports.AgreementRequest = AgreementRequest;
exports.AgreementResponse = AgreementResponse;
const [VerifiableCredentialRequest, VerifiableCredentialResponse] = createClaimTypes('verifiableCredential', 'Please provide your verifiable credential to continue.');
exports.VerifiableCredentialRequest = VerifiableCredentialRequest;
exports.VerifiableCredentialResponse = VerifiableCredentialResponse;
const [AssetRequest, AssetResponse] = createClaimTypes('asset', 'Please provide your asset to continue.');
exports.AssetRequest = AssetRequest;
exports.AssetResponse = AssetResponse;
// Any claim request
const AnyRequest = validator_1.Joi.alternatives()
    .try(AgreementRequest, AssetRequest, AuthPrincipalRequest, PrepareTxRequest, ProfileRequest, SignatureRequest, VerifiableCredentialRequest)
    .meta({ unknownType: 'string', className: 'TAnyRequest' });
exports.AnyRequest = AnyRequest;
// Any claim request
const AnyResponse = validator_1.Joi.alternatives()
    .try(AgreementResponse, AssetResponse, AuthPrincipalResponse, PrepareTxResponse, ProfileResponse, SignatureResponse, VerifiableCredentialResponse)
    .meta({ unknownType: 'string', className: 'TAnyResponse' });
exports.AnyResponse = AnyResponse;
const PreviousConnected = validator_1.Joi.object({
    userDid: validator_1.Joi.DID().required(),
    userPk: validator_1.Joi.string().required(),
    didwallet: validator_1.Joi.string().valid('ios', 'android', 'web').allow('').required(),
})
    .optional()
    .allow(null);
// DID Connect session storage
const Session = validator_1.Joi.object({
    sessionId: validator_1.Joi.string().required(),
    status: validator_1.Joi.string()
        .valid('created', 'walletScanned', 'walletConnected', 'appConnected', 'walletApproved', 'appApproved', 'error', 'timeout', 'rejected', 'canceled', 'completed')
        .required(),
    updaterPk: validator_1.Joi.string().required(),
    strategy: validator_1.Joi.alternatives().try(validator_1.Joi.DID(), validator_1.Joi.string().valid('default', 'smart')).required(),
    authUrl: validator_1.Joi.string()
        .uri({ scheme: ['http', 'https'] })
        .required(),
    challenge: validator_1.Joi.string().required(),
    appInfo: AppInfo.required(),
    onlyConnect: validator_1.Joi.boolean().default(false).required(),
    autoConnect: validator_1.Joi.boolean().default(true).required(),
    forceConnected: validator_1.Joi.boolean().default(true).required(),
    withinSession: validator_1.Joi.boolean().default(false).required(),
    previousConnected: PreviousConnected,
    currentConnected: validator_1.Joi.object({
        userDid: validator_1.Joi.DID().required(),
        userPk: validator_1.Joi.string().required(),
        didwallet: DIDWalletInfo.required(),
    })
        .optional()
        .allow(null),
    currentStep: validator_1.Joi.number().integer().min(0).default(0).required(),
    // User can set claims in following format
    // requestedClaims: [[claim1], [claim2, claim3], [claim4]]
    requestedClaims: validator_1.Joi.array().items(validator_1.Joi.array().items(AnyRequest).min(1)).default([]).required(),
    // Always a 2 dimension array
    responseClaims: validator_1.Joi.array().items(validator_1.Joi.array().items(AnyResponse).min(1)).default([]).required(),
    // Always a flat array
    approveResults: validator_1.Joi.array().items(validator_1.Joi.any()).default([]).required(),
    error: validator_1.Joi.string().optional().allow(''),
    timeout: validator_1.Joi.object({
        app: validator_1.Joi.number().positive().required(),
        relay: validator_1.Joi.number().positive().required(),
        wallet: validator_1.Joi.number().positive().required(),
    })
        .default({
        app: 10000,
        relay: 10000,
        wallet: 60000,
    })
        .required(),
    // When we need to fetch requestedClaims from another source
    connectUrl: validator_1.Joi.string()
        .uri({ scheme: ['http', 'https'] })
        .optional()
        .allow(''),
    // When we need to fetch approve results from another source
    approveUrl: validator_1.Joi.string()
        .uri({ scheme: ['http', 'https'] })
        .optional()
        .allow(''),
})
    .options(options)
    .meta({ unknownType: 'string', className: 'TSession' });
exports.Session = Session;
// DID Connect handler context
const Context = validator_1.Joi.object({
    didwallet: DIDWalletInfo.required(),
    body: validator_1.Joi.object().required(),
    headers: validator_1.Joi.object().required(),
    sessionId: validator_1.Joi.string().max(21).min(21).required().allow(''),
    session: Session.required().allow(null),
    locale: validator_1.Joi.string().required().default('en'),
    signerPk: validator_1.Joi.string().required().allow(''),
    signerToken: validator_1.Joi.string().required().allow(''),
    previousConnected: PreviousConnected,
})
    .options(options)
    .meta({ unknownType: 'string', className: 'TContext' });
exports.Context = Context;
