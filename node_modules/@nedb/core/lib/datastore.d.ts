/// <reference types="node" />
import EventEmitter from 'events';
declare const Executor: any;
declare const Persistence: any;
import { Cursor } from './cursor';
import { DataStoreOptions, CallbackOptionalError, CallbackWithResult, IndexOptions, FilterQuery, ProjectionQuery, UpdateOptions, UpdateQuery, UpdateResult, RemoveOptions, Row, AnyObject } from './types';
/**
 * Create a new collection
 * @param {String} options.filename Optional, datastore will be in-memory only if not provided
 * @param {Boolean} options.timestampData Optional, defaults to false. If set to true, createdAt and updatedAt will be created and populated automatically (if not specified by user)
 * @param {Boolean} options.inMemoryOnly Optional, defaults to false
 * @param {String} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where
 *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)
 * @param {Boolean} options.autoload Optional, defaults to false
 * @param {Function} options.onload Optional, if autoload is used this will be called after the load database with the error object as parameter. If you don't pass it the error will be thrown
 * @param {Function} options.afterSerialization/options.beforeDeserialization Optional, serialization hooks
 * @param {Number} options.corruptAlertThreshold Optional, threshold after which an alert is thrown if too much data is corrupt
 * @param {Function} options.compareStrings Optional, string comparison function that overrides default for sorting
 *
 * Event Emitter - Events
 * * compaction.done - Fired whenever a compaction operation was finished
 */
export declare class DataStore<T = AnyObject> extends EventEmitter {
    readonly inMemoryOnly: boolean;
    readonly autoload: boolean;
    readonly timestampData: boolean;
    readonly filename: string;
    private readonly compareStrings;
    private readonly indexes;
    private readonly ttlIndexes;
    readonly persistence: typeof Persistence;
    readonly executor: typeof Executor;
    constructor(options?: DataStoreOptions);
    /**
     * Load the database from the datafile, and trigger the execution of buffered commands if any
     */
    loadDatabase(): PromiseLike<void>;
    loadDatabase(cb: CallbackOptionalError): void;
    /**
     * Close the database and its underlying datafile.
     */
    closeDatabase(): PromiseLike<void>;
    closeDatabase(cb: CallbackOptionalError): void;
    /**
     * Get an array of all the data in the database
     */
    getAllData(): T[];
    forEach(cb: any): any;
    /**
     * Reset all currently defined indexes
     */
    resetIndexes(newData: any): void;
    /**
     * Ensure an index is kept for this field. Same parameters as lib/indexes
     * For now this function is synchronous, we need to test how much time it takes
     * We use an async API for consistency with the rest of the code
     * @param {String} options.fieldName
     * @param {Boolean} options.unique
     * @param {Boolean} options.sparse
     * @param {Number} options.expireAfterSeconds - Optional, if set this index becomes a TTL index (only works on Date fields, not arrays of Date)
     * @param {Function} cb Optional callback, signature: err
     */
    ensureIndex(options: IndexOptions, cb?: CallbackOptionalError): Promise<void>;
    /**
     * Remove an index
     * @param {String} fieldName
     * @param {Function} cb Optional callback, signature: err
     */
    removeIndex(fieldName: string, cb?: CallbackOptionalError): Promise<void>;
    /**
     * Add one or several document(s) to all indexes
     */
    private addToIndexes;
    /**
     * Remove one or several document(s) from all indexes
     */
    private removeFromIndexes;
    /**
     * Update one or several documents in all indexes
     * To update multiple documents, oldDoc must be an array of { oldDoc, newDoc } pairs
     * If one update violates a constraint, all changes are rolled back
     */
    private updateIndexes;
    private getIndex;
    /**
     * Return the list of candidates for a given query
     * Crude implementation for now, we return the candidates given by the first usable index if any
     * We try the following query types, in this order: basic match, $in match, comparison match
     * One way to make it better would be to enable the use of multiple indexes if the first usable index
     * returns too much data. I may do it in the future.
     *
     * Returned candidates will be scanned to find and remove all expired documents
     *
     * @param {Query} query
     * @param {Boolean} dontExpireStaleDocs Optional, defaults to false, if true don't remove stale docs. Useful for the remove function which shouldn't be impacted by expirations
     * @param {Function} callback Signature err, candidates
     */
    getCandidates(query: FilterQuery<T>, callback: CallbackWithResult<Row<T>[]>): void;
    getCandidates(query: FilterQuery<T>, dontExpireStaleDocs: boolean, callback: CallbackWithResult<Row<T>[]>): void;
    /**
     * Insert a new document
     * @param {Function} cb Optional callback, signature: err, insertedDoc
     */
    private _insert;
    /**
     * Create a new _id that's not already in use
     */
    createNewId(): string;
    /**
     * Prepare a document (or array of documents) to be inserted in a database
     * Meaning adds _id and timestamps if necessary on a copy of newDoc to avoid any side effect on user input
     */
    prepareDocumentForInsertion(newDoc: T): Row<T>;
    prepareDocumentForInsertion(newDoc: T[]): Row<T>[];
    /**
     * If newDoc is an array of documents, this will insert all documents in the cache
     */
    private _insertInCache;
    /**
     * If one insertion fails (e.g. because of a unique constraint), roll back all previous
     * inserts and throws the error
     */
    private _insertMultipleDocsInCache;
    insert(doc: T): PromiseLike<Row<T>>;
    insert(doc: T[]): PromiseLike<Row<T>[]>;
    insert(doc: T, cb: CallbackWithResult<Row<T>>): void;
    insert(doc: T[], cb: CallbackWithResult<Row<T>[]>): void;
    /**
     * Return a cursor and support a chained api style
     */
    cursor(query?: FilterQuery<T>): Cursor<T>;
    /**
     * Count all documents matching the query
     * @param {Object} query FIXME: MongoDB-style query
     */
    count(query?: FilterQuery<T>): PromiseLike<number>;
    count(query: FilterQuery<T>, callback: CallbackWithResult<number>): void;
    count(callback: CallbackWithResult<number>): void;
    /**
     * Find all documents matching the query
     * If no callback is passed, we return the cursor so that user can limit, skip and finally exec
     * @param {Object} query FIXME: MongoDB-style query
     * @param {Object} projection MongoDB-style projection
     */
    find(query?: FilterQuery<T>): PromiseLike<Row<T>[]>;
    find(query: FilterQuery<T>, projection: ProjectionQuery<T>): PromiseLike<Row<T>[]>;
    find(callback: CallbackWithResult<Row<T>[]>): void;
    find(query: FilterQuery<T>, callback: CallbackWithResult<Row<T>[]>): void;
    find(query: FilterQuery<T>, projection: ProjectionQuery<T>, callback: CallbackWithResult<Row<T>[]>): void;
    /**
     * Find one document matching the query
     * @param {Object} query FIXME: MongoDB-style query
     * @param {Object} projection MongoDB-style projection
     */
    findOne(query?: FilterQuery<T>): PromiseLike<Row<T>>;
    findOne(query: FilterQuery<T>, projection?: ProjectionQuery<T>): PromiseLike<Row<T>>;
    findOne(query: FilterQuery<T>, callback?: CallbackWithResult<Row<T>>): void;
    findOne(query: FilterQuery<T>, projection: ProjectionQuery<T>, callback: CallbackWithResult<Row<T>>): void;
    /**
     * Update all docs matching query
     * @param {Object} query
     * @param {Object} updateQuery
     * @param {Object} options Optional options
     *                 options.multi If true, can update multiple documents (defaults to false)
     *                 options.upsert If true, document is inserted if the query doesn't match anything
     *                 options.returnUpdatedDocs Defaults to false, if true return as third argument the array of updated matched documents (even if no change actually took place)
     * @param {Function} cb Optional callback, signature: (err, numAffected, affectedDocuments, upsert)
     *                      If update was an upsert, upsert flag is set to true
     *                      affectedDocuments can be one of the following:
     *                        * For an upsert, the upserted document
     *                        * For an update with returnUpdatedDocs option false, null
     *                        * For an update with returnUpdatedDocs true and multi false, the updated document
     *                        * For an update with returnUpdatedDocs true and multi true, the array of updated documents
     *
     * WARNING: The API was changed between v1.7.4 and v1.8, for consistency and readability reasons. Prior and including to v1.7.4,
     *          the callback signature was (err, numAffected, updated) where updated was the updated document in case of an upsert
     *          or the array of updated documents for an update if the returnUpdatedDocs option was true. That meant that the type of
     *          affectedDocuments in a non multi update depended on whether there was an upsert or not, leaving only two ways for the
     *          user to check whether an upsert had occured: checking the type of affectedDocuments or running another find query on
     *          the whole dataset to check its size. Both options being ugly, the breaking change was necessary.
     */
    private _update;
    update(query: FilterQuery<T>, updateQuery: UpdateQuery<T>): PromiseLike<UpdateResult<T>>;
    update(query: FilterQuery<T>, updateQuery: UpdateQuery<T>, cb: CallbackWithResult<any>): void;
    update(query: FilterQuery<T>, updateQuery: UpdateQuery<T>, options: UpdateOptions): PromiseLike<UpdateResult<T>>;
    update(query: FilterQuery<T>, updateQuery: UpdateQuery<T>, options: UpdateOptions, cb: CallbackWithResult<any>): void;
    /**
     * Remove all docs matching the query
     * For now very naive implementation (similar to update)
     * @param {Object} query
     * @param {Object} options Optional options
     *                 options.multi If true, can remove multiple documents (defaults to false)
     * @param {Function} cb Optional callback, signature: err, numRemoved
     */
    private _remove;
    remove(query: FilterQuery<T>): PromiseLike<number>;
    remove(query: FilterQuery<T>, options: RemoveOptions): PromiseLike<number>;
    remove(query: FilterQuery<T>, cb: CallbackWithResult<number>): void;
    remove(query: FilterQuery<T>, options: RemoveOptions, cb: CallbackWithResult<number>): void;
    /**
     * Supports both promise and callback functions for a public API
     *
     * @private
     * @template T
     * @param {object} context
     * @param {Function} fn
     * @param {any[]} args
     * @return {*}  {PromiseLike<T>}
     * @memberof DataStore
     */
    private _promiseAsCallback;
    private _cursorAsCallback;
}
export {};
