export declare class NativeError extends Error {
}
export declare type CallbackError = NativeError | null;
export declare type CallbackWithResult<T = any> = (error: CallbackError, result?: T) => void;
export declare type CallbackWithError = (error: CallbackError) => void;
export declare type CallbackOptionalError = (error?: CallbackError) => void;
export declare type DataStoreOptions = {
    filename?: string;
    inMemoryOnly?: boolean;
    autoload?: boolean;
    timestampData?: boolean;
    onload?: CallbackOptionalError;
    beforeDeserialization?: any;
    afterSerialization?: any;
    compareStrings?: any;
    corruptAlertThreshold?: any;
    nodeWebkitAppName?: string;
};
export declare type IndexOptions = {
    fieldName: string;
    unique?: boolean;
    sparse?: boolean;
    hash?: boolean;
    expireAfterSeconds?: number;
};
export declare type AnyObject = {
    [key: string]: any;
};
export declare type Row<T> = {
    _id?: string;
    createdAt?: string;
    updatedAt?: string;
} & T;
export declare type LiteralUnion<LiteralType, BaseType> = LiteralType | (BaseType & Record<never, never>);
export declare type ApplyBasicQueryCasting<T> = T | T[] | (T extends (infer U)[] ? U : any) | any;
export declare type Condition<T> = ApplyBasicQueryCasting<T> | QuerySelector<ApplyBasicQueryCasting<T>>;
export declare type UpdateOptions = {
    multi?: boolean;
    upsert?: boolean;
    returnUpdatedDocs?: boolean;
};
export declare type UpdateResult<T> = [number, Row<T>[], boolean];
export declare type UpdateQuery<T> = {
    $set?: {
        [P in keyof T]?: any;
    };
    $unset?: {
        [P in keyof T]?: true;
    };
    $inc?: {
        [P in keyof T]?: number;
    };
    $push?: {
        [P in keyof T]?: any;
    };
    $pop?: {
        [P in keyof T]?: SortFlag;
    };
    [key: string]: any;
};
export declare type SortFlag = LiteralUnion<1 | -1, number>;
export declare type SortQuery<T> = {
    [P in keyof T]?: SortFlag;
};
export declare type ProjectionFlag = LiteralUnion<1 | 0, number>;
export declare type ProjectionQuery<T> = {
    [P in keyof T]?: ProjectionFlag;
} & Record<string, ProjectionFlag>;
export declare type RemoveOptions = {
    multi?: boolean;
};
export declare type FilterQuery<T> = {
    [P in keyof T]?: Condition<T[P]>;
} & RootQuerySelector<T>;
export declare type QuerySelector<T> = {
    $lt?: T;
    $lte?: T;
    $gt?: T;
    $gte?: T;
    $in?: T[];
    $nin?: T[];
    $ne?: T;
    $exists?: boolean;
    $regex?: T extends string ? RegExp | string : never;
    $size?: T extends any[] ? number : never;
    $elemMatch?: T extends any[] ? object : never;
};
export declare type RootQuerySelector<T> = {
    $and?: Array<FilterQuery<T>>;
    $or?: Array<FilterQuery<T>>;
    $not?: Array<FilterQuery<T>>;
    $where?: Function;
    [key: string]: any;
};
