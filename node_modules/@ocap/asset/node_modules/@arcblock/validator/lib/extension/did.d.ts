import { Root, StringSchema } from 'joi';
import { KeyType, HashType, RoleType } from '@ocap/mcrypto';
import { DIDTypeShortcut } from '@arcblock/did';
export interface DIDSchema extends StringSchema {
    wallet(type: DIDTypeShortcut): this;
    pk(type: KeyType): this;
    hash(type: HashType): this;
    role(type: RoleType): this;
    prefix(str?: string): this;
}
export declare function DIDExtension(root: Root): {
    type: string;
    base: StringSchema<string>;
    messages: {
        'did.empty': string;
        'did.invalid': string;
        'did.wallet': string;
        'did.pk': string;
        'did.hash': string;
        'did.role': string;
        'did.prefix': string;
    };
    validate(value: any, helpers: any): {
        errors: any;
        value?: undefined;
    } | {
        value: string;
        errors?: undefined;
    };
    rules: {
        type: {
            args: ({
                name: string;
                ref: boolean;
                assert: (v: string) => boolean;
                message: string;
            } | {
                name: string;
                assert: (v: string) => boolean;
                message: string;
                ref?: undefined;
            })[];
            validate(value: string, helpers: any, args: any): any;
        };
        pk: {
            method(type: KeyType): DIDSchema;
        };
        hash: {
            method(type: HashType): DIDSchema;
        };
        role: {
            method(type: RoleType): DIDSchema;
        };
        wallet: {
            method(type: DIDTypeShortcut): DIDSchema;
            args: {
                name: string;
                ref: boolean;
                assert: (v: any) => boolean;
                message: string;
                normalize: (v: any) => any;
            }[];
            validate(value: any, helpers: any, args?: any): any;
        };
        prefix: {
            method(str?: string): DIDSchema;
            args: {
                name: string;
                ref: boolean;
                assert: (v: any) => boolean;
                message: string;
                normalize: (v: any) => any;
            }[];
            validate(value: any, helpers: any, args?: any): any;
        };
    };
};
