"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toDelegateAddress = exports.toStakeAddress = exports.toRollupAddress = exports.toTokenAddress = exports.toFactoryAddress = exports.toAssetAddress = exports.toItxAddress = void 0;
const mcrypto_1 = require("@ocap/mcrypto");
const did_1 = require("@arcblock/did");
const message_1 = require("@ocap/message");
// @ts-ignore FIXME:
const proto_1 = require("@ocap/proto");
/**
 * Create an itx address
 */
function toItxAddress(itx, type, role = mcrypto_1.types.RoleType.ROLE_TX) {
    if (proto_1.transactions.indexOf(type) === -1) {
        throw new Error(`Unsupported itx type ${type}`);
    }
    const message = (0, message_1.createMessage)(type, itx);
    // @ts-ignore FIXME:
    const itxBytes = message.serializeBinary();
    const hash = mcrypto_1.Hasher.SHA3.hash256(itxBytes);
    const address = (0, did_1.fromHash)(hash, role);
    return address;
}
exports.toItxAddress = toItxAddress;
/**
 * Create an asset address
 */
function toAssetAddress(itx) {
    return toItxAddress(itx, 'CreateAssetTx', mcrypto_1.types.RoleType.ROLE_ASSET);
}
exports.toAssetAddress = toAssetAddress;
/**
 * Create an asset factory address
 */
function toFactoryAddress(itx) {
    return toItxAddress(itx, 'CreateFactoryTx', mcrypto_1.types.RoleType.ROLE_FACTORY);
}
exports.toFactoryAddress = toFactoryAddress;
/**
 * Create an token address
 */
function toTokenAddress(itx) {
    return toItxAddress(itx, 'CreateTokenTx', mcrypto_1.types.RoleType.ROLE_TOKEN);
}
exports.toTokenAddress = toTokenAddress;
/**
 * Create an rollup address
 */
function toRollupAddress(itx) {
    return toItxAddress(itx, 'CreateRollupTx', mcrypto_1.types.RoleType.ROLE_ROLLUP);
}
exports.toRollupAddress = toRollupAddress;
/**
 * Generate an stake address, eg: the did of the stake
 */
function toStakeAddress(sender, receiver) {
    const buffer = Buffer.concat([Buffer.from(sender), Buffer.from(receiver)]);
    const hash = mcrypto_1.Hasher.SHA3.hash256(buffer);
    return (0, did_1.fromHash)(hash, mcrypto_1.types.RoleType.ROLE_STAKE);
}
exports.toStakeAddress = toStakeAddress;
/**
 * Generate an delegate address, eg: the did of the delegation
 */
function toDelegateAddress(delegator, delegatee) {
    const buffer = Buffer.concat([Buffer.from(delegator), Buffer.from(delegatee)]);
    const hash = mcrypto_1.Hasher.SHA3.hash256(buffer);
    return (0, did_1.fromHash)(hash, mcrypto_1.types.RoleType.ROLE_DELEGATION);
}
exports.toDelegateAddress = toDelegateAddress;
