const EventEmitter = require('events');
const cluster = require('cluster');

const { nanoid } = require('nanoid');
const get = require('lodash/get');
const WebSocket = require('ws');
const eventHub = cluster.isMaster ? require('@arcblock/event-hub/single') : require('@arcblock/event-hub');

const createLogger = require('../logger');

const sleep = (timeout) =>
  new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });

const reply = (socket, topic, event, response, status = 'ok') => {
  if (socket.readyState === WebSocket.OPEN) {
    const res = JSON.stringify([socket.joinRef, socket.ref, topic, event, { status, response }]);
    socket.send(res);
  }
};

const noop = () => {};
const defaultHooks = {
  authenticateJoinChannel: noop,
  preJoinChannel: noop,
  postJoinChannel: noop,
  preLeaveChannel: noop,
  postLeaveChannel: noop,
  postBroadcast: noop,
  postSend: noop,
  receiveMessage: noop,
};

const refreshHeartbeat = (socket) => {
  socket.heartbeatAt = Date.now();
};

const HEARTBEAT_TIMEOUT = 60 * 1000;

/**
 * Create a websocket server
 *
 * @param {Object} opts
 * @param {String} opts.pathname - which path to mount the socket server
 * @param {Object} opts.authenticate - authentication function to be called on connection
 * @param {Object} opts.hooks - hooks to be called on events
 * @param {Object} opts.logger - logger used to log messages
 * @param {Object} opts.broadcastEventName - used in cluster mode, default is '@arcblock/ws:broadcast'
 * @param {Object} opts.heartbeatTimeout - maximum non-response time of a connection socket
 * @class WsServer
 * @extends {EventEmitter}
 */
class WsServer extends EventEmitter {
  constructor(opts = {}) {
    super();
    this.pathname = opts.pathname;
    this.authenticate = opts.authenticate || null;
    this.hooks = Object.assign({}, defaultHooks, opts.hooks || {});
    this.logger = opts.logger || createLogger('server', opts.silent);
    this.heartbeatTimeout = opts.heartbeatTimeout || HEARTBEAT_TIMEOUT;

    this.wss = new WebSocket.Server({ noServer: true, clientTracking: false });
    this.wss.on('connection', this.onWssConnection.bind(this));
    this.wss.on('close', this.onWssClose.bind(this));
    this.wss.on('error', this.onWssError.bind(this));

    this.topics = {}; // <topic>: Set<socket>

    this.broadcastEventName = opts.broadcastEventName || '@arcblock/ws:broadcast';
    eventHub.on(this.broadcastEventName, (data) => this._doBroadCast(data));
  }

  attach(server) {
    server.on('upgrade', this.onConnect.bind(this));
  }

  onConnect(request, socket, head) {
    const { pathname } = new URL(request.url, `http://${request.headers.host || 'unknown'}`);
    this.logger.debug('connect attempt', { pathname });
    if (this.pathname && pathname !== this.pathname) {
      socket.write('HTTP/1.1 404 Pathname mismatch\r\n\r\n');
      socket.destroy();
      return;
    }

    if (!this.authenticate) {
      this.wss.handleUpgrade(request, socket, head, (ws) => {
        this.wss.emit('connection', ws, request);
      });
      return;
    }

    this.authenticate(request, (err, authInfo) => {
      if (err) {
        socket.write('HTTP/1.1 401 Unauthorized\r\n\r\n');
        socket.destroy();
        return;
      }
      this.wss.handleUpgrade(request, socket, head, (ws) => {
        ws.authInfo = authInfo;
        this.wss.emit('connection', ws, request);
      });
    });
  }

  /**
   * Broadcast message to all subscribers of a topic, can be used as
   * - broadcast(event, data)
   * - broadcast(topic, event, data)
   * - broadcast(topic, event, data, options)
   */
  async broadcast(...args) {
    let topic;
    let event;
    let data;
    let options = {};
    let cb = () => {};

    if (typeof args[args.length - 1] === 'function') {
      cb = args.pop();
    }

    if (args.length < 2) {
      throw new Error('Broadcasting requires at least 2 arguments');
    }
    if (args.length === 2) {
      [event, data] = args;
      topic = event;
    } else if (args.length === 3) {
      [topic, event, data] = args;
    } else {
      [topic, event, data, options] = args;
    }

    const enableLog = options.enableLog !== undefined ? !!options.enableLog : true;
    const { socketFilters, noCluster } = options;
    const replyId = nanoid();

    // Count of clients what will receive the message
    // The count is NOT reliable
    let count = 0;

    if (noCluster) {
      const { count: c } = this._doBroadCast({ topic, event, data, enableLog, socketFilters });
      count = c;
    } else {
      eventHub.on(replyId, ({ count: c } = {}) => {
        if (c) {
          count += c;
        }
      });

      eventHub.broadcast(this.broadcastEventName, { topic, event, data, options, enableLog, replyId, socketFilters });

      // wait 600ms for message sending by each process
      await sleep(600);
      eventHub.off(replyId);
    }

    const opts = { count, topic, event, data, options };
    cb(opts);
    try {
      await this.hooks.postBroadcast(opts);
    } catch (error) {
      this.logger.error('postBroadcast error', { error });
    }
  }

  async _doBroadCast({ topic, event, data, enableLog, replyId, socketFilters } = {}) {
    try {
      let count = 0;

      if (this.topics[topic] && this.topics[topic].size) {
        let conditions = null;
        if (socketFilters && Object.keys(socketFilters).length) {
          conditions = Object.entries(socketFilters);
        }

        this.topics[topic].forEach((socket) => {
          const noHeartbeatTime = Date.now() - socket.heartbeatAt;
          if (noHeartbeatTime > this.heartbeatTimeout) {
            this.logger.error(`Socket has no heartbeat within ${Math.floor(noHeartbeatTime / 1000)} seconds`, {
              topic,
              id: socket.id,
            });
            this.topics[topic].delete(socket);
            return;
          }

          if (conditions && !conditions.every(([key, value]) => get(socket, key) === value)) {
            return;
          }

          count++;
          if (enableLog) {
            this.logger.info('broadcast message to', { topic, event, id: socket.id });
          }
          reply(socket, topic, event, data);
        });
      }

      if (count === 0 && enableLog) {
        this.logger.info('no connections when broadcast message', { topic, event });
      }

      if (count > 0 && replyId) {
        eventHub.broadcast(replyId, { count });
      }

      return { count };
    } catch (error) {
      this.logger.error('_doBroadcast error', { error });
      return { error };
    }
  }

  /**
   * Send message to 1 subscriber of a topic, can be used as
   * - send(socket, event, data)
   * - send(socket, topic, event, data)
   * - send(socket, topic, event, data, options)
   */
  async send(...args) {
    let socket;
    let topic;
    let event;
    let data;
    let options = {};

    if (args.length < 3) {
      throw new Error('send requires at least 3 arguments');
    }
    if (args.length === 3) {
      [socket, event, data] = args;
      topic = event;
    } else if (args.length === 4) {
      [socket, topic, event, data] = args;
    } else {
      [socket, topic, event, data, options] = args;
    }

    const opts = { enableLog: true, ...options };
    if (!socket) {
      this.logger.error('socket does not exist');
      return;
    }

    if (opts.enableLog) {
      this.logger.info('send message to', { topic, event, id: socket.id });
    }

    reply(socket, topic, event, data);

    try {
      await this.hooks.postSend({ topic, event, data, options });
    } catch (error) {
      this.logger.error('postSend error', { error });
    }
  }

  /**
   * private
   */
  async onWssConnection(socket) {
    socket.id = nanoid();
    socket.channel = {};

    refreshHeartbeat(socket);
    this.logger.debug('socket connected', { id: socket.id });

    socket.on('message', async (msg) => {
      this.logger.debug('socket onmessage', { msg });
      let joinRef;
      let ref;
      let topic;
      let event;
      let payload;
      try {
        [joinRef, ref, topic, event, payload] = JSON.parse(msg);
      } catch (err) {
        this.logger.error('parse socket message error', { id: socket.id, error: err });
        return;
      }

      if (!topic || !event) {
        this.logger.warn('Invalid message format, topic/event fields are required');
        return;
      }

      socket.joinRef = joinRef;
      socket.ref = ref;

      if (topic === 'phoenix' && event === 'heartbeat') {
        // heartbeat
        reply(socket, topic, event);
        refreshHeartbeat(socket);
        return;
      }

      if (event === 'phx_join') {
        // pre hook
        try {
          const authInfo = await this.hooks.authenticateJoinChannel({ socket, joinRef, ref, topic, event, payload });
          await this.hooks.preJoinChannel({ socket, joinRef, ref, topic, event, payload });

          socket.channel[topic] = {};
          socket.channel[topic].authInfo = authInfo;
        } catch (error) {
          this.logger.error('preJoinChannel error', { error });
          reply(socket, topic, `chan_reply_${ref}`, { message: error.message }, 'error');
          return;
        }

        // join
        if (!this.topics[topic]) {
          this.topics[topic] = new Set();
        }
        this.topics[topic].add(socket);

        reply(socket, topic, `chan_reply_${ref}`);
        this.emit('channel.join', { socket, topic, event, payload });

        // post hook
        try {
          await this.hooks.postJoinChannel({ socket, joinRef, ref, topic, event, payload });
        } catch (error) {
          this.logger.error('postJoinChannel error', { error });
        }

        return;
      }

      if (event === 'phx_leave') {
        // pre hook
        try {
          await this.hooks.preLeaveChannel({ socket, joinRef, ref, topic, event, payload });
        } catch (error) {
          this.logger.error('preLeaveChannel error', { error });
          reply(socket, topic, `chan_reply_${ref}`, { message: error.message }, 'error');
          return;
        }

        // leave
        this._leaveChannel(socket, topic);
        reply(socket, topic, `chan_reply_${ref}`);

        // post hook
        try {
          await this.hooks.postLeaveChannel({ socket, joinRef, ref, topic, event, payload });
        } catch (error) {
          this.logger.error('postLeaveChannel error', { error });
        }

        return;
      }

      // pre hook
      try {
        await this.hooks.receiveMessage({ socket, joinRef, ref, topic, event, payload });
      } catch (error) {
        this.logger.error('receiveMessage error', { error });
        reply(socket, topic, `chan_reply_${ref}`, { message: error.message }, 'error');
        return;
      }

      reply(socket, topic, `chan_reply_${ref}`, {});
    });

    socket.on('close', () => {
      this.logger.debug('socket onclose', { id: socket.id });

      Object.keys(this.topics).forEach((topic) => this._leaveChannel(socket, topic));
    });

    socket.on('error', (err) => {
      this.logger.error('socket onerror', { id: socket.id, error: err });
      Object.keys(this.topics).forEach((topic) => this._leaveChannel(socket, topic));
    });
  }

  /**
   * private
   */
  onWssClose() {
    this.logger.debug('ws server onclose');
    this.emit('close');
  }

  /**
   * private
   */
  onWssError(error) {
    this.logger.error('ws server error', { error });
    this.emit('error', error);
  }

  _leaveChannel(socket, topic) {
    // unsubscribe
    if (this.topics[topic]) {
      this.topics[topic].delete(socket);
    }

    this.emit('channel.leave', { socket, topic });
    if (!this.topics[topic] || !this.topics[topic].size) {
      this.emit('channel.destroy', { socket, topic });
    }
  }
}

module.exports = WsServer;
