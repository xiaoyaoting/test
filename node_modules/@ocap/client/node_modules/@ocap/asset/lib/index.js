"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatFactoryState = exports.preMintFromFactory = exports.mintFromFactory = exports.findPrerenderKeys = exports.isValidFactory = exports.isValidHook = exports.isValidNotation = void 0;
/* eslint-disable @typescript-eslint/ban-ts-comment */
const get_1 = __importDefault(require("lodash/get"));
const set_1 = __importDefault(require("lodash/set"));
const uniq_1 = __importDefault(require("lodash/uniq"));
const uniqBy_1 = __importDefault(require("lodash/uniqBy"));
const isEmpty_1 = __importDefault(require("lodash/isEmpty"));
const flat_1 = __importDefault(require("flat"));
const mustache_1 = __importDefault(require("mustache"));
const is_absolute_url_1 = __importDefault(require("is-absolute-url"));
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const did_1 = require("@arcblock/did");
const vc_1 = require("@arcblock/vc");
const validator_1 = require("@arcblock/validator");
const did_util_1 = require("@arcblock/did-util");
const mcrypto_1 = require("@ocap/mcrypto");
const util_1 = require("@ocap/util");
const contract_1 = require("@ocap/contract");
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)('@ocap/asset');
const SUPPORTED_HOOK_NAMES = ['preMint', 'mint', 'postMint'];
const SUPPORTED_HOOK_TYPES = ['contract', 'url'];
const isValidNotation = (notation) => ['ctx', 'data', 'input'].includes(notation.split('.').shift());
exports.isValidNotation = isValidNotation;
const isValidHook = (hook, quota, throwOnError = false) => {
    if (SUPPORTED_HOOK_TYPES.includes(hook.type) === false) {
        return false;
    }
    if (SUPPORTED_HOOK_NAMES.includes(hook.name) === false) {
        return false;
    }
    if (hook.type === 'url') {
        return (0, is_absolute_url_1.default)(hook.hook);
    }
    if (hook.type === 'contract') {
        try {
            const compiled = (0, contract_1.compile)(hook.hook);
            (0, contract_1.validate)(compiled, quota);
            return true;
        }
        catch (err) {
            if (process.env.NODE_ENV !== 'test') {
                console.error('invalid contract hook', err.message);
            }
            if (throwOnError) {
                throw new Error(`Factory hook ${hook.name} is invalid: ${err.message}`);
            }
            return false;
        }
    }
    return false;
};
exports.isValidHook = isValidHook;
// @link https://github.com/improbable-eng/ts-protoc-gen
const isValidFactory = (props) => {
    if (!props) {
        throw new Error('Factory props should not be empty');
    }
    const { value, error } = validator_1.schemas.factorySchema.validate(props);
    if (error) {
        throw new Error(`Invalid factory: ${error.details.map((x) => x.message).join(', ')}`);
    }
    // input.tokens and input.assets should not be empty
    if (['tokens', 'assets'].every((x) => (0, isEmpty_1.default)(value.input[x])) && value.input.value <= 0) {
        throw new Error('Factory input should contain at least one token or asset');
    }
    if ((0, uniqBy_1.default)(value.input.tokens, 'address').length !== value.input.tokens.length) {
        throw new Error('Factory token input should not contains duplicate address');
    }
    if ((0, uniq_1.default)(value.input.assets).length !== value.input.assets.length) {
        throw new Error('Factory asset input should not contains duplicate address');
    }
    try {
        // should be a valid mustache template when serialized as json
        const template = JSON.stringify(value.output, null, 2);
        const result = mustache_1.default.parse(template);
        if (result.filter(([type]) => type === 'name').some(([, notation]) => (0, exports.isValidNotation)(notation) === false)) {
            throw new Error('Invalid tags found in the output template');
        }
    }
    catch (err) {
        throw new Error('Factory output should be a valid mustache template when serialized as json');
    }
    // validate hooks
    const quota = (0, contract_1.getQuota)(value.input);
    if (Array.isArray(value.hooks)) {
        const invalidHook = value.hooks.find((x) => (0, exports.isValidHook)(x, quota, true) === false);
        if (invalidHook) {
            throw new Error(`Factory hook ${invalidHook.name} is invalid`);
        }
    }
    // ensure input and hook are zero-sum for factories that consumes token
    if (value.settlement === 'instant') {
        if (quota.value <= 0 && Object.keys(quota.tokens).every((x) => quota[x] <= 0)) {
            return true;
        }
        if ((0, isEmpty_1.default)(value.hooks)) {
            throw new Error('Factory hooks should not be empty for instant settlement');
        }
        const mintHook = value.hooks.find((x) => x.name === 'mint');
        if (!mintHook) {
            throw new Error('Factory hook mint should not be empty for instant settlement that consumes token');
        }
        try {
            const compiled = (0, contract_1.compile)(mintHook.hook);
            (0, contract_1.validate)(compiled, quota, true);
        }
        catch (err) {
            throw new Error(`Factory hook mint is invalid: ${err.message}`);
        }
    }
    return true;
};
exports.isValidFactory = isValidFactory;
/**
 * Find credentialSubject path in the object
 * Because they need prerender
 *
 * @param {object} obj
 * @param {string} keyword
 * @return {string} list of keys
 */
const findPrerenderKeys = (obj, keyword) => {
    const flatObj = (0, flat_1.default)(obj, { safe: true });
    const keys = Object.keys(flatObj)
        .map((x) => x.split('.'))
        .filter((x) => x.includes(keyword))
        .map((x) => x.slice(0, x.lastIndexOf(keyword) + 1))
        .sort((a, b) => b.length - a.length)
        .map((x) => x.join('.'));
    return (0, uniq_1.default)(keys);
};
exports.findPrerenderKeys = findPrerenderKeys;
/**
 * Mint from an asset factory, used on server side
 *
 * @param {object} params { factory, inputs, issuer }
 * @param {object} params.factory factory object
 * @param {object} params.inputs factory input variables
 * @param {string} params.owner owner did for the new asset
 * @param {object} params.issuer issuer object
 */
const mintFromFactory = ({ factory, inputs, owner, issuer, }) => {
    const { output, address: factoryAddress, numMinted, data } = factory;
    debug('mintFromFactory.args', JSON.stringify({ output, factoryAddress, numMinted, inputs, owner, issuer, data }, null, 2));
    const asset = JSON.parse(mustache_1.default.render(JSON.stringify(output), {
        input: inputs,
        data: data.value || data,
        ctx: { factory: factoryAddress, id: numMinted + 1, owner, issuer },
    }));
    const address = (0, did_util_1.toAssetAddress)(asset);
    debug('mintFromFactory.result', JSON.stringify({ asset, address }, null, 2));
    return { asset, address };
};
exports.mintFromFactory = mintFromFactory;
/**
 * Simulate minting from an asset factory, used for client side
 *
 * @param {object} params { factory, inputs, issuer }
 * @param {object} params.factory factory object
 * @param {object} params.inputs factory input variables
 * @param {string} params.owner owner did for the new asset
 * @param {object} params.issuer factory issuer wallet and name
 */
const preMintFromFactory = ({ factory, inputs, owner, issuer, }) => {
    if (Object.keys(inputs).some((x) => typeof inputs[x] !== 'string')) {
        throw new Error('Failed to mint asset from factory: input values must be strings');
    }
    let asset = null;
    const { output, numMinted, address: factoryAddress, data } = factory;
    const { wallet, name } = issuer;
    debug('preMintFromFactory.args', JSON.stringify({ output, factoryAddress, numMinted, inputs, owner, issuer, data }, null, 2));
    const extra = {};
    const issuerObject = { id: wallet.address, pk: (0, util_1.toBase58)(wallet.publicKey), name };
    const render = (templateObject) => JSON.parse(mustache_1.default.render(JSON.stringify(templateObject), {
        input: Object.assign(Object.assign({}, inputs), extra),
        data: data.value || data,
        ctx: { factory: factoryAddress, id: numMinted + 1, owner, issuer: issuerObject },
    }));
    const template = (0, cloneDeep_1.default)(output);
    // prerender credentialSubjects if they exists
    // then populate their ids
    const prerenderKeys = (0, exports.findPrerenderKeys)(template, 'credentialSubject');
    if (prerenderKeys.length) {
        extra.issuanceDate = new Date().toISOString();
        for (const key of prerenderKeys) {
            const subjectTemplate = (0, get_1.default)(template, key);
            const subjectObject = Array.isArray(subjectTemplate)
                ? subjectTemplate.map((x) => render(x))
                : render(subjectTemplate);
            (0, set_1.default)(template, key, subjectObject);
            // calculate credential id from credentialSubject
            const vcRootPath = key.split('.').slice(0, -1).join('.');
            const vcIdPath = vcRootPath.split('.').concat(['id']).join('.');
            const typeInfo = (0, did_1.toTypeInfo)(issuerObject.id);
            const vcType = Object.assign(Object.assign({}, typeInfo), { role: mcrypto_1.types.RoleType.ROLE_VC });
            const vcId = (0, did_1.fromPublicKeyHash)(wallet.hash((0, vc_1.stableStringify)(subjectObject)), vcType);
            extra.id = vcId;
            extra.proofType = vc_1.proofTypes[typeInfo.pk];
            // technically we do not support nested vc when minting
            // But it is possible to support multiple credentialSubjects when minting
            (0, set_1.default)(template, vcIdPath, vcId);
            // Generate proof signatures
            if (!vc_1.proofTypes[typeInfo.pk]) {
                throw new Error('Unsupported signer type when create verifiable credential');
            }
            let vcObj = render((0, get_1.default)(template, vcRootPath));
            delete vcObj.proof;
            const vcStr = (0, vc_1.stableStringify)(vcObj);
            const signature = (0, util_1.toBase64)(wallet.sign(vcStr));
            vcObj.proof = {
                type: vc_1.proofTypes[typeInfo.pk],
                created: extra.issuanceDate,
                proofPurpose: 'assertionMethod',
                jws: signature,
            };
            extra.signature = signature;
            try {
                // Simulate minting from start, so that we can ensure the validity of minted asset
                asset = render((0, cloneDeep_1.default)(output));
                vcObj = (0, get_1.default)(asset, vcRootPath);
                debug('preMintFromFactory.result', JSON.stringify(asset, null, 2));
                (0, vc_1.verify)({ vc: vcObj, trustedIssuers: [issuerObject.id], ownerDid: owner, ignoreExpired: true });
            }
            catch (err) {
                console.error(err);
                throw new Error('Failed to mint asset from factory: invalid verifiable credential minted');
            }
        }
    }
    else {
        // populate other variables into the whole output
        asset = render(template);
        debug('preMintFromFactory.result', JSON.stringify(asset, null, 2));
    }
    // calculate address
    const address = (0, did_util_1.toAssetAddress)(asset);
    // return extra inputs
    return { address, issuer: issuerObject, variables: Object.assign(Object.assign({}, inputs), extra), asset };
};
exports.preMintFromFactory = preMintFromFactory;
const formatFactoryState = (state) => {
    const { address, output, data, numMinted } = state;
    const outputX = (0, cloneDeep_1.default)(output);
    outputX.data.value = JSON.parse(outputX.data.value);
    outputX.data.type = outputX.data.typeUrl;
    return {
        address,
        output: outputX,
        data: JSON.parse(data.value),
        numMinted,
    };
};
exports.formatFactoryState = formatFactoryState;
