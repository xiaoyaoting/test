// package: ocap
// file: type.proto

import * as jspb from "google-protobuf";
import * as google_protobuf_timestamp_pb from "google-protobuf/google/protobuf/timestamp_pb";
import * as google_protobuf_any_pb from "google-protobuf/google/protobuf/any_pb";
import * as vendor_pb from "./vendor_pb";
import * as enum_pb from "./enum_pb";

export class BigUint extends jspb.Message {
  getValue(): Uint8Array | string;
  getValue_asU8(): Uint8Array;
  getValue_asB64(): string;
  setValue(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TBigUint;
  static toObject(includeInstance: boolean, msg: BigUint): TBigUint;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BigUint, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BigUint;
  static deserializeBinaryFromReader(message: BigUint, reader: jspb.BinaryReader): BigUint;
}

export type TBigUint = {
  value: Uint8Array | string,
}

export class BigSint extends jspb.Message {
  getValue(): Uint8Array | string;
  getValue_asU8(): Uint8Array;
  getValue_asB64(): string;
  setValue(value: Uint8Array | string): void;

  getMinus(): boolean;
  setMinus(value: boolean): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TBigSint;
  static toObject(includeInstance: boolean, msg: BigSint): TBigSint;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BigSint, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BigSint;
  static deserializeBinaryFromReader(message: BigSint, reader: jspb.BinaryReader): BigSint;
}

export type TBigSint = {
  value: Uint8Array | string,
  minus: boolean,
}

export class TokenSymbol extends jspb.Message {
  getAddress(): string;
  setAddress(value: string): void;

  getSymbol(): string;
  setSymbol(value: string): void;

  getDecimal(): number;
  setDecimal(value: number): void;

  getUnit(): string;
  setUnit(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TTokenSymbol;
  static toObject(includeInstance: boolean, msg: TokenSymbol): TTokenSymbol;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TokenSymbol, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TokenSymbol;
  static deserializeBinaryFromReader(message: TokenSymbol, reader: jspb.BinaryReader): TokenSymbol;
}

export type TTokenSymbol = {
  address: string,
  symbol: string,
  decimal: number,
  unit: string,
}

export class WalletType extends jspb.Message {
  getPk(): enum_pb.KeyTypeMap[keyof enum_pb.KeyTypeMap];
  setPk(value: enum_pb.KeyTypeMap[keyof enum_pb.KeyTypeMap]): void;

  getHash(): enum_pb.HashTypeMap[keyof enum_pb.HashTypeMap];
  setHash(value: enum_pb.HashTypeMap[keyof enum_pb.HashTypeMap]): void;

  getAddress(): enum_pb.EncodingTypeMap[keyof enum_pb.EncodingTypeMap];
  setAddress(value: enum_pb.EncodingTypeMap[keyof enum_pb.EncodingTypeMap]): void;

  getRole(): enum_pb.RoleTypeMap[keyof enum_pb.RoleTypeMap];
  setRole(value: enum_pb.RoleTypeMap[keyof enum_pb.RoleTypeMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TWalletType;
  static toObject(includeInstance: boolean, msg: WalletType): TWalletType;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: WalletType, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): WalletType;
  static deserializeBinaryFromReader(message: WalletType, reader: jspb.BinaryReader): WalletType;
}

export type TWalletType = {
  pk: enum_pb.KeyTypeMap[keyof enum_pb.KeyTypeMap],
  hash: enum_pb.HashTypeMap[keyof enum_pb.HashTypeMap],
  address: enum_pb.EncodingTypeMap[keyof enum_pb.EncodingTypeMap],
  role: enum_pb.RoleTypeMap[keyof enum_pb.RoleTypeMap],
}

export class WalletInfo extends jspb.Message {
  hasType(): boolean;
  clearType(): void;
  getType(): TWalletType | undefined;
  setType(value?: TWalletType): void;

  getSk(): Uint8Array | string;
  getSk_asU8(): Uint8Array;
  getSk_asB64(): string;
  setSk(value: Uint8Array | string): void;

  getPk(): Uint8Array | string;
  getPk_asU8(): Uint8Array;
  getPk_asB64(): string;
  setPk(value: Uint8Array | string): void;

  getAddress(): string;
  setAddress(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TWalletInfo;
  static toObject(includeInstance: boolean, msg: WalletInfo): TWalletInfo;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: WalletInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): WalletInfo;
  static deserializeBinaryFromReader(message: WalletInfo, reader: jspb.BinaryReader): WalletInfo;
}

export type TWalletInfo = {
  type?: TWalletType,
  sk: Uint8Array | string,
  pk: Uint8Array | string,
  address: string,
}

export class ChainInfo extends jspb.Message {
  getId(): string;
  setId(value: string): void;

  getNetwork(): string;
  setNetwork(value: string): void;

  getMoniker(): string;
  setMoniker(value: string): void;

  getConsensusVersion(): string;
  setConsensusVersion(value: string): void;

  getSynced(): boolean;
  setSynced(value: boolean): void;

  getAppHash(): Uint8Array | string;
  getAppHash_asU8(): Uint8Array;
  getAppHash_asB64(): string;
  setAppHash(value: Uint8Array | string): void;

  getBlockHash(): Uint8Array | string;
  getBlockHash_asU8(): Uint8Array;
  getBlockHash_asB64(): string;
  setBlockHash(value: Uint8Array | string): void;

  getBlockHeight(): string;
  setBlockHeight(value: string): void;

  hasBlockTime(): boolean;
  clearBlockTime(): void;
  getBlockTime(): google_protobuf_timestamp_pb.Timestamp | undefined;
  setBlockTime(value?: google_protobuf_timestamp_pb.Timestamp): void;

  getAddress(): string;
  setAddress(value: string): void;

  getVotingPower(): string;
  setVotingPower(value: string): void;

  getTotalTxs(): string;
  setTotalTxs(value: string): void;

  getVersion(): string;
  setVersion(value: string): void;

  getForgeAppsVersionMap(): jspb.Map<string, string>;
  clearForgeAppsVersionMap(): void;
  clearSupportedTxsList(): void;
  getSupportedTxsList(): Array<string>;
  setSupportedTxsList(value: Array<string>): void;
  addSupportedTxs(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TChainInfo;
  static toObject(includeInstance: boolean, msg: ChainInfo): TChainInfo;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChainInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChainInfo;
  static deserializeBinaryFromReader(message: ChainInfo, reader: jspb.BinaryReader): ChainInfo;
}

export type TChainInfo = {
  id: string,
  network: string,
  moniker: string,
  consensusVersion: string,
  synced: boolean,
  appHash: Uint8Array | string,
  blockHash: Uint8Array | string,
  blockHeight: string,
  blockTime?: google_protobuf_timestamp_pb.Timestamp,
  address: string,
  votingPower: string,
  totalTxs: string,
  version: string,
  forgeAppsVersionMap: Array<[string, string]>,
  supportedTxs: Array<string>,
}

export class NodeInfo extends jspb.Message {
  getId(): string;
  setId(value: string): void;

  getNetwork(): string;
  setNetwork(value: string): void;

  getMoniker(): string;
  setMoniker(value: string): void;

  getConsensusVersion(): string;
  setConsensusVersion(value: string): void;

  getSynced(): boolean;
  setSynced(value: boolean): void;

  getAppHash(): Uint8Array | string;
  getAppHash_asU8(): Uint8Array;
  getAppHash_asB64(): string;
  setAppHash(value: Uint8Array | string): void;

  getBlockHash(): Uint8Array | string;
  getBlockHash_asU8(): Uint8Array;
  getBlockHash_asB64(): string;
  setBlockHash(value: Uint8Array | string): void;

  getBlockHeight(): string;
  setBlockHeight(value: string): void;

  hasBlockTime(): boolean;
  clearBlockTime(): void;
  getBlockTime(): google_protobuf_timestamp_pb.Timestamp | undefined;
  setBlockTime(value?: google_protobuf_timestamp_pb.Timestamp): void;

  getAddress(): string;
  setAddress(value: string): void;

  getVotingPower(): string;
  setVotingPower(value: string): void;

  getTotalTxs(): string;
  setTotalTxs(value: string): void;

  getVersion(): string;
  setVersion(value: string): void;

  getForgeAppsVersionMap(): jspb.Map<string, string>;
  clearForgeAppsVersionMap(): void;
  clearSupportedTxsList(): void;
  getSupportedTxsList(): Array<string>;
  setSupportedTxsList(value: Array<string>): void;
  addSupportedTxs(value: string, index?: number): string;

  getIp(): string;
  setIp(value: string): void;

  hasGeoInfo(): boolean;
  clearGeoInfo(): void;
  getGeoInfo(): TGeoInfo | undefined;
  setGeoInfo(value?: TGeoInfo): void;

  getP2pAddress(): string;
  setP2pAddress(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TNodeInfo;
  static toObject(includeInstance: boolean, msg: NodeInfo): TNodeInfo;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: NodeInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): NodeInfo;
  static deserializeBinaryFromReader(message: NodeInfo, reader: jspb.BinaryReader): NodeInfo;
}

export type TNodeInfo = {
  id: string,
  network: string,
  moniker: string,
  consensusVersion: string,
  synced: boolean,
  appHash: Uint8Array | string,
  blockHash: Uint8Array | string,
  blockHeight: string,
  blockTime?: google_protobuf_timestamp_pb.Timestamp,
  address: string,
  votingPower: string,
  totalTxs: string,
  version: string,
  forgeAppsVersionMap: Array<[string, string]>,
  supportedTxs: Array<string>,
  ip: string,
  geoInfo?: TGeoInfo,
  p2pAddress: string,
}

export class Validator extends jspb.Message {
  getAddress(): string;
  setAddress(value: string): void;

  getPower(): string;
  setPower(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TValidator;
  static toObject(includeInstance: boolean, msg: Validator): TValidator;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Validator, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Validator;
  static deserializeBinaryFromReader(message: Validator, reader: jspb.BinaryReader): Validator;
}

export type TValidator = {
  address: string,
  power: string,
}

export class ConsensusParams extends jspb.Message {
  getMaxBytes(): string;
  setMaxBytes(value: string): void;

  getMaxGas(): string;
  setMaxGas(value: string): void;

  getMaxValidators(): number;
  setMaxValidators(value: number): void;

  getMaxCandidates(): number;
  setMaxCandidates(value: number): void;

  clearPubKeyTypesList(): void;
  getPubKeyTypesList(): Array<string>;
  setPubKeyTypesList(value: Array<string>): void;
  addPubKeyTypes(value: string, index?: number): string;

  clearValidatorsList(): void;
  getValidatorsList(): Array<TValidator>;
  setValidatorsList(value: Array<TValidator>): void;
  addValidators(value?: Validator, index?: number): Validator;

  getValidatorChanged(): boolean;
  setValidatorChanged(value: boolean): void;

  getParamChanged(): boolean;
  setParamChanged(value: boolean): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TConsensusParams;
  static toObject(includeInstance: boolean, msg: ConsensusParams): TConsensusParams;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ConsensusParams, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ConsensusParams;
  static deserializeBinaryFromReader(message: ConsensusParams, reader: jspb.BinaryReader): ConsensusParams;
}

export type TConsensusParams = {
  maxBytes: string,
  maxGas: string,
  maxValidators: number,
  maxCandidates: number,
  pubKeyTypes: Array<string>,
  validators: Array<TValidator>,
  validatorChanged: boolean,
  paramChanged: boolean,
}

export class UpgradeTask extends jspb.Message {
  getType(): enum_pb.UpgradeTypeMap[keyof enum_pb.UpgradeTypeMap];
  setType(value: enum_pb.UpgradeTypeMap[keyof enum_pb.UpgradeTypeMap]): void;

  getDataHash(): string;
  setDataHash(value: string): void;

  clearActionsList(): void;
  getActionsList(): Array<enum_pb.UpgradeActionMap[keyof enum_pb.UpgradeActionMap]>;
  setActionsList(value: Array<enum_pb.UpgradeActionMap[keyof enum_pb.UpgradeActionMap]>): void;
  addActions(value: enum_pb.UpgradeActionMap[keyof enum_pb.UpgradeActionMap], index?: number): enum_pb.UpgradeActionMap[keyof enum_pb.UpgradeActionMap];

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TUpgradeTask;
  static toObject(includeInstance: boolean, msg: UpgradeTask): TUpgradeTask;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: UpgradeTask, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): UpgradeTask;
  static deserializeBinaryFromReader(message: UpgradeTask, reader: jspb.BinaryReader): UpgradeTask;
}

export type TUpgradeTask = {
  type: enum_pb.UpgradeTypeMap[keyof enum_pb.UpgradeTypeMap],
  dataHash: string,
  actions: Array<enum_pb.UpgradeActionMap[keyof enum_pb.UpgradeActionMap]>,
}

export class UpgradeTasks extends jspb.Message {
  clearItemList(): void;
  getItemList(): Array<TUpgradeTask>;
  setItemList(value: Array<TUpgradeTask>): void;
  addItem(value?: UpgradeTask, index?: number): UpgradeTask;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TUpgradeTasks;
  static toObject(includeInstance: boolean, msg: UpgradeTasks): TUpgradeTasks;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: UpgradeTasks, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): UpgradeTasks;
  static deserializeBinaryFromReader(message: UpgradeTasks, reader: jspb.BinaryReader): UpgradeTasks;
}

export type TUpgradeTasks = {
  item: Array<TUpgradeTask>,
}

export class Multisig extends jspb.Message {
  getSigner(): string;
  setSigner(value: string): void;

  getPk(): Uint8Array | string;
  getPk_asU8(): Uint8Array;
  getPk_asB64(): string;
  setPk(value: Uint8Array | string): void;

  getSignature(): Uint8Array | string;
  getSignature_asU8(): Uint8Array;
  getSignature_asB64(): string;
  setSignature(value: Uint8Array | string): void;

  getDelegator(): string;
  setDelegator(value: string): void;

  hasData(): boolean;
  clearData(): void;
  getData(): google_protobuf_any_pb.Any | undefined;
  setData(value?: google_protobuf_any_pb.Any): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TMultisig;
  static toObject(includeInstance: boolean, msg: Multisig): TMultisig;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Multisig, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Multisig;
  static deserializeBinaryFromReader(message: Multisig, reader: jspb.BinaryReader): Multisig;
}

export type TMultisig = {
  signer: string,
  pk: Uint8Array | string,
  signature: Uint8Array | string,
  delegator: string,
  data?: google_protobuf_any_pb.Any,
}

export class Transaction extends jspb.Message {
  getFrom(): string;
  setFrom(value: string): void;

  getNonce(): number;
  setNonce(value: number): void;

  getChainId(): string;
  setChainId(value: string): void;

  getPk(): Uint8Array | string;
  getPk_asU8(): Uint8Array;
  getPk_asB64(): string;
  setPk(value: Uint8Array | string): void;

  getGas(): number;
  setGas(value: number): void;

  getDelegator(): string;
  setDelegator(value: string): void;

  getSignature(): Uint8Array | string;
  getSignature_asU8(): Uint8Array;
  getSignature_asB64(): string;
  setSignature(value: Uint8Array | string): void;

  clearSignaturesList(): void;
  getSignaturesList(): Array<TMultisig>;
  setSignaturesList(value: Array<TMultisig>): void;
  addSignatures(value?: Multisig, index?: number): Multisig;

  hasItx(): boolean;
  clearItx(): void;
  getItx(): google_protobuf_any_pb.Any | undefined;
  setItx(value?: google_protobuf_any_pb.Any): void;

  clearReceiptsList(): void;
  getReceiptsList(): Array<TTransactionReceipt>;
  setReceiptsList(value: Array<TTransactionReceipt>): void;
  addReceipts(value?: TransactionReceipt, index?: number): TransactionReceipt;

  getServiceFee(): string;
  setServiceFee(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TTransaction;
  static toObject(includeInstance: boolean, msg: Transaction): TTransaction;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Transaction, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Transaction;
  static deserializeBinaryFromReader(message: Transaction, reader: jspb.BinaryReader): Transaction;
}

export type TTransaction = {
  from: string,
  nonce: number,
  chainId: string,
  pk: Uint8Array | string,
  gas: number,
  delegator: string,
  signature: Uint8Array | string,
  signatures: Array<TMultisig>,
  itx?: google_protobuf_any_pb.Any,
  receipts: Array<TTransactionReceipt>,
  serviceFee: string,
}

export class TransactionInfo extends jspb.Message {
  hasTx(): boolean;
  clearTx(): void;
  getTx(): TTransaction | undefined;
  setTx(value?: TTransaction): void;

  getHeight(): string;
  setHeight(value: string): void;

  getIndex(): number;
  setIndex(value: number): void;

  getHash(): string;
  setHash(value: string): void;

  clearTagsList(): void;
  getTagsList(): Array<vendor_pb.TKVPair>;
  setTagsList(value: Array<vendor_pb.TKVPair>): void;
  addTags(value?: vendor_pb.KVPair, index?: number): vendor_pb.KVPair;

  getCode(): enum_pb.StatusCodeMap[keyof enum_pb.StatusCodeMap];
  setCode(value: enum_pb.StatusCodeMap[keyof enum_pb.StatusCodeMap]): void;

  hasTime(): boolean;
  clearTime(): void;
  getTime(): google_protobuf_timestamp_pb.Timestamp | undefined;
  setTime(value?: google_protobuf_timestamp_pb.Timestamp): void;

  clearReceiptsList(): void;
  getReceiptsList(): Array<TTransactionReceipt>;
  setReceiptsList(value: Array<TTransactionReceipt>): void;
  addReceipts(value?: TransactionReceipt, index?: number): TransactionReceipt;

  getSender(): string;
  setSender(value: string): void;

  getReceiver(): string;
  setReceiver(value: string): void;

  clearTokenSymbolsList(): void;
  getTokenSymbolsList(): Array<TTokenSymbol>;
  setTokenSymbolsList(value: Array<TTokenSymbol>): void;
  addTokenSymbols(value?: TokenSymbol, index?: number): TokenSymbol;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TTransactionInfo;
  static toObject(includeInstance: boolean, msg: TransactionInfo): TTransactionInfo;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TransactionInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TransactionInfo;
  static deserializeBinaryFromReader(message: TransactionInfo, reader: jspb.BinaryReader): TransactionInfo;
}

export type TTransactionInfo = {
  tx?: TTransaction,
  height: string,
  index: number,
  hash: string,
  tags: Array<vendor_pb.TKVPair>,
  code: enum_pb.StatusCodeMap[keyof enum_pb.StatusCodeMap],
  time?: google_protobuf_timestamp_pb.Timestamp,
  receipts: Array<TTransactionReceipt>,
  sender: string,
  receiver: string,
  tokenSymbols: Array<TTokenSymbol>,
}

export class TransactionReceipt extends jspb.Message {
  getAddress(): string;
  setAddress(value: string): void;

  clearChangesList(): void;
  getChangesList(): Array<TReceiptChange>;
  setChangesList(value: Array<TReceiptChange>): void;
  addChanges(value?: ReceiptChange, index?: number): ReceiptChange;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TTransactionReceipt;
  static toObject(includeInstance: boolean, msg: TransactionReceipt): TTransactionReceipt;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TransactionReceipt, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TransactionReceipt;
  static deserializeBinaryFromReader(message: TransactionReceipt, reader: jspb.BinaryReader): TransactionReceipt;
}

export type TTransactionReceipt = {
  address: string,
  changes: Array<TReceiptChange>,
}

export class ReceiptChange extends jspb.Message {
  getTarget(): string;
  setTarget(value: string): void;

  getAction(): string;
  setAction(value: string): void;

  getValue(): string;
  setValue(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TReceiptChange;
  static toObject(includeInstance: boolean, msg: ReceiptChange): TReceiptChange;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ReceiptChange, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ReceiptChange;
  static deserializeBinaryFromReader(message: ReceiptChange, reader: jspb.BinaryReader): ReceiptChange;
}

export type TReceiptChange = {
  target: string,
  action: string,
  value: string,
}

export class TokenInput extends jspb.Message {
  getAddress(): string;
  setAddress(value: string): void;

  getValue(): string;
  setValue(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TTokenInput;
  static toObject(includeInstance: boolean, msg: TokenInput): TTokenInput;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TokenInput, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TokenInput;
  static deserializeBinaryFromReader(message: TokenInput, reader: jspb.BinaryReader): TokenInput;
}

export type TTokenInput = {
  address: string,
  value: string,
}

export class TransactionInput extends jspb.Message {
  getOwner(): string;
  setOwner(value: string): void;

  clearTokensList(): void;
  getTokensList(): Array<TTokenInput>;
  setTokensList(value: Array<TTokenInput>): void;
  addTokens(value?: TokenInput, index?: number): TokenInput;

  clearAssetsList(): void;
  getAssetsList(): Array<string>;
  setAssetsList(value: Array<string>): void;
  addAssets(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TTransactionInput;
  static toObject(includeInstance: boolean, msg: TransactionInput): TTransactionInput;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TransactionInput, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TransactionInput;
  static deserializeBinaryFromReader(message: TransactionInput, reader: jspb.BinaryReader): TransactionInput;
}

export type TTransactionInput = {
  owner: string,
  tokens: Array<TTokenInput>,
  assets: Array<string>,
}

export class VariableInput extends jspb.Message {
  getName(): string;
  setName(value: string): void;

  getValue(): string;
  setValue(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  getRequired(): boolean;
  setRequired(value: boolean): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TVariableInput;
  static toObject(includeInstance: boolean, msg: VariableInput): TVariableInput;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: VariableInput, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): VariableInput;
  static deserializeBinaryFromReader(message: VariableInput, reader: jspb.BinaryReader): VariableInput;
}

export type TVariableInput = {
  name: string,
  value: string,
  description: string,
  required: boolean,
}

export class DelegateConfig extends jspb.Message {
  getDeltaInterval(): number;
  setDeltaInterval(value: number): void;

  clearTypeUrlsList(): void;
  getTypeUrlsList(): Array<string>;
  setTypeUrlsList(value: Array<string>): void;
  addTypeUrls(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TDelegateConfig;
  static toObject(includeInstance: boolean, msg: DelegateConfig): TDelegateConfig;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DelegateConfig, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DelegateConfig;
  static deserializeBinaryFromReader(message: DelegateConfig, reader: jspb.BinaryReader): DelegateConfig;
}

export type TDelegateConfig = {
  deltaInterval: number,
  typeUrls: Array<string>,
}

export class VaultConfig extends jspb.Message {
  getSlashedStake(): string;
  setSlashedStake(value: string): void;

  getTxFee(): string;
  setTxFee(value: string): void;

  clearTxGasList(): void;
  getTxGasList(): Array<string>;
  setTxGasList(value: Array<string>): void;
  addTxGas(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TVaultConfig;
  static toObject(includeInstance: boolean, msg: VaultConfig): TVaultConfig;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: VaultConfig, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): VaultConfig;
  static deserializeBinaryFromReader(message: VaultConfig, reader: jspb.BinaryReader): VaultConfig;
}

export type TVaultConfig = {
  slashedStake: string,
  txFee: string,
  txGas: Array<string>,
}

export class TxFeeConfig extends jspb.Message {
  getTypeUrl(): string;
  setTypeUrl(value: string): void;

  getFee(): string;
  setFee(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TTxFeeConfig;
  static toObject(includeInstance: boolean, msg: TxFeeConfig): TTxFeeConfig;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TxFeeConfig, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TxFeeConfig;
  static deserializeBinaryFromReader(message: TxFeeConfig, reader: jspb.BinaryReader): TxFeeConfig;
}

export type TTxFeeConfig = {
  typeUrl: string,
  fee: string,
}

export class TxGasConfig extends jspb.Message {
  getPrice(): number;
  setPrice(value: number): void;

  getCreateState(): number;
  setCreateState(value: number): void;

  getUpdateState(): number;
  setUpdateState(value: number): void;

  getDataStorage(): number;
  setDataStorage(value: number): void;

  getMinStake(): string;
  setMinStake(value: string): void;

  getMaxStake(): string;
  setMaxStake(value: string): void;

  getStakeLockPeriod(): number;
  setStakeLockPeriod(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TTxGasConfig;
  static toObject(includeInstance: boolean, msg: TxGasConfig): TTxGasConfig;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TxGasConfig, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TxGasConfig;
  static deserializeBinaryFromReader(message: TxGasConfig, reader: jspb.BinaryReader): TxGasConfig;
}

export type TTxGasConfig = {
  price: number,
  createState: number,
  updateState: number,
  dataStorage: number,
  minStake: string,
  maxStake: string,
  stakeLockPeriod: number,
}

export class TransactionConfig extends jspb.Message {
  getMaxAssetSize(): number;
  setMaxAssetSize(value: number): void;

  getMaxListSize(): number;
  setMaxListSize(value: number): void;

  getMaxMultisig(): number;
  setMaxMultisig(value: number): void;

  hasDelegate(): boolean;
  clearDelegate(): void;
  getDelegate(): TDelegateConfig | undefined;
  setDelegate(value?: TDelegateConfig): void;

  clearTxFeeList(): void;
  getTxFeeList(): Array<TTxFeeConfig>;
  setTxFeeList(value: Array<TTxFeeConfig>): void;
  addTxFee(value?: TxFeeConfig, index?: number): TxFeeConfig;

  hasTxGas(): boolean;
  clearTxGas(): void;
  getTxGas(): TTxGasConfig | undefined;
  setTxGas(value?: TTxGasConfig): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TTransactionConfig;
  static toObject(includeInstance: boolean, msg: TransactionConfig): TTransactionConfig;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TransactionConfig, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TransactionConfig;
  static deserializeBinaryFromReader(message: TransactionConfig, reader: jspb.BinaryReader): TransactionConfig;
}

export type TTransactionConfig = {
  maxAssetSize: number,
  maxListSize: number,
  maxMultisig: number,
  delegate?: TDelegateConfig,
  txFee: Array<TTxFeeConfig>,
  txGas?: TTxGasConfig,
}

export class BlockInfo extends jspb.Message {
  getHeight(): string;
  setHeight(value: string): void;

  getNumTxs(): number;
  setNumTxs(value: number): void;

  hasTime(): boolean;
  clearTime(): void;
  getTime(): google_protobuf_timestamp_pb.Timestamp | undefined;
  setTime(value?: google_protobuf_timestamp_pb.Timestamp): void;

  getAppHash(): Uint8Array | string;
  getAppHash_asU8(): Uint8Array;
  getAppHash_asB64(): string;
  setAppHash(value: Uint8Array | string): void;

  getProposer(): Uint8Array | string;
  getProposer_asU8(): Uint8Array;
  getProposer_asB64(): string;
  setProposer(value: Uint8Array | string): void;

  clearTxsList(): void;
  getTxsList(): Array<TTransactionInfo>;
  setTxsList(value: Array<TTransactionInfo>): void;
  addTxs(value?: TransactionInfo, index?: number): TransactionInfo;

  getTotalTxs(): string;
  setTotalTxs(value: string): void;

  clearInvalidTxsList(): void;
  getInvalidTxsList(): Array<TTransactionInfo>;
  setInvalidTxsList(value: Array<TTransactionInfo>): void;
  addInvalidTxs(value?: TransactionInfo, index?: number): TransactionInfo;

  clearTxsHashesList(): void;
  getTxsHashesList(): Array<string>;
  setTxsHashesList(value: Array<string>): void;
  addTxsHashes(value: string, index?: number): string;

  clearInvalidTxsHashesList(): void;
  getInvalidTxsHashesList(): Array<string>;
  setInvalidTxsHashesList(value: Array<string>): void;
  addInvalidTxsHashes(value: string, index?: number): string;

  getConsensusHash(): Uint8Array | string;
  getConsensusHash_asU8(): Uint8Array;
  getConsensusHash_asB64(): string;
  setConsensusHash(value: Uint8Array | string): void;

  getDataHash(): Uint8Array | string;
  getDataHash_asU8(): Uint8Array;
  getDataHash_asB64(): string;
  setDataHash(value: Uint8Array | string): void;

  getEvidenceHash(): Uint8Array | string;
  getEvidenceHash_asU8(): Uint8Array;
  getEvidenceHash_asB64(): string;
  setEvidenceHash(value: Uint8Array | string): void;

  getLastCommitHash(): Uint8Array | string;
  getLastCommitHash_asU8(): Uint8Array;
  getLastCommitHash_asB64(): string;
  setLastCommitHash(value: Uint8Array | string): void;

  getLastResultsHash(): Uint8Array | string;
  getLastResultsHash_asU8(): Uint8Array;
  getLastResultsHash_asB64(): string;
  setLastResultsHash(value: Uint8Array | string): void;

  getNextValidatorsHash(): Uint8Array | string;
  getNextValidatorsHash_asU8(): Uint8Array;
  getNextValidatorsHash_asB64(): string;
  setNextValidatorsHash(value: Uint8Array | string): void;

  getValidatorsHash(): Uint8Array | string;
  getValidatorsHash_asU8(): Uint8Array;
  getValidatorsHash_asB64(): string;
  setValidatorsHash(value: Uint8Array | string): void;

  hasVersion(): boolean;
  clearVersion(): void;
  getVersion(): vendor_pb.TVersion | undefined;
  setVersion(value?: vendor_pb.TVersion): void;

  hasLastBlockId(): boolean;
  clearLastBlockId(): void;
  getLastBlockId(): vendor_pb.TBlockID | undefined;
  setLastBlockId(value?: vendor_pb.TBlockID): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TBlockInfo;
  static toObject(includeInstance: boolean, msg: BlockInfo): TBlockInfo;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BlockInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BlockInfo;
  static deserializeBinaryFromReader(message: BlockInfo, reader: jspb.BinaryReader): BlockInfo;
}

export type TBlockInfo = {
  height: string,
  numTxs: number,
  time?: google_protobuf_timestamp_pb.Timestamp,
  appHash: Uint8Array | string,
  proposer: Uint8Array | string,
  txs: Array<TTransactionInfo>,
  totalTxs: string,
  invalidTxs: Array<TTransactionInfo>,
  txsHashes: Array<string>,
  invalidTxsHashes: Array<string>,
  consensusHash: Uint8Array | string,
  dataHash: Uint8Array | string,
  evidenceHash: Uint8Array | string,
  lastCommitHash: Uint8Array | string,
  lastResultsHash: Uint8Array | string,
  nextValidatorsHash: Uint8Array | string,
  validatorsHash: Uint8Array | string,
  version?: vendor_pb.TVersion,
  lastBlockId?: vendor_pb.TBlockID,
}

export class BlockInfoSimple extends jspb.Message {
  getHeight(): string;
  setHeight(value: string): void;

  getNumTxs(): number;
  setNumTxs(value: number): void;

  hasTime(): boolean;
  clearTime(): void;
  getTime(): google_protobuf_timestamp_pb.Timestamp | undefined;
  setTime(value?: google_protobuf_timestamp_pb.Timestamp): void;

  getAppHash(): Uint8Array | string;
  getAppHash_asU8(): Uint8Array;
  getAppHash_asB64(): string;
  setAppHash(value: Uint8Array | string): void;

  getProposer(): Uint8Array | string;
  getProposer_asU8(): Uint8Array;
  getProposer_asB64(): string;
  setProposer(value: Uint8Array | string): void;

  getTotalTxs(): string;
  setTotalTxs(value: string): void;

  clearTxsHashesList(): void;
  getTxsHashesList(): Array<string>;
  setTxsHashesList(value: Array<string>): void;
  addTxsHashes(value: string, index?: number): string;

  clearInvalidTxsHashesList(): void;
  getInvalidTxsHashesList(): Array<string>;
  setInvalidTxsHashesList(value: Array<string>): void;
  addInvalidTxsHashes(value: string, index?: number): string;

  getConsensusHash(): Uint8Array | string;
  getConsensusHash_asU8(): Uint8Array;
  getConsensusHash_asB64(): string;
  setConsensusHash(value: Uint8Array | string): void;

  getDataHash(): Uint8Array | string;
  getDataHash_asU8(): Uint8Array;
  getDataHash_asB64(): string;
  setDataHash(value: Uint8Array | string): void;

  getEvidenceHash(): Uint8Array | string;
  getEvidenceHash_asU8(): Uint8Array;
  getEvidenceHash_asB64(): string;
  setEvidenceHash(value: Uint8Array | string): void;

  getLastCommitHash(): Uint8Array | string;
  getLastCommitHash_asU8(): Uint8Array;
  getLastCommitHash_asB64(): string;
  setLastCommitHash(value: Uint8Array | string): void;

  getLastResultsHash(): Uint8Array | string;
  getLastResultsHash_asU8(): Uint8Array;
  getLastResultsHash_asB64(): string;
  setLastResultsHash(value: Uint8Array | string): void;

  getNextValidatorsHash(): Uint8Array | string;
  getNextValidatorsHash_asU8(): Uint8Array;
  getNextValidatorsHash_asB64(): string;
  setNextValidatorsHash(value: Uint8Array | string): void;

  getValidatorsHash(): Uint8Array | string;
  getValidatorsHash_asU8(): Uint8Array;
  getValidatorsHash_asB64(): string;
  setValidatorsHash(value: Uint8Array | string): void;

  hasVersion(): boolean;
  clearVersion(): void;
  getVersion(): vendor_pb.TVersion | undefined;
  setVersion(value?: vendor_pb.TVersion): void;

  hasLastBlockId(): boolean;
  clearLastBlockId(): void;
  getLastBlockId(): vendor_pb.TBlockID | undefined;
  setLastBlockId(value?: vendor_pb.TBlockID): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TBlockInfoSimple;
  static toObject(includeInstance: boolean, msg: BlockInfoSimple): TBlockInfoSimple;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BlockInfoSimple, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BlockInfoSimple;
  static deserializeBinaryFromReader(message: BlockInfoSimple, reader: jspb.BinaryReader): BlockInfoSimple;
}

export type TBlockInfoSimple = {
  height: string,
  numTxs: number,
  time?: google_protobuf_timestamp_pb.Timestamp,
  appHash: Uint8Array | string,
  proposer: Uint8Array | string,
  totalTxs: string,
  txsHashes: Array<string>,
  invalidTxsHashes: Array<string>,
  consensusHash: Uint8Array | string,
  dataHash: Uint8Array | string,
  evidenceHash: Uint8Array | string,
  lastCommitHash: Uint8Array | string,
  lastResultsHash: Uint8Array | string,
  nextValidatorsHash: Uint8Array | string,
  validatorsHash: Uint8Array | string,
  version?: vendor_pb.TVersion,
  lastBlockId?: vendor_pb.TBlockID,
}

export class StateContext extends jspb.Message {
  getGenesisTx(): string;
  setGenesisTx(value: string): void;

  getRenaissanceTx(): string;
  setRenaissanceTx(value: string): void;

  hasGenesisTime(): boolean;
  clearGenesisTime(): void;
  getGenesisTime(): google_protobuf_timestamp_pb.Timestamp | undefined;
  setGenesisTime(value?: google_protobuf_timestamp_pb.Timestamp): void;

  hasRenaissanceTime(): boolean;
  clearRenaissanceTime(): void;
  getRenaissanceTime(): google_protobuf_timestamp_pb.Timestamp | undefined;
  setRenaissanceTime(value?: google_protobuf_timestamp_pb.Timestamp): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TStateContext;
  static toObject(includeInstance: boolean, msg: StateContext): TStateContext;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: StateContext, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): StateContext;
  static deserializeBinaryFromReader(message: StateContext, reader: jspb.BinaryReader): StateContext;
}

export type TStateContext = {
  genesisTx: string,
  renaissanceTx: string,
  genesisTime?: google_protobuf_timestamp_pb.Timestamp,
  renaissanceTime?: google_protobuf_timestamp_pb.Timestamp,
}

export class StakeSummary extends jspb.Message {
  hasTotalStakes(): boolean;
  clearTotalStakes(): void;
  getTotalStakes(): TBigUint | undefined;
  setTotalStakes(value?: TBigUint): void;

  hasTotalUnstakes(): boolean;
  clearTotalUnstakes(): void;
  getTotalUnstakes(): TBigUint | undefined;
  setTotalUnstakes(value?: TBigUint): void;

  hasContext(): boolean;
  clearContext(): void;
  getContext(): TStateContext | undefined;
  setContext(value?: TStateContext): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TStakeSummary;
  static toObject(includeInstance: boolean, msg: StakeSummary): TStakeSummary;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: StakeSummary, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): StakeSummary;
  static deserializeBinaryFromReader(message: StakeSummary, reader: jspb.BinaryReader): StakeSummary;
}

export type TStakeSummary = {
  totalStakes?: TBigUint,
  totalUnstakes?: TBigUint,
  context?: TStateContext,
}

export class UnconfirmedTxs extends jspb.Message {
  getNTxs(): number;
  setNTxs(value: number): void;

  clearTxsList(): void;
  getTxsList(): Array<TTransaction>;
  setTxsList(value: Array<TTransaction>): void;
  addTxs(value?: Transaction, index?: number): Transaction;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TUnconfirmedTxs;
  static toObject(includeInstance: boolean, msg: UnconfirmedTxs): TUnconfirmedTxs;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: UnconfirmedTxs, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): UnconfirmedTxs;
  static deserializeBinaryFromReader(message: UnconfirmedTxs, reader: jspb.BinaryReader): UnconfirmedTxs;
}

export type TUnconfirmedTxs = {
  nTxs: number,
  txs: Array<TTransaction>,
}

export class NetInfo extends jspb.Message {
  getListening(): boolean;
  setListening(value: boolean): void;

  clearListenersList(): void;
  getListenersList(): Array<string>;
  setListenersList(value: Array<string>): void;
  addListeners(value: string, index?: number): string;

  getNPeers(): number;
  setNPeers(value: number): void;

  clearPeersList(): void;
  getPeersList(): Array<TPeerInfo>;
  setPeersList(value: Array<TPeerInfo>): void;
  addPeers(value?: PeerInfo, index?: number): PeerInfo;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TNetInfo;
  static toObject(includeInstance: boolean, msg: NetInfo): TNetInfo;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: NetInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): NetInfo;
  static deserializeBinaryFromReader(message: NetInfo, reader: jspb.BinaryReader): NetInfo;
}

export type TNetInfo = {
  listening: boolean,
  listeners: Array<string>,
  nPeers: number,
  peers: Array<TPeerInfo>,
}

export class GeoInfo extends jspb.Message {
  getCity(): string;
  setCity(value: string): void;

  getCountry(): string;
  setCountry(value: string): void;

  getLatitude(): number;
  setLatitude(value: number): void;

  getLongitude(): number;
  setLongitude(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TGeoInfo;
  static toObject(includeInstance: boolean, msg: GeoInfo): TGeoInfo;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GeoInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GeoInfo;
  static deserializeBinaryFromReader(message: GeoInfo, reader: jspb.BinaryReader): GeoInfo;
}

export type TGeoInfo = {
  city: string,
  country: string,
  latitude: number,
  longitude: number,
}

export class PeerInfo extends jspb.Message {
  getId(): string;
  setId(value: string): void;

  getNetwork(): string;
  setNetwork(value: string): void;

  getConsensusVersion(): string;
  setConsensusVersion(value: string): void;

  getMoniker(): string;
  setMoniker(value: string): void;

  getIp(): string;
  setIp(value: string): void;

  hasGeoInfo(): boolean;
  clearGeoInfo(): void;
  getGeoInfo(): TGeoInfo | undefined;
  setGeoInfo(value?: TGeoInfo): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TPeerInfo;
  static toObject(includeInstance: boolean, msg: PeerInfo): TPeerInfo;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PeerInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PeerInfo;
  static deserializeBinaryFromReader(message: PeerInfo, reader: jspb.BinaryReader): PeerInfo;
}

export type TPeerInfo = {
  id: string,
  network: string,
  consensusVersion: string,
  moniker: string,
  ip: string,
  geoInfo?: TGeoInfo,
}

export class ValidatorsInfo extends jspb.Message {
  getBlockHeight(): string;
  setBlockHeight(value: string): void;

  clearValidatorsList(): void;
  getValidatorsList(): Array<TValidatorInfo>;
  setValidatorsList(value: Array<TValidatorInfo>): void;
  addValidators(value?: ValidatorInfo, index?: number): ValidatorInfo;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TValidatorsInfo;
  static toObject(includeInstance: boolean, msg: ValidatorsInfo): TValidatorsInfo;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ValidatorsInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ValidatorsInfo;
  static deserializeBinaryFromReader(message: ValidatorsInfo, reader: jspb.BinaryReader): ValidatorsInfo;
}

export type TValidatorsInfo = {
  blockHeight: string,
  validators: Array<TValidatorInfo>,
}

export class ValidatorInfo extends jspb.Message {
  getAddress(): string;
  setAddress(value: string): void;

  hasPubKey(): boolean;
  clearPubKey(): void;
  getPubKey(): vendor_pb.TPubKey | undefined;
  setPubKey(value?: vendor_pb.TPubKey): void;

  getVotingPower(): string;
  setVotingPower(value: string): void;

  getProposerPriority(): string;
  setProposerPriority(value: string): void;

  getName(): string;
  setName(value: string): void;

  hasGeoInfo(): boolean;
  clearGeoInfo(): void;
  getGeoInfo(): TGeoInfo | undefined;
  setGeoInfo(value?: TGeoInfo): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TValidatorInfo;
  static toObject(includeInstance: boolean, msg: ValidatorInfo): TValidatorInfo;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ValidatorInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ValidatorInfo;
  static deserializeBinaryFromReader(message: ValidatorInfo, reader: jspb.BinaryReader): ValidatorInfo;
}

export type TValidatorInfo = {
  address: string,
  pubKey?: vendor_pb.TPubKey,
  votingPower: string,
  proposerPriority: string,
  name: string,
  geoInfo?: TGeoInfo,
}

export class ForgeToken extends jspb.Message {
  getName(): string;
  setName(value: string): void;

  getSymbol(): string;
  setSymbol(value: string): void;

  getUnit(): string;
  setUnit(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  getIcon(): Uint8Array | string;
  getIcon_asU8(): Uint8Array;
  getIcon_asB64(): string;
  setIcon(value: Uint8Array | string): void;

  getDecimal(): number;
  setDecimal(value: number): void;

  getInitialSupply(): string;
  setInitialSupply(value: string): void;

  getTotalSupply(): string;
  setTotalSupply(value: string): void;

  getInflationRate(): number;
  setInflationRate(value: number): void;

  getAddress(): string;
  setAddress(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TForgeToken;
  static toObject(includeInstance: boolean, msg: ForgeToken): TForgeToken;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ForgeToken, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ForgeToken;
  static deserializeBinaryFromReader(message: ForgeToken, reader: jspb.BinaryReader): ForgeToken;
}

export type TForgeToken = {
  name: string,
  symbol: string,
  unit: string,
  description: string,
  icon: Uint8Array | string,
  decimal: number,
  initialSupply: string,
  totalSupply: string,
  inflationRate: number,
  address: string,
}

export class UpgradeInfo extends jspb.Message {
  getHeight(): string;
  setHeight(value: string): void;

  getVersion(): string;
  setVersion(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TUpgradeInfo;
  static toObject(includeInstance: boolean, msg: UpgradeInfo): TUpgradeInfo;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: UpgradeInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): UpgradeInfo;
  static deserializeBinaryFromReader(message: UpgradeInfo, reader: jspb.BinaryReader): UpgradeInfo;
}

export type TUpgradeInfo = {
  height: string,
  version: string,
}

export class WithdrawItem extends jspb.Message {
  getHash(): string;
  setHash(value: string): void;

  hasValue(): boolean;
  clearValue(): void;
  getValue(): TBigUint | undefined;
  setValue(value?: TBigUint): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TWithdrawItem;
  static toObject(includeInstance: boolean, msg: WithdrawItem): TWithdrawItem;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: WithdrawItem, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): WithdrawItem;
  static deserializeBinaryFromReader(message: WithdrawItem, reader: jspb.BinaryReader): WithdrawItem;
}

export type TWithdrawItem = {
  hash: string,
  value?: TBigUint,
}

export class AccountConfig extends jspb.Message {
  getAddress(): string;
  setAddress(value: string): void;

  getPk(): Uint8Array | string;
  getPk_asU8(): Uint8Array;
  getPk_asB64(): string;
  setPk(value: Uint8Array | string): void;

  hasBalance(): boolean;
  clearBalance(): void;
  getBalance(): TBigUint | undefined;
  setBalance(value?: TBigUint): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TAccountConfig;
  static toObject(includeInstance: boolean, msg: AccountConfig): TAccountConfig;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: AccountConfig, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): AccountConfig;
  static deserializeBinaryFromReader(message: AccountConfig, reader: jspb.BinaryReader): AccountConfig;
}

export type TAccountConfig = {
  address: string,
  pk: Uint8Array | string,
  balance?: TBigUint,
}

export class Evidence extends jspb.Message {
  getHash(): string;
  setHash(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TEvidence;
  static toObject(includeInstance: boolean, msg: Evidence): TEvidence;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Evidence, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Evidence;
  static deserializeBinaryFromReader(message: Evidence, reader: jspb.BinaryReader): Evidence;
}

export type TEvidence = {
  hash: string,
}

export class NFTEndpoint extends jspb.Message {
  getId(): string;
  setId(value: string): void;

  getScope(): string;
  setScope(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TNFTEndpoint;
  static toObject(includeInstance: boolean, msg: NFTEndpoint): TNFTEndpoint;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: NFTEndpoint, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): NFTEndpoint;
  static deserializeBinaryFromReader(message: NFTEndpoint, reader: jspb.BinaryReader): NFTEndpoint;
}

export type TNFTEndpoint = {
  id: string,
  scope: string,
}

export class NFTDisplay extends jspb.Message {
  getType(): string;
  setType(value: string): void;

  getContent(): string;
  setContent(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TNFTDisplay;
  static toObject(includeInstance: boolean, msg: NFTDisplay): TNFTDisplay;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: NFTDisplay, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): NFTDisplay;
  static deserializeBinaryFromReader(message: NFTDisplay, reader: jspb.BinaryReader): NFTDisplay;
}

export type TNFTDisplay = {
  type: string,
  content: string,
}

export class NFTIssuer extends jspb.Message {
  getId(): string;
  setId(value: string): void;

  getPk(): string;
  setPk(value: string): void;

  getName(): string;
  setName(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TNFTIssuer;
  static toObject(includeInstance: boolean, msg: NFTIssuer): TNFTIssuer;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: NFTIssuer, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): NFTIssuer;
  static deserializeBinaryFromReader(message: NFTIssuer, reader: jspb.BinaryReader): NFTIssuer;
}

export type TNFTIssuer = {
  id: string,
  pk: string,
  name: string,
}

export class AssetFactoryHook extends jspb.Message {
  getName(): string;
  setName(value: string): void;

  getType(): string;
  setType(value: string): void;

  getHook(): string;
  setHook(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TAssetFactoryHook;
  static toObject(includeInstance: boolean, msg: AssetFactoryHook): TAssetFactoryHook;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: AssetFactoryHook, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): AssetFactoryHook;
  static deserializeBinaryFromReader(message: AssetFactoryHook, reader: jspb.BinaryReader): AssetFactoryHook;
}

export type TAssetFactoryHook = {
  name: string,
  type: string,
  hook: string,
}

export class IndexedTokenInput extends jspb.Message {
  getAddress(): string;
  setAddress(value: string): void;

  getValue(): string;
  setValue(value: string): void;

  getDecimal(): number;
  setDecimal(value: number): void;

  getUnit(): string;
  setUnit(value: string): void;

  getSymbol(): string;
  setSymbol(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TIndexedTokenInput;
  static toObject(includeInstance: boolean, msg: IndexedTokenInput): TIndexedTokenInput;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: IndexedTokenInput, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): IndexedTokenInput;
  static deserializeBinaryFromReader(message: IndexedTokenInput, reader: jspb.BinaryReader): IndexedTokenInput;
}

export type TIndexedTokenInput = {
  address: string,
  value: string,
  decimal: number,
  unit: string,
  symbol: string,
}

export class IndexedFactoryInput extends jspb.Message {
  getValue(): string;
  setValue(value: string): void;

  clearTokensList(): void;
  getTokensList(): Array<TIndexedTokenInput>;
  setTokensList(value: Array<TIndexedTokenInput>): void;
  addTokens(value?: IndexedTokenInput, index?: number): IndexedTokenInput;

  clearAssetsList(): void;
  getAssetsList(): Array<string>;
  setAssetsList(value: Array<string>): void;
  addAssets(value: string, index?: number): string;

  clearVariablesList(): void;
  getVariablesList(): Array<TVariableInput>;
  setVariablesList(value: Array<TVariableInput>): void;
  addVariables(value?: VariableInput, index?: number): VariableInput;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TIndexedFactoryInput;
  static toObject(includeInstance: boolean, msg: IndexedFactoryInput): TIndexedFactoryInput;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: IndexedFactoryInput, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): IndexedFactoryInput;
  static deserializeBinaryFromReader(message: IndexedFactoryInput, reader: jspb.BinaryReader): IndexedFactoryInput;
}

export type TIndexedFactoryInput = {
  value: string,
  tokens: Array<TIndexedTokenInput>,
  assets: Array<string>,
  variables: Array<TVariableInput>,
}

export class RollupValidator extends jspb.Message {
  getPk(): string;
  setPk(value: string): void;

  getAddress(): string;
  setAddress(value: string): void;

  getEndpoint(): string;
  setEndpoint(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TRollupValidator;
  static toObject(includeInstance: boolean, msg: RollupValidator): TRollupValidator;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: RollupValidator, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): RollupValidator;
  static deserializeBinaryFromReader(message: RollupValidator, reader: jspb.BinaryReader): RollupValidator;
}

export type TRollupValidator = {
  pk: string,
  address: string,
  endpoint: string,
}

export class RollupSignature extends jspb.Message {
  getSigner(): string;
  setSigner(value: string): void;

  getSignature(): string;
  setSignature(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TRollupSignature;
  static toObject(includeInstance: boolean, msg: RollupSignature): TRollupSignature;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: RollupSignature, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): RollupSignature;
  static deserializeBinaryFromReader(message: RollupSignature, reader: jspb.BinaryReader): RollupSignature;
}

export type TRollupSignature = {
  signer: string,
  signature: string,
}

export class ForeignToken extends jspb.Message {
  getType(): string;
  setType(value: string): void;

  getContractAddress(): string;
  setContractAddress(value: string): void;

  getChainType(): string;
  setChainType(value: string): void;

  getChainName(): string;
  setChainName(value: string): void;

  getChainId(): number;
  setChainId(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TForeignToken;
  static toObject(includeInstance: boolean, msg: ForeignToken): TForeignToken;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ForeignToken, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ForeignToken;
  static deserializeBinaryFromReader(message: ForeignToken, reader: jspb.BinaryReader): ForeignToken;
}

export type TForeignToken = {
  type: string,
  contractAddress: string,
  chainType: string,
  chainName: string,
  chainId: number,
}

export class RevokedStake extends jspb.Message {
  clearTokensList(): void;
  getTokensList(): Array<TTokenInput>;
  setTokensList(value: Array<TTokenInput>): void;
  addTokens(value?: TokenInput, index?: number): TokenInput;

  clearAssetsList(): void;
  getAssetsList(): Array<string>;
  setAssetsList(value: Array<string>): void;
  addAssets(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TRevokedStake;
  static toObject(includeInstance: boolean, msg: RevokedStake): TRevokedStake;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: RevokedStake, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): RevokedStake;
  static deserializeBinaryFromReader(message: RevokedStake, reader: jspb.BinaryReader): RevokedStake;
}

export type TRevokedStake = {
  tokens: Array<TTokenInput>,
  assets: Array<string>,
}

export class ForgeStats extends jspb.Message {
  clearNumBlocksList(): void;
  getNumBlocksList(): Array<string>;
  setNumBlocksList(value: Array<string>): void;
  addNumBlocks(value: string, index?: number): string;

  clearNumTxsList(): void;
  getNumTxsList(): Array<string>;
  setNumTxsList(value: Array<string>): void;
  addNumTxs(value: string, index?: number): string;

  clearNumStakesList(): void;
  getNumStakesList(): Array<TBigUint>;
  setNumStakesList(value: Array<TBigUint>): void;
  addNumStakes(value?: BigUint, index?: number): BigUint;

  clearNumValidatorsList(): void;
  getNumValidatorsList(): Array<number>;
  setNumValidatorsList(value: Array<number>): void;
  addNumValidators(value: number, index?: number): number;

  clearNumAccountMigrateTxsList(): void;
  getNumAccountMigrateTxsList(): Array<string>;
  setNumAccountMigrateTxsList(value: Array<string>): void;
  addNumAccountMigrateTxs(value: string, index?: number): string;

  clearNumCreateAssetTxsList(): void;
  getNumCreateAssetTxsList(): Array<string>;
  setNumCreateAssetTxsList(value: Array<string>): void;
  addNumCreateAssetTxs(value: string, index?: number): string;

  clearNumConsensusUpgradeTxsList(): void;
  getNumConsensusUpgradeTxsList(): Array<number>;
  setNumConsensusUpgradeTxsList(value: Array<number>): void;
  addNumConsensusUpgradeTxs(value: number, index?: number): number;

  clearNumDeclareTxsList(): void;
  getNumDeclareTxsList(): Array<string>;
  setNumDeclareTxsList(value: Array<string>): void;
  addNumDeclareTxs(value: string, index?: number): string;

  clearNumDeclareFileTxsList(): void;
  getNumDeclareFileTxsList(): Array<string>;
  setNumDeclareFileTxsList(value: Array<string>): void;
  addNumDeclareFileTxs(value: string, index?: number): string;

  clearNumExchangeTxsList(): void;
  getNumExchangeTxsList(): Array<string>;
  setNumExchangeTxsList(value: Array<string>): void;
  addNumExchangeTxs(value: string, index?: number): string;

  clearNumStakeTxsList(): void;
  getNumStakeTxsList(): Array<string>;
  setNumStakeTxsList(value: Array<string>): void;
  addNumStakeTxs(value: string, index?: number): string;

  clearNumSysUpgradeTxsList(): void;
  getNumSysUpgradeTxsList(): Array<number>;
  setNumSysUpgradeTxsList(value: Array<number>): void;
  addNumSysUpgradeTxs(value: number, index?: number): number;

  clearNumTransferTxsList(): void;
  getNumTransferTxsList(): Array<string>;
  setNumTransferTxsList(value: Array<string>): void;
  addNumTransferTxs(value: string, index?: number): string;

  clearNumUpdateAssetTxsList(): void;
  getNumUpdateAssetTxsList(): Array<string>;
  setNumUpdateAssetTxsList(value: Array<string>): void;
  addNumUpdateAssetTxs(value: string, index?: number): string;

  clearNumConsumeAssetTxsList(): void;
  getNumConsumeAssetTxsList(): Array<string>;
  setNumConsumeAssetTxsList(value: Array<string>): void;
  addNumConsumeAssetTxs(value: string, index?: number): string;

  clearTpsList(): void;
  getTpsList(): Array<number>;
  setTpsList(value: Array<number>): void;
  addTps(value: number, index?: number): number;

  getMaxTps(): number;
  setMaxTps(value: number): void;

  getAvgTps(): number;
  setAvgTps(value: number): void;

  getAvgBlockTime(): number;
  setAvgBlockTime(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TForgeStats;
  static toObject(includeInstance: boolean, msg: ForgeStats): TForgeStats;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ForgeStats, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ForgeStats;
  static deserializeBinaryFromReader(message: ForgeStats, reader: jspb.BinaryReader): ForgeStats;
}

export type TForgeStats = {
  numBlocks: Array<string>,
  numTxs: Array<string>,
  numStakes: Array<TBigUint>,
  numValidators: Array<number>,
  numAccountMigrateTxs: Array<string>,
  numCreateAssetTxs: Array<string>,
  numConsensusUpgradeTxs: Array<number>,
  numDeclareTxs: Array<string>,
  numDeclareFileTxs: Array<string>,
  numExchangeTxs: Array<string>,
  numStakeTxs: Array<string>,
  numSysUpgradeTxs: Array<number>,
  numTransferTxs: Array<string>,
  numUpdateAssetTxs: Array<string>,
  numConsumeAssetTxs: Array<string>,
  tps: Array<number>,
  maxTps: number,
  avgTps: number,
  avgBlockTime: number,
}

export class GasEstimate extends jspb.Message {
  getMax(): string;
  setMax(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TGasEstimate;
  static toObject(includeInstance: boolean, msg: GasEstimate): TGasEstimate;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GasEstimate, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GasEstimate;
  static deserializeBinaryFromReader(message: GasEstimate, reader: jspb.BinaryReader): GasEstimate;
}

export type TGasEstimate = {
  max: string,
}

