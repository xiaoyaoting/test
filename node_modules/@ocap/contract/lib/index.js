/* eslint-disable no-restricted-syntax */
const get = require('lodash/get');
const set = require('lodash/set');
const esprima = require('esprima');
const { types } = require('@ocap/mcrypto');
const { BN } = require('@ocap/util');
const { isValid, toTypeInfo } = require('@arcblock/did');

const isCallExpression = (x) =>
  x.type === 'ExpressionStatement' && x.expression && x.expression.type === 'CallExpression';

const ZERO = new BN('0');

const SUPPORTED_CALLS = {
  // used to transfer primary token to someone
  transfer: {
    args: [
      {
        type: 'Literal',
        name: 'to',
      },
      {
        type: 'Literal',
        name: 'amount',
      },
    ],
  },
  // used to transfer secondary token to someone
  transferToken: {
    args: [
      {
        type: 'Literal',
        name: 'tokenAddress',
      },
      {
        type: 'Literal',
        name: 'to',
      },
      {
        type: 'Literal',
        name: 'amount',
      },
    ],
  },
};

/**
 * Try to compile contract source code and return call set
 *
 * @param {string} source
 * @return {array} list of parsed contract call and its args
 * @throws {Error} for invalid contract or args
 */
const compile = (source) => {
  if (typeof source !== 'string' || !source) {
    throw new Error('contract source must be a non-empty string');
  }

  try {
    const { body } = esprima.parseScript(source);
    if (body.every((x) => isCallExpression(x)) === false) {
      throw new Error('only function call expressions are allowed');
    }

    const result = [];

    const expressions = body.map((x) => x.expression);
    const allowedCalls = Object.keys(SUPPORTED_CALLS);
    for (const expression of expressions) {
      const name = get(expression, 'callee.name');
      if (allowedCalls.includes(name) === false) {
        throw new Error(`unrecognized call ${name}`);
      }

      const expectedArgs = SUPPORTED_CALLS[name].args;
      const actualArgs = expression.arguments;
      const expectedArgCount = expectedArgs.length;
      const actualArgCount = actualArgs.length;
      if (actualArgCount !== expectedArgCount) {
        throw new Error(
          `invalid number of arguments for ${name}, expected ${expectedArgCount}, but found ${actualArgCount}`
        );
      }

      for (let i = 0; i < expectedArgs.length; i++) {
        const expectedArg = expectedArgs[i];
        const actualArg = actualArgs[i];
        if (expectedArg.type !== actualArg.type) {
          throw new Error(
            `invalid #${i + 1} argument for ${name}, expected ${expectedArg.type}, but found ${actualArg.type}`
          );
        }
      }

      result.push({
        call: name,
        args: expectedArgs.reduce((acc, x, i) => {
          acc[x.name] = actualArgs[i].value;
          return acc;
        }, {}),
      });
    }

    if (result.length === 0) {
      throw new Error('compiled contract result is empty');
    }

    return result;
  } catch (err) {
    throw new Error(`Invalid contract source: ${err.message}`);
  }
};

const validateDid = (to, allowedRoleTypes) => {
  if (isValid(to) === false) {
    throw new Error('invalid did');
  }

  const type = toTypeInfo(to);
  if (allowedRoleTypes.includes(type.role) === false) {
    throw new Error('invalid did role type');
  }

  return true;
};

const validateAmount = (amount) => {
  let bn = null;
  try {
    bn = new BN(amount);
  } catch (err) {
    throw new Error(`invalid amount: ${err.message}`);
  }

  if (bn.toString() !== amount) {
    throw new Error('invalid amount: not valid big number');
  }

  return bn;
};

/**
 * Validate the compiled contract source
 *
 * @param {Array} compiled contract call list
 * @param {object} quota { value, tokens: { [address]: value }}
 * @return {boolean}
 */
const validate = (compiled, quota, ensureZeroSum = false) => {
  if (!Array.isArray(compiled) || compiled.length === 0) {
    throw new Error('no contract calls to validate');
  }

  // Since QLDB's max batch size is 40, each contract call will update 1 account
  // We need to set a smaller hard limit to avoid QLDB errors
  if (compiled.length > 30) {
    throw new Error('too much contract calls found, max is 15');
  }

  // to track consumption
  let remaining = new BN(quota ? quota.value : '0');
  const tokenRemaining = Object.keys(quota && quota.tokens ? quota.tokens : {}).reduce((acc, x) => {
    acc[x] = new BN(quota.tokens[x]);
    return acc;
  }, {});

  for (const item of compiled) {
    const { call, args } = item;
    if (call === 'transfer') {
      validateDid(args.to, [types.RoleType.ROLE_APPLICATION, types.RoleType.ROLE_ACCOUNT]);
      const consumption = validateAmount(args.amount);
      if (consumption.lte(ZERO)) {
        throw new Error('transfer amount must be greater than 0');
      }
      if (quota) {
        if (remaining.sub(consumption).isNeg()) {
          throw new Error('transfer exceeded quota');
        }
        remaining = remaining.sub(consumption);
      }
    } else if (call === 'transferToken') {
      validateDid(args.tokenAddress, [types.RoleType.ROLE_TOKEN]);
      validateDid(args.to, [types.RoleType.ROLE_APPLICATION, types.RoleType.ROLE_ACCOUNT]);

      const token = args.tokenAddress;
      const consumption = validateAmount(args.amount);
      if (consumption.lte(ZERO)) {
        throw new Error('token transfer amount must be greater than 0');
      }
      if (quota) {
        if (!tokenRemaining[token] || tokenRemaining[token].sub(consumption).isNeg()) {
          throw new Error(`transferToken for ${args.tokenAddress} exceeded quota`);
        }

        tokenRemaining[token] = tokenRemaining[token].sub(consumption);
      }
    }
  }

  if (ensureZeroSum) {
    if (remaining.isZero() === false) {
      throw new Error('transfer violates zero sum');
    }
    const invalidToken = Object.keys(tokenRemaining).find((x) => tokenRemaining[x].isZero() === false);
    if (invalidToken) {
      throw new Error(`transferToken for ${invalidToken} violates zero sum`);
    }
  }

  return true;
};

// merge duplicate receiver transfers if they exist
const merge = (compiled) => {
  const mergeAndSum = (items, uniqKey, sumBy) => {
    const result = {};
    const keys = Array.isArray(uniqKey) ? uniqKey : [uniqKey];
    keys.sort();
    for (const item of items) {
      const key = keys.map((x) => get(item, x)).join('-');
      if (result[key] === undefined) {
        result[key] = item;
      } else {
        const old = new BN(get(result[key], sumBy));
        const delta = new BN(get(item, sumBy));
        set(result[key], sumBy, old.add(delta).toString());
      }
    }

    return Object.values(result);
  };

  return [
    ...mergeAndSum(
      compiled.filter((x) => x.call === 'transfer'),
      'args.to',
      'args.amount'
    ),
    ...mergeAndSum(
      compiled.filter((x) => x.call === 'transferToken'),
      ['args.tokenAddress', 'args.to'],
      'args.amount'
    ),
  ];
};

const getQuota = (input = {}) => ({
  value: input.value || '0',
  tokens: (input.tokens || []).reduce((acc, x) => {
    acc[x.address] = x.value;
    return acc;
  }, {}),
});

module.exports = { compile, validate, merge, getQuota, SUPPORTED_CALLS };
