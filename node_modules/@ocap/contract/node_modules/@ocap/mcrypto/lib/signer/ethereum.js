"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthereumSigner = void 0;
/* eslint-disable @typescript-eslint/ban-ts-comment */
// @ts-ignore
const account_1 = __importDefault(require("eth-lib/lib/account"));
// @ts-ignore
const hash_1 = __importDefault(require("eth-lib/lib/hash"));
const util_1 = require("@ocap/util");
const secp256k1_1 = require("./secp256k1");
/**
 * Signer implementation for secp256k1, based on `elliptic`, and ethereum compatible
 *
 * @class EthereumSigner
 */
class EthereumSigner extends secp256k1_1.Secp256k1Signer {
    constructor() {
        super();
        this.pkHasFormatPrefix = false;
    }
    ethHash(data) {
        const messageHex = (0, util_1.isHexStrict)(data) ? data : (0, util_1.utf8ToHex)(data);
        const messageBytes = (0, util_1.hexToBytes)(messageHex);
        const messageBuffer = Buffer.from(messageBytes);
        const preamble = `\x19Ethereum Signed Message:\n${messageBytes.length}`;
        const preambleBuffer = Buffer.from(preamble);
        const ethMessage = Buffer.concat([preambleBuffer, messageBuffer]);
        return hash_1.default.keccak256s(ethMessage);
    }
    ethSign(data, privateKey) {
        return account_1.default.sign(data, privateKey);
    }
    ethRecover(data, signature) {
        return account_1.default.recover(data, signature);
    }
}
exports.EthereumSigner = EthereumSigner;
exports.default = new EthereumSigner();
