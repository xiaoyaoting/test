"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toTxHash = exports.Hashers = exports.Signers = exports.getRandomBytes = exports.getHasher = exports.getSigner = exports.types = exports.Hasher = exports.Signer = void 0;
const randombytes_1 = __importDefault(require("randombytes"));
const encode_1 = require("./encode");
const keccak_1 = __importDefault(require("./hasher/keccak"));
const sha2_1 = __importDefault(require("./hasher/sha2"));
const sha3_1 = __importDefault(require("./hasher/sha3"));
const ed25519_1 = __importDefault(require("./signer/ed25519"));
const ethereum_1 = __importDefault(require("./signer/ethereum"));
const secp256k1_1 = __importDefault(require("./signer/secp256k1"));
/**
 * Contains all supported signers, eg: `Ed25519` and `Secp256k1`
 *
 * @readonly
 * @type {object}
 * @name Signer
 * @static
 * @example
 * const { Signer } = require('@ocap/mcrypto');
 * const message = 'some message to sign';
 *
 * // Use Signer directly
 * const keyPair = Signer.Ed25519.genKeyPair();
 * const signature = Signer.Ed25519.sign(message, keyPair.secretKey);
 * const result = Signer.Ed25519.verify(message, signature, keyPair.publicKey);
 * assert.ok(result);
 */
exports.Signer = {
    Ed25519: ed25519_1.default,
    Secp256k1: secp256k1_1.default,
    Ethereum: ethereum_1.default,
};
/**
 * Contains all supported hasher, eg: `SHA2`,`SHA3` and `Keccak`, each of them supports `hash224`, `hash256`, `hash384`, `hash512`
 *
 * @readonly
 * @type {object}
 * @name Hasher
 * @static
 * @example
 * const { Hasher } = require('@ocap/mcrypto');
 *
 * const message = 'message to hash';
 * const hash = Hasher.SHA2.hash256(message);
 */
exports.Hasher = {
    SHA2: sha2_1.default,
    SHA3: sha3_1.default,
    Keccak: keccak_1.default,
};
/**
 * Contains type constants that represent can be used to compose different crypto method, each crypto method consist one of:
 * FIXME: enum definition of forge-abi and abt-did-elixir are not exactly the same
 *
 * @readonly
 * @type {object}
 * @name types
 * @static
 * @example
 * const { types } = require('@ocap/mcrypto');
 *
 * // types.RoleType.ROLE_ACCOUNT
 * // types.KeyType.ED25519
 * // types.HashType.SHA3
 * // types.EncodingType.BASE58
 */
exports.types = {
    /**
     * Key-pair derivation algorithms
     *
     * @readonly
     * @enum {number}
     * @name types.KeyType
     * @memberof types
     * @static
     */
    KeyType: {
        ED25519: 0,
        SECP256K1: 1,
        ETHEREUM: 2,
    },
    /**
     * Hashing algorithms
     *
     * @readonly
     * @enum {number}
     * @name types.HashType
     * @memberof types
     * @static
     */
    HashType: {
        KECCAK: 0,
        SHA3: 1,
        KECCAK_384: 2,
        SHA3_384: 3,
        KECCAK_512: 4,
        SHA3_512: 5,
        SHA2: 6,
    },
    /**
     * DID wallet role type
     *
     * @readonly
     * @enum {number}
     * @name types.RoleType
     * @memberof types
     * @static
     */
    RoleType: {
        ROLE_ACCOUNT: 0,
        ROLE_NODE: 1,
        ROLE_DEVICE: 2,
        ROLE_APPLICATION: 3,
        ROLE_SMART_CONTRACT: 4,
        ROLE_BOT: 5,
        ROLE_ASSET: 6,
        ROLE_STAKE: 7,
        ROLE_VALIDATOR: 8,
        ROLE_GROUP: 9,
        ROLE_TX: 10,
        ROLE_TETHER: 11,
        ROLE_SWAP: 12,
        ROLE_DELEGATION: 13,
        ROLE_VC: 14,
        ROLE_BLOCKLET: 15,
        ROLE_STORE: 16,
        ROLE_TOKEN: 17,
        ROLE_FACTORY: 18,
        ROLE_ROLLUP: 19,
        ROLE_STORAGE: 20,
        ROLE_ANY: 63,
    },
    /**
     * Address encoding algorithm, defaults to `base58btc`
     *
     * @readonly
     * @enum {number}
     * @name types.RoleType
     * @memberof types
     * @static
     */
    EncodingType: {
        BASE16: 0,
        BASE58: 1,
    },
};
/**
 * Get signer instance
 *
 * @function
 * @param {number} type - algorithm used to derive key pair, possible values are
 * - types.KeyType.ED25519
 * - types.KeyType.SECP256k1
 * - types.KeyType.ETHEREUM
 * @returns {object} signer instance
 * @example
 * const { getSigner, types } = require('@ocap/mcrypto');
 * const message = 'some message to sign';
 *
 * const signer = getSigner(types.KeyType.ED25519);
 * const keyPair1 = signer.genKeyPair();
 * const signature1 = signer.sign(message, keyPair1.secretKey);
 * const result1 = signer.verify(message, signature1, keyPair1.publicKey);
 * assert.ok(result1);
 */
function getSigner(type) {
    if (typeof exports.Signers[type] === 'undefined') {
        throw new Error(`Unsupported signer type: ${type}`);
    }
    // @ts-ignore
    return exports.Signers[type];
}
exports.getSigner = getSigner;
/**
 * Get hasher instance
 *
 * @function
 * @param {number} type - algorithm used to hash data, possible values
 * - types.HashType.KECCAK
 * - types.HashType.KECCAK_384
 * - types.HashType.KECCAK_512
 * - types.HashType.SHA3
 * - types.HashType.SHA3_384
 * - types.HashType.SHA3_512
 * @returns {object} hasher instance
 * @example
 * const { getHasher, types } = require('@ocap/mcrypto');
 *
 * const hashFn = getHasher(types.HashType.SHA3);
 * const hash2 = hashFn(message);
 */
function getHasher(type) {
    if (typeof exports.Hashers[type] === 'undefined') {
        throw new Error(`Unsupported hash type: ${type}`);
    }
    // @ts-ignore
    return exports.Hashers[type];
}
exports.getHasher = getHasher;
function getRandomBytes(length = 32, encoding = 'hex') {
    return (0, encode_1.encode)((0, randombytes_1.default)(length), encoding);
}
exports.getRandomBytes = getRandomBytes;
exports.Signers = Object.freeze({
    [exports.types.KeyType.ED25519]: exports.Signer.Ed25519,
    [exports.types.KeyType.SECP256K1]: exports.Signer.Secp256k1,
    [exports.types.KeyType.ETHEREUM]: exports.Signer.Ethereum,
});
exports.Hashers = Object.freeze({
    [exports.types.HashType.KECCAK]: exports.Hasher.Keccak.hash256,
    [exports.types.HashType.KECCAK_384]: exports.Hasher.Keccak.hash384,
    [exports.types.HashType.KECCAK_512]: exports.Hasher.Keccak.hash512,
    [exports.types.HashType.SHA3]: exports.Hasher.SHA3.hash256,
    [exports.types.HashType.SHA3_384]: exports.Hasher.SHA3.hash384,
    [exports.types.HashType.SHA3_512]: exports.Hasher.SHA3.hash512,
    [exports.types.HashType.SHA2]: exports.Hasher.SHA2.hash256,
});
const toTxHash = (buf) => exports.Hasher.SHA2.hash256(buf, 1, 'hex').replace(/^0x/, '').toUpperCase();
exports.toTxHash = toTxHash;
