"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ed25519Signer = void 0;
/* eslint-disable @typescript-eslint/no-useless-constructor */
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const randombytes_1 = __importDefault(require("randombytes"));
const util_1 = require("@ocap/util");
const signer_1 = __importDefault(require("../protocols/signer"));
const encode_1 = require("../encode");
const ed25519 = tweetnacl_1.default.sign;
/**
 * Signer implementation for ed25519, based on `tweetnacl`
 *
 * @class Ed25519Signer
 */
class Ed25519Signer extends signer_1.default {
    constructor() {
        super();
    }
    /**
     * @public
     * @typedefKeyPairType
     * @prop {string} publicKey - publicKey in hex format
     * @prop {string} secretKey - secretKey in hex format
     * @memberof Ed25519Signer
     */
    /**
     * Generate random secret/public key pair
     *
     * @param {Buffer|Uint8Array} [userSeed=undefined]
     * @param {string} [encoding='hex']
     * @returns {KeyPairType}
     * @memberof Ed25519Signer
     */
    genKeyPair(encoding = 'hex', userSeed) {
        const seed = userSeed ? (0, util_1.toUint8Array)(userSeed) : new Uint8Array((0, randombytes_1.default)(32));
        if (seed.byteLength !== 32) {
            throw new Error('Invalid seed to generate key pair');
        }
        const keyPair = ed25519.keyPair.fromSeed(seed);
        keyPair.publicKey = (0, encode_1.encode)(keyPair.publicKey, encoding);
        keyPair.secretKey = (0, encode_1.encode)(keyPair.secretKey, encoding);
        return keyPair;
    }
    /**
     * Get publicKey from secretKey
     *
     * @param {hex|buffer|base58|Uint8Array} sk - can be either a hex encoded string or a buffer
     * @returns {string} hex encoded publicKey
     */
    getPublicKey(sk, encoding = 'hex') {
        const skBytes = (0, util_1.toUint8Array)(sk);
        const pk = ed25519.keyPair.fromSecretKey(skBytes).publicKey;
        return (0, encode_1.encode)(pk, encoding);
    }
    /**
     * Sign a message and get the signature hex
     *
     * @param {hex|base58|buffer|Uint8Array} message
     * @param {hex|base58|buffer|Uint8Array} sk
     * @returns {string} hex encoded signature
     */
    sign(message, sk, encoding = 'hex') {
        const skBytes = (0, util_1.toUint8Array)(sk);
        const messageBytes = (0, util_1.toUint8Array)(message);
        const signature = ed25519.detached(messageBytes, skBytes);
        return (0, encode_1.encode)(signature, encoding);
    }
    /**
     * Verify if a signature is valid
     *
     * @param {string|buffer} message
     * @param {string|buffer} signature
     * @param {string|buffer} pk
     * @returns {bool}
     */
    verify(message, signature, pk) {
        const pkBytes = (0, util_1.toUint8Array)(pk);
        const messageBytes = (0, util_1.toUint8Array)(message);
        const signatureBytes = (0, util_1.toUint8Array)(signature);
        return ed25519.detached.verify(messageBytes, signatureBytes, pkBytes);
    }
}
exports.Ed25519Signer = Ed25519Signer;
exports.default = new Ed25519Signer();
