// package: ocap
// file: trace-type.proto

import * as jspb from "google-protobuf";
import * as google_protobuf_any_pb from "google-protobuf/google/protobuf/any_pb";
import * as type_pb from "./type_pb";
import * as enum_pb from "./enum_pb";
import * as tx_pb from "./tx_pb";

export class PageOrder extends jspb.Message {
  getField(): string;
  setField(value: string): void;

  getType(): string;
  setType(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TPageOrder;
  static toObject(includeInstance: boolean, msg: PageOrder): TPageOrder;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PageOrder, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PageOrder;
  static deserializeBinaryFromReader(message: PageOrder, reader: jspb.BinaryReader): PageOrder;
}

export type TPageOrder = {
  field: string,
  type: string,
}

export class Page extends jspb.Message {
  getCursor(): string;
  setCursor(value: string): void;

  getSize(): number;
  setSize(value: number): void;

  clearOrderList(): void;
  getOrderList(): Array<TPageOrder>;
  setOrderList(value: Array<TPageOrder>): void;
  addOrder(value?: PageOrder, index?: number): PageOrder;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TPage;
  static toObject(includeInstance: boolean, msg: Page): TPage;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Page, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Page;
  static deserializeBinaryFromReader(message: Page, reader: jspb.BinaryReader): Page;
}

export type TPage = {
  cursor: string,
  size: number,
  order: Array<TPageOrder>,
}

export class TypeFilter extends jspb.Message {
  clearTypesList(): void;
  getTypesList(): Array<string>;
  setTypesList(value: Array<string>): void;
  addTypes(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TTypeFilter;
  static toObject(includeInstance: boolean, msg: TypeFilter): TTypeFilter;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TypeFilter, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TypeFilter;
  static deserializeBinaryFromReader(message: TypeFilter, reader: jspb.BinaryReader): TypeFilter;
}

export type TTypeFilter = {
  types: Array<string>,
}

export class AssetFilter extends jspb.Message {
  clearAssetsList(): void;
  getAssetsList(): Array<string>;
  setAssetsList(value: Array<string>): void;
  addAssets(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TAssetFilter;
  static toObject(includeInstance: boolean, msg: AssetFilter): TAssetFilter;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: AssetFilter, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): AssetFilter;
  static deserializeBinaryFromReader(message: AssetFilter, reader: jspb.BinaryReader): AssetFilter;
}

export type TAssetFilter = {
  assets: Array<string>,
}

export class FactoryFilter extends jspb.Message {
  clearFactoriesList(): void;
  getFactoriesList(): Array<string>;
  setFactoriesList(value: Array<string>): void;
  addFactories(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TFactoryFilter;
  static toObject(includeInstance: boolean, msg: FactoryFilter): TFactoryFilter;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FactoryFilter, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FactoryFilter;
  static deserializeBinaryFromReader(message: FactoryFilter, reader: jspb.BinaryReader): FactoryFilter;
}

export type TFactoryFilter = {
  factories: Array<string>,
}

export class TokenFilter extends jspb.Message {
  clearTokensList(): void;
  getTokensList(): Array<string>;
  setTokensList(value: Array<string>): void;
  addTokens(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TTokenFilter;
  static toObject(includeInstance: boolean, msg: TokenFilter): TTokenFilter;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TokenFilter, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TokenFilter;
  static deserializeBinaryFromReader(message: TokenFilter, reader: jspb.BinaryReader): TokenFilter;
}

export type TTokenFilter = {
  tokens: Array<string>,
}

export class StakeFilter extends jspb.Message {
  clearStakesList(): void;
  getStakesList(): Array<string>;
  setStakesList(value: Array<string>): void;
  addStakes(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TStakeFilter;
  static toObject(includeInstance: boolean, msg: StakeFilter): TStakeFilter;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: StakeFilter, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): StakeFilter;
  static deserializeBinaryFromReader(message: StakeFilter, reader: jspb.BinaryReader): StakeFilter;
}

export type TStakeFilter = {
  stakes: Array<string>,
}

export class AccountFilter extends jspb.Message {
  clearAccountsList(): void;
  getAccountsList(): Array<string>;
  setAccountsList(value: Array<string>): void;
  addAccounts(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TAccountFilter;
  static toObject(includeInstance: boolean, msg: AccountFilter): TAccountFilter;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: AccountFilter, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): AccountFilter;
  static deserializeBinaryFromReader(message: AccountFilter, reader: jspb.BinaryReader): AccountFilter;
}

export type TAccountFilter = {
  accounts: Array<string>,
}

export class TxFilter extends jspb.Message {
  clearTxsList(): void;
  getTxsList(): Array<string>;
  setTxsList(value: Array<string>): void;
  addTxs(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TTxFilter;
  static toObject(includeInstance: boolean, msg: TxFilter): TTxFilter;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TxFilter, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TxFilter;
  static deserializeBinaryFromReader(message: TxFilter, reader: jspb.BinaryReader): TxFilter;
}

export type TTxFilter = {
  txs: Array<string>,
}

export class RollupFilter extends jspb.Message {
  clearRollupsList(): void;
  getRollupsList(): Array<string>;
  setRollupsList(value: Array<string>): void;
  addRollups(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TRollupFilter;
  static toObject(includeInstance: boolean, msg: RollupFilter): TRollupFilter;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: RollupFilter, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): RollupFilter;
  static deserializeBinaryFromReader(message: RollupFilter, reader: jspb.BinaryReader): RollupFilter;
}

export type TRollupFilter = {
  rollups: Array<string>,
}

export class ValidatorFilter extends jspb.Message {
  clearValidatorsList(): void;
  getValidatorsList(): Array<string>;
  setValidatorsList(value: Array<string>): void;
  addValidators(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TValidatorFilter;
  static toObject(includeInstance: boolean, msg: ValidatorFilter): TValidatorFilter;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ValidatorFilter, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ValidatorFilter;
  static deserializeBinaryFromReader(message: ValidatorFilter, reader: jspb.BinaryReader): ValidatorFilter;
}

export type TValidatorFilter = {
  validators: Array<string>,
}

export class TimeFilter extends jspb.Message {
  getStartDateTime(): string;
  setStartDateTime(value: string): void;

  getEndDateTime(): string;
  setEndDateTime(value: string): void;

  getField(): string;
  setField(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TTimeFilter;
  static toObject(includeInstance: boolean, msg: TimeFilter): TTimeFilter;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TimeFilter, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TimeFilter;
  static deserializeBinaryFromReader(message: TimeFilter, reader: jspb.BinaryReader): TimeFilter;
}

export type TTimeFilter = {
  startDateTime: string,
  endDateTime: string,
  field: string,
}

export class AddressFilter extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getReceiver(): string;
  setReceiver(value: string): void;

  getDirection(): DirectionMap[keyof DirectionMap];
  setDirection(value: DirectionMap[keyof DirectionMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TAddressFilter;
  static toObject(includeInstance: boolean, msg: AddressFilter): TAddressFilter;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: AddressFilter, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): AddressFilter;
  static deserializeBinaryFromReader(message: AddressFilter, reader: jspb.BinaryReader): AddressFilter;
}

export type TAddressFilter = {
  sender: string,
  receiver: string,
  direction: DirectionMap[keyof DirectionMap],
}

export class PageInfo extends jspb.Message {
  getCursor(): string;
  setCursor(value: string): void;

  getNext(): boolean;
  setNext(value: boolean): void;

  getTotal(): number;
  setTotal(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TPageInfo;
  static toObject(includeInstance: boolean, msg: PageInfo): TPageInfo;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PageInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PageInfo;
  static deserializeBinaryFromReader(message: PageInfo, reader: jspb.BinaryReader): PageInfo;
}

export type TPageInfo = {
  cursor: string,
  next: boolean,
  total: number,
}

export class TokenInfo extends jspb.Message {
  getAddress(): string;
  setAddress(value: string): void;

  getBalance(): string;
  setBalance(value: string): void;

  getDecimal(): number;
  setDecimal(value: number): void;

  getUnit(): string;
  setUnit(value: string): void;

  getSymbol(): string;
  setSymbol(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TTokenInfo;
  static toObject(includeInstance: boolean, msg: TokenInfo): TTokenInfo;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TokenInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TokenInfo;
  static deserializeBinaryFromReader(message: TokenInfo, reader: jspb.BinaryReader): TokenInfo;
}

export type TTokenInfo = {
  address: string,
  balance: string,
  decimal: number,
  unit: string,
  symbol: string,
}

export class ValidityFilter extends jspb.Message {
  getValidity(): ValidityMap[keyof ValidityMap];
  setValidity(value: ValidityMap[keyof ValidityMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TValidityFilter;
  static toObject(includeInstance: boolean, msg: ValidityFilter): TValidityFilter;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ValidityFilter, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ValidityFilter;
  static deserializeBinaryFromReader(message: ValidityFilter, reader: jspb.BinaryReader): ValidityFilter;
}

export type TValidityFilter = {
  validity: ValidityMap[keyof ValidityMap],
}

export class RangeFilter extends jspb.Message {
  getFrom(): string;
  setFrom(value: string): void;

  getTo(): string;
  setTo(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TRangeFilter;
  static toObject(includeInstance: boolean, msg: RangeFilter): TRangeFilter;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: RangeFilter, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): RangeFilter;
  static deserializeBinaryFromReader(message: RangeFilter, reader: jspb.BinaryReader): RangeFilter;
}

export type TRangeFilter = {
  from: string,
  to: string,
}

export class AccountToken extends jspb.Message {
  getAddress(): string;
  setAddress(value: string): void;

  getSymbol(): string;
  setSymbol(value: string): void;

  getBalance(): string;
  setBalance(value: string): void;

  getDecimal(): number;
  setDecimal(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TAccountToken;
  static toObject(includeInstance: boolean, msg: AccountToken): TAccountToken;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: AccountToken, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): AccountToken;
  static deserializeBinaryFromReader(message: AccountToken, reader: jspb.BinaryReader): AccountToken;
}

export type TAccountToken = {
  address: string,
  symbol: string,
  balance: string,
  decimal: number,
}

export class ByDay extends jspb.Message {
  getStartDate(): string;
  setStartDate(value: string): void;

  getEndDate(): string;
  setEndDate(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TByDay;
  static toObject(includeInstance: boolean, msg: ByDay): TByDay;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ByDay, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ByDay;
  static deserializeBinaryFromReader(message: ByDay, reader: jspb.BinaryReader): ByDay;
}

export type TByDay = {
  startDate: string,
  endDate: string,
}

export class ByHour extends jspb.Message {
  getDate(): string;
  setDate(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TByHour;
  static toObject(includeInstance: boolean, msg: ByHour): TByHour;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ByHour, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ByHour;
  static deserializeBinaryFromReader(message: ByHour, reader: jspb.BinaryReader): ByHour;
}

export type TByHour = {
  date: string,
}

export class IndexedTransaction extends jspb.Message {
  getHash(): string;
  setHash(value: string): void;

  getSender(): string;
  setSender(value: string): void;

  getReceiver(): string;
  setReceiver(value: string): void;

  getTime(): string;
  setTime(value: string): void;

  getType(): string;
  setType(value: string): void;

  hasTx(): boolean;
  clearTx(): void;
  getTx(): type_pb.TTransaction | undefined;
  setTx(value?: type_pb.TTransaction): void;

  getValid(): boolean;
  setValid(value: boolean): void;

  getCode(): enum_pb.StatusCodeMap[keyof enum_pb.StatusCodeMap];
  setCode(value: enum_pb.StatusCodeMap[keyof enum_pb.StatusCodeMap]): void;

  clearTokenSymbolsList(): void;
  getTokenSymbolsList(): Array<type_pb.TTokenSymbol>;
  setTokenSymbolsList(value: Array<type_pb.TTokenSymbol>): void;
  addTokenSymbols(value?: type_pb.TokenSymbol, index?: number): type_pb.TokenSymbol;

  clearReceiptsList(): void;
  getReceiptsList(): Array<type_pb.TTransactionReceipt>;
  setReceiptsList(value: Array<type_pb.TTransactionReceipt>): void;
  addReceipts(value?: type_pb.TransactionReceipt, index?: number): type_pb.TransactionReceipt;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TIndexedTransaction;
  static toObject(includeInstance: boolean, msg: IndexedTransaction): TIndexedTransaction;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: IndexedTransaction, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): IndexedTransaction;
  static deserializeBinaryFromReader(message: IndexedTransaction, reader: jspb.BinaryReader): IndexedTransaction;
}

export type TIndexedTransaction = {
  hash: string,
  sender: string,
  receiver: string,
  time: string,
  type: string,
  tx?: type_pb.TTransaction,
  valid: boolean,
  code: enum_pb.StatusCodeMap[keyof enum_pb.StatusCodeMap],
  tokenSymbols: Array<type_pb.TTokenSymbol>,
  receipts: Array<type_pb.TTransactionReceipt>,
}

export class IndexedAccountState extends jspb.Message {
  getAddress(): string;
  setAddress(value: string): void;

  hasBalance(): boolean;
  clearBalance(): void;
  getBalance(): type_pb.TBigUint | undefined;
  setBalance(value?: type_pb.TBigUint): void;

  getNumAssets(): string;
  setNumAssets(value: string): void;

  getNumTxs(): string;
  setNumTxs(value: string): void;

  getNonce(): string;
  setNonce(value: string): void;

  getGenesisTime(): string;
  setGenesisTime(value: string): void;

  getRenaissanceTime(): string;
  setRenaissanceTime(value: string): void;

  getMoniker(): string;
  setMoniker(value: string): void;

  getMigratedFrom(): string;
  setMigratedFrom(value: string): void;

  getMigratedTo(): string;
  setMigratedTo(value: string): void;

  hasTotalReceivedStakes(): boolean;
  clearTotalReceivedStakes(): void;
  getTotalReceivedStakes(): type_pb.TBigUint | undefined;
  setTotalReceivedStakes(value?: type_pb.TBigUint): void;

  hasTotalStakes(): boolean;
  clearTotalStakes(): void;
  getTotalStakes(): type_pb.TBigUint | undefined;
  setTotalStakes(value?: type_pb.TBigUint): void;

  hasTotalUnstakes(): boolean;
  clearTotalUnstakes(): void;
  getTotalUnstakes(): type_pb.TBigUint | undefined;
  setTotalUnstakes(value?: type_pb.TBigUint): void;

  clearRecentNumTxsList(): void;
  getRecentNumTxsList(): Array<string>;
  setRecentNumTxsList(value: Array<string>): void;
  addRecentNumTxs(value: string, index?: number): string;

  clearTokensList(): void;
  getTokensList(): Array<TTokenInfo>;
  setTokensList(value: Array<TTokenInfo>): void;
  addTokens(value?: TokenInfo, index?: number): TokenInfo;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TIndexedAccountState;
  static toObject(includeInstance: boolean, msg: IndexedAccountState): TIndexedAccountState;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: IndexedAccountState, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): IndexedAccountState;
  static deserializeBinaryFromReader(message: IndexedAccountState, reader: jspb.BinaryReader): IndexedAccountState;
}

export type TIndexedAccountState = {
  address: string,
  balance?: type_pb.TBigUint,
  numAssets: string,
  numTxs: string,
  nonce: string,
  genesisTime: string,
  renaissanceTime: string,
  moniker: string,
  migratedFrom: string,
  migratedTo: string,
  totalReceivedStakes?: type_pb.TBigUint,
  totalStakes?: type_pb.TBigUint,
  totalUnstakes?: type_pb.TBigUint,
  recentNumTxs: Array<string>,
  tokens: Array<TTokenInfo>,
}

export class IndexedAssetState extends jspb.Message {
  getAddress(): string;
  setAddress(value: string): void;

  getOwner(): string;
  setOwner(value: string): void;

  getGenesisTime(): string;
  setGenesisTime(value: string): void;

  getRenaissanceTime(): string;
  setRenaissanceTime(value: string): void;

  getMoniker(): string;
  setMoniker(value: string): void;

  getReadonly(): boolean;
  setReadonly(value: boolean): void;

  getConsumedTime(): string;
  setConsumedTime(value: string): void;

  getIssuer(): string;
  setIssuer(value: string): void;

  getParent(): string;
  setParent(value: string): void;

  getTransferrable(): boolean;
  setTransferrable(value: boolean): void;

  getTtl(): string;
  setTtl(value: string): void;

  hasDisplay(): boolean;
  clearDisplay(): void;
  getDisplay(): type_pb.TNFTDisplay | undefined;
  setDisplay(value?: type_pb.TNFTDisplay): void;

  hasEndpoint(): boolean;
  clearEndpoint(): void;
  getEndpoint(): type_pb.TNFTEndpoint | undefined;
  setEndpoint(value?: type_pb.TNFTEndpoint): void;

  clearTagsList(): void;
  getTagsList(): Array<string>;
  setTagsList(value: Array<string>): void;
  addTags(value: string, index?: number): string;

  hasData(): boolean;
  clearData(): void;
  getData(): google_protobuf_any_pb.Any | undefined;
  setData(value?: google_protobuf_any_pb.Any): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TIndexedAssetState;
  static toObject(includeInstance: boolean, msg: IndexedAssetState): TIndexedAssetState;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: IndexedAssetState, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): IndexedAssetState;
  static deserializeBinaryFromReader(message: IndexedAssetState, reader: jspb.BinaryReader): IndexedAssetState;
}

export type TIndexedAssetState = {
  address: string,
  owner: string,
  genesisTime: string,
  renaissanceTime: string,
  moniker: string,
  readonly: boolean,
  consumedTime: string,
  issuer: string,
  parent: string,
  transferrable: boolean,
  ttl: string,
  display?: type_pb.TNFTDisplay,
  endpoint?: type_pb.TNFTEndpoint,
  tags: Array<string>,
  data?: google_protobuf_any_pb.Any,
}

export class IndexedBlock extends jspb.Message {
  getHeight(): string;
  setHeight(value: string): void;

  getTime(): string;
  setTime(value: string): void;

  getProposer(): string;
  setProposer(value: string): void;

  getNumTxs(): string;
  setNumTxs(value: string): void;

  getNumInvalidTxs(): string;
  setNumInvalidTxs(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TIndexedBlock;
  static toObject(includeInstance: boolean, msg: IndexedBlock): TIndexedBlock;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: IndexedBlock, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): IndexedBlock;
  static deserializeBinaryFromReader(message: IndexedBlock, reader: jspb.BinaryReader): IndexedBlock;
}

export type TIndexedBlock = {
  height: string,
  time: string,
  proposer: string,
  numTxs: string,
  numInvalidTxs: string,
}

export class IndexedTokenState extends jspb.Message {
  getName(): string;
  setName(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  getSymbol(): string;
  setSymbol(value: string): void;

  getUnit(): string;
  setUnit(value: string): void;

  getDecimal(): number;
  setDecimal(value: number): void;

  getIssuer(): string;
  setIssuer(value: string): void;

  getIcon(): string;
  setIcon(value: string): void;

  getTotalSupply(): string;
  setTotalSupply(value: string): void;

  getAddress(): string;
  setAddress(value: string): void;

  getGenesisTime(): string;
  setGenesisTime(value: string): void;

  getRenaissanceTime(): string;
  setRenaissanceTime(value: string): void;

  hasForeignToken(): boolean;
  clearForeignToken(): void;
  getForeignToken(): type_pb.TForeignToken | undefined;
  setForeignToken(value?: type_pb.TForeignToken): void;

  hasData(): boolean;
  clearData(): void;
  getData(): google_protobuf_any_pb.Any | undefined;
  setData(value?: google_protobuf_any_pb.Any): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TIndexedTokenState;
  static toObject(includeInstance: boolean, msg: IndexedTokenState): TIndexedTokenState;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: IndexedTokenState, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): IndexedTokenState;
  static deserializeBinaryFromReader(message: IndexedTokenState, reader: jspb.BinaryReader): IndexedTokenState;
}

export type TIndexedTokenState = {
  name: string,
  description: string,
  symbol: string,
  unit: string,
  decimal: number,
  issuer: string,
  icon: string,
  totalSupply: string,
  address: string,
  genesisTime: string,
  renaissanceTime: string,
  foreignToken?: type_pb.TForeignToken,
  data?: google_protobuf_any_pb.Any,
}

export class IndexedFactoryState extends jspb.Message {
  getAddress(): string;
  setAddress(value: string): void;

  getOwner(): string;
  setOwner(value: string): void;

  getName(): string;
  setName(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  getSettlement(): string;
  setSettlement(value: string): void;

  getLimit(): string;
  setLimit(value: string): void;

  clearTrustedIssuersList(): void;
  getTrustedIssuersList(): Array<string>;
  setTrustedIssuersList(value: Array<string>): void;
  addTrustedIssuers(value: string, index?: number): string;

  hasInput(): boolean;
  clearInput(): void;
  getInput(): type_pb.TIndexedFactoryInput | undefined;
  setInput(value?: type_pb.TIndexedFactoryInput): void;

  hasOutput(): boolean;
  clearOutput(): void;
  getOutput(): tx_pb.TCreateAssetTx | undefined;
  setOutput(value?: tx_pb.TCreateAssetTx): void;

  clearHooksList(): void;
  getHooksList(): Array<type_pb.TAssetFactoryHook>;
  setHooksList(value: Array<type_pb.TAssetFactoryHook>): void;
  addHooks(value?: type_pb.AssetFactoryHook, index?: number): type_pb.AssetFactoryHook;

  hasData(): boolean;
  clearData(): void;
  getData(): google_protobuf_any_pb.Any | undefined;
  setData(value?: google_protobuf_any_pb.Any): void;

  getBalance(): string;
  setBalance(value: string): void;

  clearTokensList(): void;
  getTokensList(): Array<TTokenInfo>;
  setTokensList(value: Array<TTokenInfo>): void;
  addTokens(value?: TokenInfo, index?: number): TokenInfo;

  getNumMinted(): number;
  setNumMinted(value: number): void;

  getLastSettlement(): string;
  setLastSettlement(value: string): void;

  getGenesisTime(): string;
  setGenesisTime(value: string): void;

  getRenaissanceTime(): string;
  setRenaissanceTime(value: string): void;

  hasDisplay(): boolean;
  clearDisplay(): void;
  getDisplay(): type_pb.TNFTDisplay | undefined;
  setDisplay(value?: type_pb.TNFTDisplay): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TIndexedFactoryState;
  static toObject(includeInstance: boolean, msg: IndexedFactoryState): TIndexedFactoryState;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: IndexedFactoryState, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): IndexedFactoryState;
  static deserializeBinaryFromReader(message: IndexedFactoryState, reader: jspb.BinaryReader): IndexedFactoryState;
}

export type TIndexedFactoryState = {
  address: string,
  owner: string,
  name: string,
  description: string,
  settlement: string,
  limit: string,
  trustedIssuers: Array<string>,
  input?: type_pb.TIndexedFactoryInput,
  output?: tx_pb.TCreateAssetTx,
  hooks: Array<type_pb.TAssetFactoryHook>,
  data?: google_protobuf_any_pb.Any,
  balance: string,
  tokens: Array<TTokenInfo>,
  numMinted: number,
  lastSettlement: string,
  genesisTime: string,
  renaissanceTime: string,
  display?: type_pb.TNFTDisplay,
}

export class IndexedStakeState extends jspb.Message {
  getAddress(): string;
  setAddress(value: string): void;

  getSender(): string;
  setSender(value: string): void;

  getReceiver(): string;
  setReceiver(value: string): void;

  clearTokensList(): void;
  getTokensList(): Array<TTokenInfo>;
  setTokensList(value: Array<TTokenInfo>): void;
  addTokens(value?: TokenInfo, index?: number): TokenInfo;

  clearAssetsList(): void;
  getAssetsList(): Array<string>;
  setAssetsList(value: Array<string>): void;
  addAssets(value: string, index?: number): string;

  getRevocable(): boolean;
  setRevocable(value: boolean): void;

  getGenesisTime(): string;
  setGenesisTime(value: string): void;

  getRenaissanceTime(): string;
  setRenaissanceTime(value: string): void;

  getMessage(): string;
  setMessage(value: string): void;

  getRevokeWaitingPeriod(): number;
  setRevokeWaitingPeriod(value: number): void;

  clearRevokedTokensList(): void;
  getRevokedTokensList(): Array<TTokenInfo>;
  setRevokedTokensList(value: Array<TTokenInfo>): void;
  addRevokedTokens(value?: TokenInfo, index?: number): TokenInfo;

  clearRevokedAssetsList(): void;
  getRevokedAssetsList(): Array<string>;
  setRevokedAssetsList(value: Array<string>): void;
  addRevokedAssets(value: string, index?: number): string;

  clearSlashersList(): void;
  getSlashersList(): Array<string>;
  setSlashersList(value: Array<string>): void;
  addSlashers(value: string, index?: number): string;

  hasData(): boolean;
  clearData(): void;
  getData(): google_protobuf_any_pb.Any | undefined;
  setData(value?: google_protobuf_any_pb.Any): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TIndexedStakeState;
  static toObject(includeInstance: boolean, msg: IndexedStakeState): TIndexedStakeState;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: IndexedStakeState, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): IndexedStakeState;
  static deserializeBinaryFromReader(message: IndexedStakeState, reader: jspb.BinaryReader): IndexedStakeState;
}

export type TIndexedStakeState = {
  address: string,
  sender: string,
  receiver: string,
  tokens: Array<TTokenInfo>,
  assets: Array<string>,
  revocable: boolean,
  genesisTime: string,
  renaissanceTime: string,
  message: string,
  revokeWaitingPeriod: number,
  revokedTokens: Array<TTokenInfo>,
  revokedAssets: Array<string>,
  slashers: Array<string>,
  data?: google_protobuf_any_pb.Any,
}

export class IndexedRollupState extends jspb.Message {
  getAddress(): string;
  setAddress(value: string): void;

  getTokenAddress(): string;
  setTokenAddress(value: string): void;

  getVaultAddress(): string;
  setVaultAddress(value: string): void;

  getContractAddress(): string;
  setContractAddress(value: string): void;

  clearSeedValidatorsList(): void;
  getSeedValidatorsList(): Array<type_pb.TRollupValidator>;
  setSeedValidatorsList(value: Array<type_pb.TRollupValidator>): void;
  addSeedValidators(value?: type_pb.RollupValidator, index?: number): type_pb.RollupValidator;

  clearValidatorsList(): void;
  getValidatorsList(): Array<type_pb.TRollupValidator>;
  setValidatorsList(value: Array<type_pb.TRollupValidator>): void;
  addValidators(value?: type_pb.RollupValidator, index?: number): type_pb.RollupValidator;

  getMinStakeAmount(): string;
  setMinStakeAmount(value: string): void;

  getMaxStakeAmount(): string;
  setMaxStakeAmount(value: string): void;

  getMinSignerCount(): number;
  setMinSignerCount(value: number): void;

  getMaxSignerCount(): number;
  setMaxSignerCount(value: number): void;

  getMinBlockSize(): number;
  setMinBlockSize(value: number): void;

  getMaxBlockSize(): number;
  setMaxBlockSize(value: number): void;

  getMinBlockInterval(): number;
  setMinBlockInterval(value: number): void;

  getGenesisTime(): string;
  setGenesisTime(value: string): void;

  getRenaissanceTime(): string;
  setRenaissanceTime(value: string): void;

  hasTokenInfo(): boolean;
  clearTokenInfo(): void;
  getTokenInfo(): type_pb.TIndexedTokenInput | undefined;
  setTokenInfo(value?: type_pb.TIndexedTokenInput): void;

  getIssuer(): string;
  setIssuer(value: string): void;

  getDepositFeeRate(): number;
  setDepositFeeRate(value: number): void;

  getWithdrawFeeRate(): number;
  setWithdrawFeeRate(value: number): void;

  getProposerFeeShare(): number;
  setProposerFeeShare(value: number): void;

  getMinDepositAmount(): string;
  setMinDepositAmount(value: string): void;

  getMinWithdrawAmount(): string;
  setMinWithdrawAmount(value: string): void;

  getBlockHeight(): number;
  setBlockHeight(value: number): void;

  getBlockHash(): string;
  setBlockHash(value: string): void;

  getMinBlockConfirmation(): number;
  setMinBlockConfirmation(value: number): void;

  getTotalDepositAmount(): string;
  setTotalDepositAmount(value: string): void;

  getTotalWithdrawAmount(): string;
  setTotalWithdrawAmount(value: string): void;

  getMaxDepositAmount(): string;
  setMaxDepositAmount(value: string): void;

  getMaxWithdrawAmount(): string;
  setMaxWithdrawAmount(value: string): void;

  getMinDepositFee(): string;
  setMinDepositFee(value: string): void;

  getMaxDepositFee(): string;
  setMaxDepositFee(value: string): void;

  getMinWithdrawFee(): string;
  setMinWithdrawFee(value: string): void;

  getMaxWithdrawFee(): string;
  setMaxWithdrawFee(value: string): void;

  getPaused(): boolean;
  setPaused(value: boolean): void;

  hasForeignToken(): boolean;
  clearForeignToken(): void;
  getForeignToken(): type_pb.TForeignToken | undefined;
  setForeignToken(value?: type_pb.TForeignToken): void;

  getLeaveWaitingPeriod(): number;
  setLeaveWaitingPeriod(value: number): void;

  getPublisherFeeShare(): number;
  setPublisherFeeShare(value: number): void;

  getPublishWaitingPeriod(): number;
  setPublishWaitingPeriod(value: number): void;

  getPublishSlashRate(): number;
  setPublishSlashRate(value: number): void;

  clearMigrateHistoryList(): void;
  getMigrateHistoryList(): Array<string>;
  setMigrateHistoryList(value: Array<string>): void;
  addMigrateHistory(value: string, index?: number): string;

  getClosed(): boolean;
  setClosed(value: boolean): void;

  clearVaultHistoryList(): void;
  getVaultHistoryList(): Array<string>;
  setVaultHistoryList(value: Array<string>): void;
  addVaultHistory(value: string, index?: number): string;

  hasData(): boolean;
  clearData(): void;
  getData(): google_protobuf_any_pb.Any | undefined;
  setData(value?: google_protobuf_any_pb.Any): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TIndexedRollupState;
  static toObject(includeInstance: boolean, msg: IndexedRollupState): TIndexedRollupState;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: IndexedRollupState, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): IndexedRollupState;
  static deserializeBinaryFromReader(message: IndexedRollupState, reader: jspb.BinaryReader): IndexedRollupState;
}

export type TIndexedRollupState = {
  address: string,
  tokenAddress: string,
  vaultAddress: string,
  contractAddress: string,
  seedValidators: Array<type_pb.TRollupValidator>,
  validators: Array<type_pb.TRollupValidator>,
  minStakeAmount: string,
  maxStakeAmount: string,
  minSignerCount: number,
  maxSignerCount: number,
  minBlockSize: number,
  maxBlockSize: number,
  minBlockInterval: number,
  genesisTime: string,
  renaissanceTime: string,
  tokenInfo?: type_pb.TIndexedTokenInput,
  issuer: string,
  depositFeeRate: number,
  withdrawFeeRate: number,
  proposerFeeShare: number,
  minDepositAmount: string,
  minWithdrawAmount: string,
  blockHeight: number,
  blockHash: string,
  minBlockConfirmation: number,
  totalDepositAmount: string,
  totalWithdrawAmount: string,
  maxDepositAmount: string,
  maxWithdrawAmount: string,
  minDepositFee: string,
  maxDepositFee: string,
  minWithdrawFee: string,
  maxWithdrawFee: string,
  paused: boolean,
  foreignToken?: type_pb.TForeignToken,
  leaveWaitingPeriod: number,
  publisherFeeShare: number,
  publishWaitingPeriod: number,
  publishSlashRate: number,
  migrateHistory: Array<string>,
  closed: boolean,
  vaultHistory: Array<string>,
  data?: google_protobuf_any_pb.Any,
}

export class IndexedRollupBlock extends jspb.Message {
  getHash(): string;
  setHash(value: string): void;

  getHeight(): number;
  setHeight(value: number): void;

  getMerkleRoot(): string;
  setMerkleRoot(value: string): void;

  getPreviousHash(): string;
  setPreviousHash(value: string): void;

  getTxsHash(): string;
  setTxsHash(value: string): void;

  clearTxsList(): void;
  getTxsList(): Array<string>;
  setTxsList(value: Array<string>): void;
  addTxs(value: string, index?: number): string;

  getProposer(): string;
  setProposer(value: string): void;

  clearSignaturesList(): void;
  getSignaturesList(): Array<type_pb.TMultisig>;
  setSignaturesList(value: Array<type_pb.TMultisig>): void;
  addSignatures(value?: type_pb.Multisig, index?: number): type_pb.Multisig;

  getGenesisTime(): string;
  setGenesisTime(value: string): void;

  getRenaissanceTime(): string;
  setRenaissanceTime(value: string): void;

  getRollup(): string;
  setRollup(value: string): void;

  getMintedAmount(): string;
  setMintedAmount(value: string): void;

  getBurnedAmount(): string;
  setBurnedAmount(value: string): void;

  getRewardAmount(): string;
  setRewardAmount(value: string): void;

  getGovernance(): boolean;
  setGovernance(value: boolean): void;

  hasTokenInfo(): boolean;
  clearTokenInfo(): void;
  getTokenInfo(): type_pb.TIndexedTokenInput | undefined;
  setTokenInfo(value?: type_pb.TIndexedTokenInput): void;

  hasData(): boolean;
  clearData(): void;
  getData(): google_protobuf_any_pb.Any | undefined;
  setData(value?: google_protobuf_any_pb.Any): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TIndexedRollupBlock;
  static toObject(includeInstance: boolean, msg: IndexedRollupBlock): TIndexedRollupBlock;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: IndexedRollupBlock, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): IndexedRollupBlock;
  static deserializeBinaryFromReader(message: IndexedRollupBlock, reader: jspb.BinaryReader): IndexedRollupBlock;
}

export type TIndexedRollupBlock = {
  hash: string,
  height: number,
  merkleRoot: string,
  previousHash: string,
  txsHash: string,
  txs: Array<string>,
  proposer: string,
  signatures: Array<type_pb.TMultisig>,
  genesisTime: string,
  renaissanceTime: string,
  rollup: string,
  mintedAmount: string,
  burnedAmount: string,
  rewardAmount: string,
  governance: boolean,
  tokenInfo?: type_pb.TIndexedTokenInput,
  data?: google_protobuf_any_pb.Any,
}

export class SearchResult extends jspb.Message {
  getType(): string;
  setType(value: string): void;

  getId(): string;
  setId(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TSearchResult;
  static toObject(includeInstance: boolean, msg: SearchResult): TSearchResult;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SearchResult, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SearchResult;
  static deserializeBinaryFromReader(message: SearchResult, reader: jspb.BinaryReader): SearchResult;
}

export type TSearchResult = {
  type: string,
  id: string,
}

export class IndexedRollupValidator extends jspb.Message {
  getPk(): string;
  setPk(value: string): void;

  getAddress(): string;
  setAddress(value: string): void;

  getMoniker(): string;
  setMoniker(value: string): void;

  getEndpoint(): string;
  setEndpoint(value: string): void;

  getJoinTime(): string;
  setJoinTime(value: string): void;

  getLeaveTime(): string;
  setLeaveTime(value: string): void;

  getGenesisTime(): string;
  setGenesisTime(value: string): void;

  getRenaissanceTime(): string;
  setRenaissanceTime(value: string): void;

  getTotalStake(): string;
  setTotalStake(value: string): void;

  getRevokedStake(): string;
  setRevokedStake(value: string): void;

  getAvailableStake(): string;
  setAvailableStake(value: string): void;

  getTotalGain(): string;
  setTotalGain(value: string): void;

  getProposedBlockCount(): number;
  setProposedBlockCount(value: number): void;

  getVerifiedBlockCount(): number;
  setVerifiedBlockCount(value: number): void;

  getLatestBlockHeight(): number;
  setLatestBlockHeight(value: number): void;

  getLatestBlockHash(): string;
  setLatestBlockHash(value: string): void;

  getRollup(): string;
  setRollup(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TIndexedRollupValidator;
  static toObject(includeInstance: boolean, msg: IndexedRollupValidator): TIndexedRollupValidator;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: IndexedRollupValidator, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): IndexedRollupValidator;
  static deserializeBinaryFromReader(message: IndexedRollupValidator, reader: jspb.BinaryReader): IndexedRollupValidator;
}

export type TIndexedRollupValidator = {
  pk: string,
  address: string,
  moniker: string,
  endpoint: string,
  joinTime: string,
  leaveTime: string,
  genesisTime: string,
  renaissanceTime: string,
  totalStake: string,
  revokedStake: string,
  availableStake: string,
  totalGain: string,
  proposedBlockCount: number,
  verifiedBlockCount: number,
  latestBlockHeight: number,
  latestBlockHash: string,
  rollup: string,
}

export interface DirectionMap {
  MUTUAL: 0;
  ONE_WAY: 1;
  UNION: 2;
}

export const Direction: DirectionMap;

export interface ValidityMap {
  BOTH: 0;
  VALID: 1;
  INVALID: 2;
}

export const Validity: ValidityMap;

